/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{_ as e}from"../../chunks/tslib.es6.js";import"../../geometry.js";import{rasterRendererTypes as t,websceneRasterRendererTypes as s,read as r}from"../../rasterRenderers.js";import i from"../../request.js";import{d as o}from"../../core/Accessor.js";import n from"../../core/Error.js";import{L as a}from"../../chunks/Logger.js";import{property as l}from"../../core/accessorSupport/decorators/property.js";import{a as c,I as m}from"../../chunks/ensureType.js";import"../../core/lang.js";import{e as p}from"../../chunks/enumeration.js";import{r as u}from"../../chunks/reader.js";import{subclass as h}from"../../core/accessorSupport/decorators/subclass.js";import{l as d}from"../../chunks/unitUtils.js";import{s as f}from"../../chunks/arcgisLayerUrl.js";import{u as y}from"../../chunks/commonProperties2.js";import g from"../support/DimensionalDefinition.js";import x from"../support/MultidimensionalSubset.js";import b,{i as j}from"../support/RasterFunction.js";import{R}from"../../chunks/RasterJobHandler.js";import I from"../support/TileInfo.js";import k from"../../geometry/Polygon.js";import{JSONSupport as S}from"../../core/JSONSupport.js";import{onAbort as w}from"../../core/promiseUtils.js";import v from"../support/LOD.js";import{R as T}from"../support/RasterInfo.js";import{i as F,g as _,c as C,a as P,b as D,h as J,d as M,e as H}from"../../chunks/multidimensionalUtils.js";import{g as B,a as z,p as E,d as O,b as U}from"../../chunks/RawBlockCache.js";import{c as L}from"../../chunks/pixelRangeUtils.js";import{d as N,R as A}from"../../chunks/RasterSymbolizer.js";import{m as W,b as V,d as G,e as q,f as $,c as Q}from"../../chunks/vectorFieldUtils.js";import{d as K,l as X,e as Y,s as Z,f as ee,h as te,a as se,c as re,i as ie,b as oe,j as ne}from"../../chunks/rasterProjectionHelper.js";import{Q as ae}from"../../chunks/QueueProcessor.js";import le from"../../geometry/Point.js";import ce from"../../geometry/Extent.js";import me from"../../geometry/SpatialReference.js";import{c as pe,s as ue,a as he}from"../../chunks/rasterFunctionHelper.js";import de from"../../rest/support/FeatureSet.js";import{g as fe}from"../../chunks/stretchUtils.js";import{n as ye,g as ge,m as xe,o as be,h as je,p as Re,q as Ie}from"../../chunks/rasterRendererHelper.js";import ke from"../../rest/support/ImageHistogramParameters.js";import{c as Se}from"../../chunks/dataUtils.js";import"../../geometry/Geometry.js";import"../../core/Handles.js";import"../../chunks/maybe.js";import"../../chunks/metadata.js";import"../../chunks/utils.js";import"../../chunks/handleUtils.js";import"../../chunks/ObservableBase.js";import"../../chunks/tracking.js";import"../../core/scheduling.js";import"../../config.js";import"../../chunks/jsonMap.js";import"../../chunks/assets.js";import"../../core/urlUtils.js";import"../../kernel.js";import"../../chunks/writer.js";import"../../geometry/Multipoint.js";import"../../chunks/zmUtils.js";import"../../geometry/support/webMercatorUtils.js";import"../../core/accessorSupport/decorators/cast.js";import"../../geometry/Polyline.js";import"../../chunks/extentUtils.js";import"../../chunks/boundsUtils.js";import"../../chunks/aaBoundingRect.js";import"../../chunks/mathUtils.js";import"../../chunks/typeUtils.js";import"../../geometry/support/jsonUtils.js";import"../../chunks/coordsUtils.js";import"../../chunks/Axis.js";import"../../renderers/ClassBreaksRenderer.js";import"../../symbols.js";import"../../symbols/CIMSymbol.js";import"../support/fieldUtils.js";import"../../core/sql.js";import"../../intl.js";import"../../chunks/date.js";import"../../chunks/locale.js";import"../../chunks/datetime.js";import"../../chunks/number.js";import"../../chunks/substitute.js";import"../../chunks/messages.js";import"../../symbols/Symbol.js";import"../../Color.js";import"../../chunks/colorUtils.js";import"../../symbols/ExtrudeSymbol3DLayer.js";import"../../symbols/Symbol3DLayer.js";import"../../chunks/utils4.js";import"../../symbols/edges/Edges3D.js";import"../../chunks/screenUtils.js";import"../../chunks/materialUtils.js";import"../../chunks/opacityUtils.js";import"../../symbols/edges/SketchEdges3D.js";import"../../symbols/edges/SolidEdges3D.js";import"../../chunks/Symbol3DMaterial.js";import"../../chunks/vec3f64.js";import"../../symbols/FillSymbol.js";import"../../symbols/SimpleLineSymbol.js";import"../../symbols/LineSymbol.js";import"../../symbols/LineSymbolMarker.js";import"../../chunks/lineMarkers.js";import"../../symbols/FillSymbol3DLayer.js";import"../../symbols/patterns/LineStylePattern3D.js";import"../../symbols/patterns/StylePattern3D.js";import"../../chunks/utils5.js";import"../../chunks/colors.js";import"../../chunks/symbolLayerUtils3D.js";import"../../chunks/aaBoundingBox.js";import"../../symbols/Font.js";import"../../symbols/IconSymbol3DLayer.js";import"../../chunks/persistableUrlUtils.js";import"../../symbols/LabelSymbol3D.js";import"../../core/Collection.js";import"../../core/Evented.js";import"../../chunks/shared.js";import"../../chunks/SimpleObservable.js";import"../../symbols/Symbol3D.js";import"../../chunks/collectionUtils.js";import"../../portal/Portal.js";import"../../core/Loadable.js";import"../../core/Promise.js";import"../../portal/PortalGroup.js";import"../../portal/PortalQueryParams.js";import"../../portal/PortalQueryResult.js";import"../../portal/PortalUser.js";import"../../portal/PortalFolder.js";import"../../symbols/LineSymbol3DLayer.js";import"../../symbols/LineStyleMarker3D.js";import"../../core/Clonable.js";import"../../symbols/ObjectSymbol3DLayer.js";import"../../symbols/PathSymbol3DLayer.js";import"../../symbols/TextSymbol3DLayer.js";import"../../symbols/WaterSymbol3DLayer.js";import"../../symbols/support/StyleOrigin.js";import"../../chunks/Thumbnail.js";import"../../chunks/calloutUtils.js";import"../../symbols/callouts/Callout3D.js";import"../../symbols/callouts/LineCallout3D.js";import"../../symbols/support/Symbol3DVerticalOffset.js";import"../../symbols/LineSymbol3D.js";import"../../symbols/MarkerSymbol.js";import"../../symbols/MeshSymbol3D.js";import"../../symbols/PictureFillSymbol.js";import"../../chunks/urlUtils.js";import"../../symbols/PictureMarkerSymbol.js";import"../../symbols/PointSymbol3D.js";import"../../symbols/PolygonSymbol3D.js";import"../../core/reactiveUtils.js";import"../../chunks/asyncUtils.js";import"../../symbols/SimpleFillSymbol.js";import"../../symbols/SimpleMarkerSymbol.js";import"../../symbols/TextSymbol.js";import"../../symbols/WebStyleSymbol.js";import"../../renderers/Renderer.js";import"../../renderers/support/AuthoringInfo.js";import"../../renderers/support/AuthoringInfoVisualVariable.js";import"../../chunks/colorRamps.js";import"../../rest/support/AlgorithmicColorRamp.js";import"../../rest/support/ColorRamp.js";import"../../rest/support/MultipartColorRamp.js";import"../../renderers/mixins/VisualVariablesMixin.js";import"../../renderers/visualVariables/ColorVariable.js";import"../../renderers/visualVariables/VisualVariable.js";import"../../renderers/visualVariables/support/ColorStop.js";import"../../renderers/visualVariables/OpacityVariable.js";import"../../renderers/visualVariables/support/OpacityStop.js";import"../../renderers/visualVariables/RotationVariable.js";import"../../renderers/visualVariables/SizeVariable.js";import"../../renderers/visualVariables/support/SizeStop.js";import"../../chunks/sizeVariableUtils.js";import"../../chunks/visualVariableUtils.js";import"../../Graphic.js";import"../../PopupTemplate.js";import"../../popup/content.js";import"../../popup/content/AttachmentsContent.js";import"../../popup/content/Content.js";import"../../popup/content/CustomContent.js";import"../../popup/content/ExpressionContent.js";import"../../popup/ElementExpressionInfo.js";import"../../popup/content/FieldsContent.js";import"../../popup/FieldInfo.js";import"../../popup/support/FieldInfoFormat.js";import"../../popup/content/MediaContent.js";import"../../popup/content/BarChartMediaInfo.js";import"../../popup/content/mixins/ChartMediaInfo.js";import"../../popup/content/mixins/MediaInfo.js";import"../../popup/content/support/ChartMediaInfoValue.js";import"../../popup/content/support/ChartMediaInfoValueSeries.js";import"../../chunks/chartMediaInfoUtils.js";import"../../popup/content/ColumnChartMediaInfo.js";import"../../popup/content/ImageMediaInfo.js";import"../../popup/content/support/ImageMediaInfoValue.js";import"../../popup/content/LineChartMediaInfo.js";import"../../popup/content/PieChartMediaInfo.js";import"../../popup/content/RelationshipContent.js";import"../../popup/support/RelatedRecordsInfoFieldOrder.js";import"../../popup/content/TextContent.js";import"../../popup/content/UtilityNetworkAssociationsContent.js";import"../../popup/support/UtilityNetworkAssociationType.js";import"../../popup/ExpressionInfo.js";import"../../popup/LayerOptions.js";import"../../popup/RelatedRecordsInfo.js";import"../../support/actions/ActionBase.js";import"../../core/Identifiable.js";import"../../support/actions/ActionButton.js";import"../../support/actions/ActionToggle.js";import"../../chunks/compilerUtils.js";import"../../chunks/lengthUtils.js";import"../../renderers/support/ClassBreakInfo.js";import"../../chunks/commonProperties.js";import"../../symbols/support/jsonUtils.js";import"../../chunks/layerUtils.js";import"../../chunks/defaults.js";import"../../chunks/defaultsJSON.js";import"../../chunks/RendererLegendOptions.js";import"../../renderers/FlowRenderer.js";import"../../renderers/RasterColormapRenderer.js";import"../../renderers/support/ColormapInfo.js";import"../../chunks/colorRampUtils.js";import"../../chunks/colorUtils2.js";import"../../chunks/vec4.js";import"../../chunks/common.js";import"../../chunks/vec4f64.js";import"../../renderers/RasterShadedReliefRenderer.js";import"../../renderers/RasterStretchRenderer.js";import"../../chunks/stretchRendererUtils.js";import"../../renderers/UniqueValueRenderer.js";import"../../chunks/diffUtils.js";import"../../renderers/support/UniqueValue.js";import"../../renderers/support/UniqueValueClass.js";import"../../renderers/support/UniqueValueGroup.js";import"../../renderers/support/UniqueValueInfo.js";import"../../chunks/styleUtils.js";import"../../renderers/VectorFieldRenderer.js";import"../../geometry/support/normalizeUtils.js";import"../../chunks/normalizeUtilsCommon.js";import"../../chunks/simplify.js";import"../../chunks/utils9.js";import"../../chunks/utils10.js";import"../../chunks/utils12.js";import"../../chunks/jsonUtils.js";import"../../chunks/parser.js";import"../../chunks/utils2.js";import"../../chunks/mat4.js";import"../../symbols/support/cimSymbolUtils.js";import"../../chunks/utils7.js";import"../../chunks/enums2.js";import"../../chunks/LRUCache.js";import"../../chunks/MemCache.js";import"../support/PixelBlock.js";import"../../chunks/layerContainerType.js";import"../../chunks/ElevationInfo.js";import"../../chunks/unitConversionUtils.js";import"../../tables/AttributeTableTemplate.js";import"../../tables/elements/AttributeTableGroupElement.js";import"../../tables/elements/AttributeTableElement.js";import"../../tables/support/elements.js";import"../../tables/elements/AttributeTableAttachmentElement.js";import"../../tables/elements/AttributeTableFieldElement.js";import"../../tables/elements/AttributeTableRelationshipElement.js";import"../../core/workers/workers.js";import"../../core/workers/Connection.js";import"../../chunks/Queue.js";import"../../core/workers/RemoteClient.js";import"../../chunks/TileKey.js";import"../support/RasterBandInfo.js";import"../support/RasterSensorInfo.js";import"../../chunks/_commonjsHelpers.js";import"../../geometry/projection.js";import"../../chunks/projectBuffer.js";import"../../chunks/geodesicConstants.js";import"../../geometry/support/GeographicTransformation.js";import"../../geometry/support/GeographicTransformationStep.js";import"../../chunks/zscale.js";import"../../chunks/ReactiveMap.js";import"../../core/signal.js";import"../support/rasterFunctionConstants.js";import"../support/Field.js";import"../../chunks/domains.js";import"../support/CodedValueDomain.js";import"../support/Domain.js";import"../support/InheritedDomain.js";import"../support/RangeDomain.js";import"../../chunks/fieldType.js";import"../../chunks/focalStatUtils.js";import"../../chunks/generateRendererUtils.js";import"../support/MosaicRule.js";import"../../time/TimeExtent.js";import"../../chunks/timeUtils.js";let we=0,ve=class extends S{constructor(){super(...arguments),this._tileFetchQueue=new ae({concurrency:32,process:(e,t)=>this._fetchRawTile(e.pyramidLevel,e.row,e.col,{...e.options,signal:t})}),this.datasetName=null,this.datasetFormat=null,this.hasUniqueSourceStorageInfo=!0,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}normalizeCtorArgs(e){return e?.ioConfig&&(e={...e,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:I.create(),...e.ioConfig}}),e}get _isGlobalWrappableSource(){const{rasterInfo:e}=this,t=K(e.spatialReference);return null!=t&&e.extent.width>=t/2}get _hasNoneOrGCSShiftTransform(){const{transform:e}=this.rasterInfo;return null==e||"gcs-shift"===e.type}set rasterJobHandler(e){this._set("rasterJobHandler",e),"Function"===this.datasetFormat&&this.primaryRasters?.rasters?.forEach((t=>t.rasterJobHandler=e))}get rasterId(){return this.url||"rasterId-"+we++}set url(e){this._set("url",f(e,a.getLogger(this)))}async open(e){return this._openPromise??=X().then((()=>this._open(e))),this._openPromise}async fetchTile(e,t,s,r={}){const i=r.tileInfo||this.rasterInfo.storageInfo.tileInfo,o=this.getTileExtentFromTileInfo(e,t,s,i);return r={noClip:!0,...r},this.fetchPixels(o,i.size[0],i.size[1],r)}async identify(e,t={}){e=c(le,e).clone().normalize();const{multidimensionalDefinition:s,timeExtent:r}=t,{rasterInfo:i}=this,{hasMultidimensionalTranspose:o,multidimensionalInfo:n}=i;let{transposedVariableName:a}=t;const l=null!=n&&o&&(null!=r||F(s));l&&!a&&(a=null!=s&&s.length>0?s[0].variableName??void 0:n.variables[0].name,t={...t,transposedVariableName:a}),t=this._getRequestOptionsWithSliceId(t);const{spatialReference:m,extent:p}=i,{datumTransformation:u}=t;let h=Y(e,m,u);if(!p.intersects(h))return{location:h,value:null};if(null!=i.transform){const e=i.transform.inverseTransform(h);if(!i.nativeExtent.intersects(e))return{location:e,value:null};h=e}let d=0;const f=null!=a&&null!=n&&i.hasMultidimensionalTranspose;if("Function"===this.datasetFormat){const e=this.primaryRasters.rasters[0];if(f)return e.identify(h,t);const{pixelSize:r}=i,o=3,n=r.x*o/2,a=r.y*o/2,l=new ce({xmin:h.x-n,xmax:h.x+n,ymin:h.y-a,ymax:h.y+a,spatialReference:m}),c={interpolation:"nearest",multidimensionalDefinition:s,sliceId:t.sliceId},{pixelBlock:p}=await e.fetchPixels(l,o,o,c),{pixelBlock:u}=await this.fetchPixels(l,o,o,c);if(null==p)return{location:h,value:null};const d=Math.floor(o*o*.5),y=!p.mask||p.mask[d]?p.pixels.map((e=>e[d])):null;let g;return null!=u&&(g=!u.mask||u.mask[d]?u.pixels.map((e=>e[d])):void 0),{location:h,value:y,processedValue:g,pyramidLevel:0}}if(!f)if(t.srcResolution)d=Z(t.srcResolution,i,this.ioConfig.sampling).pyramidLevel;else if(d=await this.computeBestPyramidLevelForLocation(e,t),null==d)return{location:h,value:null};const y=this.identifyPixelLocation(h,d,null,f);if(null===y)return{location:h,value:null};const{row:g,col:x,rowOffset:b,colOffset:j,blockWidth:R}=y,I=a??t.sliceId,k=B(this.rasterId,I),S=`${d}/${g}/${x}`;let w=z(k,null,S);null==w&&(w=this.fetchRawTile(d,g,x,t),E(k,null,S,w));const v=await w;if(!v?.pixels?.length)return{location:h,value:null};const T=b*R+j;return this._processIdentifyResult(v,{srcLocation:h,position:T,pyramidLevel:d,useTransposedTile:!!f,requestSomeSlices:l,identifyOptions:t})}async fetchPixels(e,t,s,r={}){e=ee(e),r=this._getRequestOptionsWithSliceId(r);const{_hasNoneOrGCSShiftTransform:i}=this;if(r.requestRawData&&i)return this._fetchPixels(e,t,s,r);const o=K(e.spatialReference),n=te(e);if(null==o||0===n||1===n&&this._isGlobalWrappableSource&&i)return this._fetchPixels(e,t,s,r);if(n>=3)return{extent:e,pixelBlock:null};const a=[],{xmin:l,xmax:c}=e,m=Math.round(o/(c-l)*t),p=m-Math.round((o/2-l)/(c-l)*t);let u=0;const h=[];for(let i=0;i<=n;i++){const d=new ce({xmin:0===i?l:-o/2,xmax:i===n?c-o*i:o/2,ymin:e.ymin,ymax:e.ymax,spatialReference:e.spatialReference}),f=0===i?m-p:i===n?t-u:m;u+=f,h.push(f);const y=r.disableWrapAround&&i>0?null:this._fetchPixels(d,f,s,r);a.push(y)}const d=(await Promise.all(a)).map((e=>e?.pixelBlock));let f=null;const y={width:t,height:s};return f=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:d,srcMosaicSize:y,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:h},r)).pixelBlock:W(d,y,{blockWidths:h}),{extent:e,srcExtent:se(e,this.rasterInfo.spatialReference,r.datumTransformation),pixelBlock:f}}async fetchRawPixels(e,t,s,r={}){t={x:Math.floor(t.x),y:Math.floor(t.y)};const i=await this._fetchRawTiles(e,t,s,r),{nativeExtent:o,nativePixelSize:n,storageInfo:a}=this.rasterInfo,l=2**e,c=n.x*l,m=n.y*l,p=new ce({xmin:o.xmin+c*t.x,xmax:o.xmin+c*(t.x+s.width-1),ymin:o.ymax-m*(t.y+s.height-1),ymax:o.ymax-m*t.y,spatialReference:o.spatialReference});if(!i)return{extent:p,srcExtent:p,pixelBlock:null};const{pixelBlocks:u,mosaicSize:h}=i;if(1===u.length&&null!=u[0]&&u[0].width===s.width&&u[0].height===s.height)return{extent:p,srcExtent:p,pixelBlock:i.pixelBlocks[0]};const d=e>0?a.pyramidBlockWidth:a.blockWidth,f=e>0?a.pyramidBlockHeight:a.blockHeight,y={x:t.x%d,y:t.y%f};let g;return g=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:u,srcMosaicSize:h,destDimension:s,clipOffset:y,clipSize:s,coefs:null,sampleSpacing:null,interpolation:r.interpolation,alignmentInfo:null,blockWidths:null},r)).pixelBlock:W(u,h,{clipOffset:y,clipSize:s}),{extent:p,srcExtent:p,pixelBlock:g}}fetchRawTile(e,t,s,r){throw new n("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(e){return se(this.rasterInfo.extent,e)}decodePixelBlock(e,t){return!this.rasterJobHandler||t.useCanvas?N(e,t):this.rasterJobHandler.decode({data:e,options:t})}async request(e,t,s=0){const{customFetchParameters:r}=this.ioConfig,{range:o,query:n,headers:a}=t;s=s??t.retryCount??this.ioConfig.retryCount;const l=o?{Range:`bytes=${o.from}-${o.to}`}:null;try{return await i(e,{...t,query:{...n,...r},headers:{...a,...l}})}catch(r){if(s>0)return s--,this.request(e,t,s);throw r}}getSliceIndex(e){const{multidimensionalInfo:t}=this.rasterInfo;return null==t||null==e||0===e.length?null:_(e,t)}getTileExtentFromTileInfo(e,t,s,r){const i=r.lodAt(e);return this.getTileExtent({x:i.resolution,y:i.resolution},t,s,r.origin,r.spatialReference,r.size)}updateTileInfo(){const{storageInfo:e,spatialReference:t,extent:s,pixelSize:r}=this.rasterInfo,{pyramidResolutions:i}=e;if(!e.tileInfo){const o=[],n=e.maximumPyramidLevel||0;let a=(r.x+r.y)/2,l=1/.0254*96*a;for(let e=0;e<=n&&(o.unshift(new v({level:n-e,resolution:a,scale:l})),e!==n);e++)if(i){const t=(i[e].x+i[e].y)/2;l*=t/a,a=t}else a*=2,l*=2;const c=new le({x:s.xmin,y:s.ymax,spatialReference:t});e.tileInfo=new I({origin:c,size:[e.blockWidth,e.blockHeight],spatialReference:t,lods:o}),e.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(e,t=512,s=512,r){const{width:i,height:o,nativeExtent:n,pixelSize:a,spatialReference:l}=e,c=new le({x:n.xmin,y:n.ymax,spatialReference:l});null==r&&(r=Math.max(0,Math.round(Math.log(Math.max(i,o))/Math.LN2-8)));const m=this.computeBlockBoundary(n,512,512,{x:n.xmin,y:n.ymax},[a],r);e.storageInfo=new T({blockWidth:t,blockHeight:s,pyramidBlockWidth:t,pyramidBlockHeight:s,origin:c,firstPyramidLevel:1,maximumPyramidLevel:r,blockBoundary:m})}async computeBestPyramidLevelForLocation(e,t={}){return 0}computeBlockBoundary(e,t,s,r,i,o=0,n=2){if(1===i.length&&o>0){i=[...i];let{x:e,y:t}=i[0];for(let s=0;s<o;s++)e*=n,t*=n,i.push({x:e,y:t})}const a=[],{x:l,y:c}=r;for(let r=0;r<i.length;r++){const{x:o,y:n}=i[r];a.push({minCol:Math.floor((e.xmin-l+.1*o)/t/o),maxCol:Math.floor((e.xmax-l-.1*o)/t/o),minRow:Math.floor((c-e.ymax+.1*n)/s/n),maxRow:Math.floor((c-e.ymin-.1*n)/s/n)})}return a}getPyramidPixelSize(e){const{nativePixelSize:t}=this.rasterInfo,{pyramidResolutions:s,pyramidScalingFactor:r}=this.rasterInfo.storageInfo;if(0===e)return t;if(null!=s&&s.length)return s[e-1];const i=r**e;return{x:t.x*i,y:t.y*i}}identifyPixelLocation(e,t,s,r){const{spatialReference:i,nativeExtent:o,storageInfo:n}=this.rasterInfo,{maximumPyramidLevel:a,origin:l,transposeInfo:c}=n,m=r&&null!=c?c.tileSize[0]:n.blockWidth,p=r&&null!=c?c.tileSize[1]:n.blockHeight,u=Y(e,i,s);if(!o.intersects(u))return null;if(t<0||t>a)return null;const h=this.getPyramidPixelSize(t),{x:d,y:f}=h,y=(l.y-u.y)/f/p,g=(u.x-l.x)/d/m,x=Math.min(p-1,Math.floor((y-Math.floor(y))*p)),b=Math.min(m-1,Math.floor((g-Math.floor(g))*m));return{pyramidLevel:t,row:Math.floor(y),col:Math.floor(g),rowOffset:x,colOffset:b,blockWidth:m,srcLocation:u}}getTileExtent(e,t,s,r,i,o){const[n,a]=o,l=r.x+s*n*e.x,c=l+n*e.x,m=r.y-t*a*e.y,p=m-a*e.y;return new ce({xmin:l,xmax:c,ymin:p,ymax:m,spatialReference:i})}getBlockWidthHeight(e){return{blockWidth:e>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:e>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(e,t,s){const r=this.rasterInfo.storageInfo.blockBoundary[e];return!r||r.maxRow<t||r.maxCol<s||r.minRow>t||r.minCol>s}updateImageSpaceRasterInfo(e){const{pixelSize:t}=e,{width:s,height:r}=e,i=me.WebMercator;e.spatialReference=i,e.extent=e.nativeExtent=new ce({xmin:-.5,ymax:.5,xmax:s-.5,ymin:.5-r,spatialReference:i}),e.isPseudoSpatialReference=!0,e.transform=null,e.pixelSize=new le({x:1,y:1,spatialReference:i});const{extent:o,storageInfo:n}=e;if(n){n.origin=new le({x:o.xmin,y:o.ymax,spatialReference:i});const{pyramidResolutions:s,tileInfo:r}=n;if(s&&s.forEach((e=>{e.x/=t.x,e.y/=t.y})),r){r.origin=n.origin;const t=(e.nativePixelSize.x+e.nativePixelSize.y)/2;r.lods.forEach(((e,s)=>{e.resolution=t*2**s,e.scale=96*e.resolution/.0254}))}}}async _fetchPixels(e,t,s,r={}){let i=te(e);if(i>=2)return{extent:e,pixelBlock:null};const o=this._getSourceDataInfo(e,t,s,r),{pyramidLevel:n,srcResolution:a,srcExtent:l,srcWidth:c,srcHeight:m,ul:p}=o;if(0===c||0===m)return{extent:e,srcExtent:l,pixelBlock:null};const{rasterInfo:u}=this,h=u.transform,d="gcs-shift"===h?.type,f=null!=K(e.spatialReference);!d&&f||(i=te(o.srcExtent,d));const y=await this._fetchRawTiles(n,p,{width:c,height:m,wrapCount:i},r);if(!y)return{extent:e,srcExtent:l,pixelBlock:null};const g=u.storageInfo,x=n>0?g.pyramidBlockWidth:g.blockWidth,b=n>0?g.pyramidBlockHeight:g.blockHeight;let{x:j,y:R}=u.pixelSize;if(n>0){const{pyramidResolutions:e,pyramidScalingFactor:t}=g;if(null!=e&&e[n-1])({x:j,y:R}=e[n-1]);else{const e=t**n;j*=e,R*=e}}const I=u.spatialReference,k=new le({x:j,y:R,spatialReference:I}),S=x===c&&b===m&&p.x%x==0&&p.y%b==0,w=new le({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/s,spatialReference:e.spatialReference}),v=!e.spatialReference.equals(I),T=I.isGeographic?1e-9:1e-4,{datumTransformation:F}=r,_=!v&&S&&1===y.pixelBlocks.length&&x===t&&b===s&&function(e,t,s){return Math.abs(e.x-t.x)<s&&Math.abs(e.y-t.y)<s}(a,w,T);if(_)return{extent:e,srcExtent:l,srcTilePixelSize:k,pixelBlock:y.pixelBlocks[0]};const C=f&&null!=K(l.spatialReference)&&this._hasNoneOrGCSShiftTransform,P=r.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");P&&!this.rasterJobHandler&&await X();const D=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:e,srcBufferExtent:y.extent,pixelSize:w.toJSON(),datumTransformation:F,rasterTransform:h,hasWrapAround:i>0||C,isAdaptive:!1!==this.ioConfig.optimizeProjectionAccuracy,includeGCSGrid:P},r):re({projectedExtent:e,srcBufferExtent:y.extent,pixelSize:w,datumTransformation:F,rasterTransform:h,hasWrapAround:i>0||C,isAdaptive:!1,includeGCSGrid:P});let J;const M=!r.requestRawData,H={rows:D.spacing[0],cols:D.spacing[1]},B=this._hasNoneOrGCSShiftTransform?this._getRasterTileAlignmentInfo(n,y.extent.xmin):void 0,{pixelBlocks:z,mosaicSize:E,isPartiallyFilled:O}=y;let U=null;if(this.rasterJobHandler){const e=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:z,srcMosaicSize:E,destDimension:M?{width:t,height:s}:null,coefs:M?D.coefficients:null,sampleSpacing:M?H:null,projectDirections:P,gcsGrid:P?D.gcsGrid:null,isUV:"vector-uv"===this.rasterInfo.dataType,interpolation:r.interpolation,alignmentInfo:B,blockWidths:null},r);({pixelBlock:J,localNorthDirections:U}=e)}else{const e=W(z,E,{alignmentInfo:B});J=M?V(e,{width:t,height:s},D.coefficients,H,r.interpolation):e,P&&D.gcsGrid&&(U=G({width:t,height:s},D.gcsGrid),J=q(J,this.rasterInfo.dataType,U))}return r.requestRawData||P?{extent:e,srcExtent:l,srcTilePixelSize:k,pixelBlock:J,transformGrid:D,localNorthDirections:U,isPartiallyFilled:O}:{extent:e,srcExtent:l,srcTilePixelSize:k,pixelBlock:J}}async _fetchRawTiles(e,t,s,r){const{origin:i,blockBoundary:o}=this.rasterInfo.storageInfo,{blockWidth:n,blockHeight:a}=this.getBlockWidthHeight(e);let{x:l,y:c}=t,{width:m,height:p,wrapCount:u}=s;const h=this._getRasterTileAlignmentInfo(e,0);r.buffer&&(l-=r.buffer.cols,c-=r.buffer.rows,m+=2*r.buffer.cols,p+=2*r.buffer.rows);let d=0,f=0,y=0;u&&null!=h&&(({worldColumnCountFromOrigin:f,originColumnOffset:y,rightPadding:d}=h),f*h.blockWidth-d>=l+m&&(d=0));const g=Math.floor(l/n),x=Math.floor(c/a),b=Math.floor((l+m+d-1)/n),j=Math.floor((c+p+d-1)/a),R=o[e];if(!R)return null;const{minRow:I,minCol:k,maxCol:S,maxRow:w}=R;if(0===u&&(j<I||b<k||x>w||g>S))return null;const v=new Array;let T=!1;const F=null==this.ioConfig.allowPartialFill?r.allowPartialFill:this.ioConfig.allowPartialFill;for(let t=x;t<=j;t++)for(let s=g;s<=b;s++){let i=s;if(!r.disableWrapAround&&u&&null!=h&&f<=s&&(i=s-f-y),t>=I&&i>=k&&w>=t&&S>=i){const s=this._tileFetchQueue.push({pyramidLevel:e,row:t,col:i,options:r},{signal:r.signal});F?v.push(new Promise((e=>{s.then((t=>e(t))).catch((()=>{T=!0,e(null)}))}))):v.push(s)}else v.push(Promise.resolve(null))}if(0===v.length)return null;const _=await Promise.all(v),C={height:(j-x+1)*a,width:(b-g+1)*n},{spatialReference:P}=this.rasterInfo,D=this.getPyramidPixelSize(e),{x:J,y:M}=D;return{extent:new ce({xmin:i.x+g*n*J,xmax:i.x+(b+1)*n*J,ymin:i.y-(j+1)*a*M,ymax:i.y-x*a*M,spatialReference:P}),pixelBlocks:_,mosaicSize:C,isPartiallyFilled:T}}_fetchRawTile(e,t,s,r){const i=this.rasterInfo.storageInfo.blockBoundary[e];if(!i)return Promise.resolve(null);const{minRow:o,minCol:n,maxCol:a,maxRow:l}=i;if(t<o||s<n||t>l||s>a)return Promise.resolve(null);const c=B(this.rasterId,r.sliceId),m=`${e}/${t}/${s}`;let p=z(c,r.registryId,m);if(null==p){const i=new AbortController;p=this.fetchRawTile(e,t,s,{...r,signal:i.signal}),E(c,r.registryId,m,p,i),p.catch((()=>O(c,r.registryId,m)))}return r.signal&&w(r,(()=>{U(c,r.registryId,m)})),p}_computeMagDirValues(e){const{bandCount:t,dataType:s}=this.rasterInfo;if((2!==t||"vector-magdir"!==s)&&"vector-uv"!==s||2!==e?.length||!e[0]?.length)return null;const r=e[0].length;if("vector-magdir"===s){const t=e[1].map((e=>(e+360)%360));return[e[0],t]}const[i,o]=e,n=[],a=[];for(let e=0;e<r;e++){const[t,s]=$([i[e],o[e]]);n.push(t),a.push(s)}return[n,a]}_getRasterTileAlignmentInfo(e,t){return null==this._rasterTileAlignmentInfo&&(this._rasterTileAlignmentInfo=ie(this.rasterInfo)),null==this._rasterTileAlignmentInfo.pyramidsInfo?null:{startX:t,halfWorldWidth:this._rasterTileAlignmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlignmentInfo.hasGCSSShiftTransform,...this._rasterTileAlignmentInfo.pyramidsInfo[e]}}_getSourceDataInfo(e,t,s,r={}){const i={datumTransformation:r.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0,ul:{x:0,y:0}};r.srcResolution&&(i.srcResolution=r.srcResolution,this._updateSourceDataInfo(e,i));const o=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:n,srcHeight:a,pyramidLevel:l}=i,c=n/t,m=a/s,p=l<o&&c*m>=16,u=l===o&&this._requireTooManySrcTiles(n,a,t,s);if(p||u||0===n||0===a){const n=new le({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/s,spatialReference:e.spatialReference});let a=oe(n,this.rasterInfo.spatialReference,e,i.datumTransformation);const u=!a||r.srcResolution&&a.x+a.y<r.srcResolution.x+r.srcResolution.y;if(p&&r.srcResolution&&u){const e=Math.round(Math.log(Math.max(c,m))/Math.LN2)-1;if(o-l+3>=e){const t=2**e;a={x:r.srcResolution.x*t,y:r.srcResolution.y*t}}}a&&(i.srcResolution=a,this._updateSourceDataInfo(e,i))}return this._requireTooManySrcTiles(i.srcWidth,i.srcHeight,t,s)&&(i.srcWidth=0,i.srcHeight=0),i}_requireTooManySrcTiles(e,t,s,r){const{tileInfo:i}=this.rasterInfo.storageInfo,o=e/s,n=t/r;return Math.ceil(e/i.size[0])*Math.ceil(t/i.size[1])>=256*Math.max(1,(s+r)/1024)||o>8||n>8}_updateSourceDataInfo(e,t){t.srcWidth=0,t.srcHeight=0;const{rasterInfo:s}=this,r=s.spatialReference,{srcResolution:i,datumTransformation:o}=t,{pyramidLevel:n,pyramidResolution:a,excessiveReading:l}=Z(i,s,this.ioConfig.sampling);if(l)return;let c=t.srcExtent||se(e,r,o);if(null==c)return;const m=s.transform;m&&(c=m.inverseTransform(c)),t.srcExtent=c;const{x:p,y:u}=s.storageInfo.origin,h=Math.floor((c.xmin-p)/a.x+.1),d=Math.floor((u-c.ymax)/a.y+.1),f=Math.floor((c.xmax-p)/a.x-.1),y=Math.floor((u-c.ymin)/a.y-.1),g=c.width<.1*a.x?0:f-h+1,x=c.height<.1*a.y?0:y-d+1;t.pyramidLevel=n,t.pyramidResolution=a,t.srcWidth=g,t.srcHeight=x,t.ul={x:h,y:d}}_getRequestOptionsWithSliceId(e){return null!=this.rasterInfo.multidimensionalInfo&&null==e.sliceId&&(e={...e,sliceId:this.getSliceIndex(e.multidimensionalDefinition)}),e}_processIdentifyResult(e,t){const{srcLocation:s,position:r,pyramidLevel:i,useTransposedTile:o}=t,n=e.pixels[0].length/e.width/e.height;if(e.mask&&!e.mask[r])return{location:s,value:null};const{multidimensionalInfo:a}=this.rasterInfo;if(null==a||!o){const t=e.pixels.map((e=>e[r])),o={location:s,value:t,pyramidLevel:i},n=this._computeMagDirValues(t.map((e=>[e])));return n?.length&&(o.magdirValue=n.map((e=>e[0]))),o}let l=e.pixels.map((e=>e.slice(r*n,r*n+n))),c=this._computeMagDirValues(l);const{requestSomeSlices:m,identifyOptions:p}=t;let u=C(a,p.transposedVariableName);if(m){const e=P(u,p.multidimensionalDefinition,p.timeExtent);l=l.map((t=>e.map((e=>t[e])))),c=c?.map((t=>e.map((e=>t[e])))),u=e.map((e=>u[e]))}const h=e.noDataValues||this.rasterInfo.noDataValue,d={pixels:l,pixelType:e.pixelType};let f;return null!=h&&(L(d,h),f=d.mask),{location:s,value:null,dataSeries:u.map(((e,t)=>{const s={value:0===f?.[t]?null:l.map((e=>e[t])),multidimensionalDefinition:e.multidimensionalDefinition.map((e=>new g({...e,isSlice:!0})))};return c?.length&&(s.magdirValue=[c[0][t],c[1][t]]),s})),pyramidLevel:i}}};e([l()],ve.prototype,"_rasterTileAlignmentInfo",void 0),e([l()],ve.prototype,"_tileFetchQueue",void 0),e([l({readOnly:!0})],ve.prototype,"_isGlobalWrappableSource",null),e([l({readOnly:!0})],ve.prototype,"_hasNoneOrGCSShiftTransform",null),e([l()],ve.prototype,"_openPromise",void 0),e([l()],ve.prototype,"rasterJobHandler",null),e([l({readOnly:!0})],ve.prototype,"rasterId",null),e([l(y)],ve.prototype,"url",null),e([l({type:String,json:{write:!0}})],ve.prototype,"datasetName",void 0),e([l({type:String,json:{write:!0}})],ve.prototype,"datasetFormat",void 0),e([l()],ve.prototype,"hasUniqueSourceStorageInfo",void 0),e([l()],ve.prototype,"rasterInfo",void 0),e([l()],ve.prototype,"ioConfig",void 0),e([l()],ve.prototype,"sourceJSON",void 0),ve=e([h("esri.layers.support.rasterDatasets.BaseRaster")],ve);const Te=ve;let Fe=class extends Te{constructor(){super(...arguments),this.datasetFormat="Function",this.tileType="Raster",this.rasterFunction=null,this._clippingGeometry=new Map}async fetchPixels(e,t,s,r={}){const{rasters:i,rasterIds:o}=this.primaryRasters;let n=!1;const{interpolation:a}=r,l=this.rasterFunction.flatWebGLFunctionChain?.hasFocalFunction;!r.requestRawData&&l&&(n=1===i.length&&!r.skipRasterFunction,r={...r,interpolation:"bilinear",requestRawData:n});const c=i.map((i=>i.fetchPixels(e,t,s,r))),m=await Promise.all(c),p=m.map((e=>e.pixelBlock)),u=n||r.requestRawData?m.map((e=>e.srcTilePixelSize)):null;if(r.skipRasterFunction||p.every((e=>null==e)))return m[0];const h=m.find((e=>null!=e.pixelBlock))?.extent??e;let d=this.rasterJobHandler?await this.rasterJobHandler.process({extent:h,primaryPixelBlocks:p,primaryPixelSizes:u,primaryRasterIds:o}):this.rasterFunction.process({extent:h,primaryPixelBlocks:p,primaryPixelSizes:u,primaryRasterIds:o});const{transformGrid:f}=m[0];if(!n||null==d||null==f){const e=r.noClip?null:this.getClippingGeometry(h.spatialReference);return r.noClip||r.requestRawData||null==d||!e||(d=await pe(d,h,e)),{...m[0],pixelBlock:d}}const y={rows:f.spacing[0],cols:f.spacing[1]};let g;g=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:[d],srcMosaicSize:{width:d.width,height:d.height},destDimension:{width:t,height:s},coefs:f.coefficients,sampleSpacing:y,projectDirections:!1,gcsGrid:null,isUV:!1,interpolation:a,alignmentInfo:void 0,blockWidths:null},r)).pixelBlock:V(d,{width:t,height:s},f.coefficients,y,a);const x=r.noClip?null:this.getClippingGeometry(e.spatialReference);return r.noClip||r.requestRawData||null==g||null==x||(g=await pe(g,e,x)),{extent:e,srcExtent:m[0].srcExtent,pixelBlock:g}}getClippingGeometry(e){const t=this._clippingGeometry.get("0");if(!e||!t)return t;const s=function(e){return String(e.wkid??e.wkt??e.wkt2)}(e);let r=this._clippingGeometry.get(s);return null!=r||(r=e.equals(t.spatialReference)?t:ne(t,e),this._clippingGeometry.set(s,r)),r}async _open(e){const{rasterFunction:t}=this;this.primaryRasters?.rasters?.length?t.sourceRasters=this.primaryRasters.rasters:(this.primaryRasters=t.getPrimaryRasters(),this.rasterJobHandler&&this.primaryRasters.rasters?.forEach((e=>e.rasterJobHandler=this.rasterJobHandler)));const{rasters:s,rasterIds:r}=this.primaryRasters,i=s.map((t=>t.rasterInfo?void 0:t.open(e)));await Promise.all(i);const o=s.map((({rasterInfo:e})=>e)),a=t.bind({rasterInfos:o,rasterIds:r});if(t.rawSourceRasterInfos=o,!a.success||0===o.length)throw new n("raster-function:open",`cannot bind the function: ${a.error??""}`);const l="Table"===t.functionName?t:t.functionArguments?.raster;"Table"===l?.functionName&&(t.rasterInfo.attributeTable=de.fromJSON(l.functionArguments.attributeTableAsRecordSet)),await this.syncJobHandler();const c=o[0];this.hasUniqueSourceStorageInfo=1===o.length||o.slice(1).every((e=>function(e,t){const{storageInfo:s,pixelSize:r,spatialReference:i,extent:o}=e,{storageInfo:n,pixelSize:a,spatialReference:l,extent:c}=t;return r.x===a.x&&r.y===a.y&&i.equals(l)&&o.equals(c)&&s.blockHeight===n.blockHeight&&s.blockWidth===n.blockWidth&&s.maximumPyramidLevel===n.maximumPyramidLevel}(e,c))),this.set("sourceJSON",s[0].sourceJSON),this.set("rasterInfo",t.rasterInfo),await this._updateClipGeometry()}async syncJobHandler(){return this.rasterJobHandler?.updateRasterFunction(this.rasterFunction)}async _updateClipGeometry(){const e=this.rasterFunction.getClippingGeometries()[0];let t=e?.clippingGeometry;if(t&&"inside"===e.clippingType){const{extent:e}=this.rasterInfo,{difference:s,densify:r}=await import("../../geometry/geometryEngine.js");let i=r(k.fromExtent(e),2*(e.width+e.height)/40);i=ne(i,t.spatialReference),t=s(i,t)}this._clippingGeometry.clear(),t&&this._clippingGeometry.set("0",t)}};e([l({type:String,json:{write:!0}})],Fe.prototype,"datasetFormat",void 0),e([l()],Fe.prototype,"tileType",void 0),e([l()],Fe.prototype,"rasterFunction",void 0),e([l()],Fe.prototype,"primaryRasters",void 0),Fe=e([h("esri.layers.support.rasterDatasets.FunctionRaster")],Fe);const _e=Fe,Ce=k=>{let S=class extends k{constructor(...e){super(...e),this._isConstructedFromFunctionRaster=!1,this._rasterJobHandler={instance:null,refCount:0,connectionPromise:null},this.bandIds=null,this.copyright=null,this.interpolation=null,this.multidimensionalSubset=null,this.raster=null,this.serviceRasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.symbolizer=null,this._isConstructedFromFunctionRaster="Function"===e[0]?.raster?.datasetFormat}get fullExtent(){return this.serviceRasterInfo?.extent}set multidimensionalDefinition(e){this._set("multidimensionalDefinition",e),this.updateRenderer()}set rasterFunction(e){"none"===e?.functionName?.toLowerCase()&&(e=void 0),this._set("rasterFunction",e),this.updateRasterFunction()}get rasterInfo(){return o(a.getLogger(this),"rasterInfo",{replacement:"serviceRasterInfo",version:"4.29",warnOnce:!0}),this._get("serviceRasterInfo")}set url(e){this._set("url",f(e,a.getLogger(this)))}get renderer(){if("imagery-tile"!==this.type)return this.internalRenderer;const{activePresetRendererName:e,presetRenderers:t}=this;if(e){const s=t?.find((({name:t})=>t===e));return s?.renderer.clone()}return this.internalRenderer}set renderer(e){"imagery-tile"===this.type&&(this.activePresetRendererName=null),this.internalRenderer=e}set internalRenderer(e){null==e&&null==this.rasterFunction?this._configDefaultRenderer("override"):(this._set("internalRenderer",e),this.updateRenderer())}readRenderer(e,t,s){const i=t?.layerDefinition?.drawingInfo?.renderer;return r(i,s)||void 0}async convertVectorFieldData(e,t){const{serviceRasterInfo:s}=this;if(null==e||!s)return null;const r=this._rasterJobHandler.instance,i=s.dataType;return r?r.convertVectorFieldData({pixelBlock:e,dataType:i},t):Q(e,i)}async computeStatisticsHistograms(e,t){await this.load(t),e=c(ke,e).clone();const{serviceRasterInfo:s}=this;if(null==s)throw new n("imagery-tile-mixin:compute-statistics-histograms","serviceRasterInfo must be specified");const{geometry:r}=e;if(null==r)throw new n("imagery-tile-mixin:compute-statistics-histograms","geometry must be specified");let i=r;const{spatialReference:o}=s;r.spatialReference.equals(o)||(await X(),i="extent"===r.type?se(r,o):ne(r,o));const a=e.pixelSize??new le({x:s.pixelSize.x,y:s.pixelSize.y,spatialReference:o}),{extent:l,width:m,height:p}=ue(s,i,a),u=await this.fetchPixels(l,m,p,{...t,interpolation:"nearest"});if(null==u.pixelBlock)throw new n("imagery-tile-mixin:compute-statistics-histograms","failed to fetch pixels");const h=await pe(u.pixelBlock,l,i),d=this._rasterJobHandler.instance;return d?d.computeStatisticsHistograms({pixelBlock:h},t):fe(h)}async createFlowMesh(e,t){const s=this._rasterJobHandler.instance;return s?s.createFlowMesh(e,t):Se(e.meshType,e.simulationSettings,e.flowData,null!=t.signal?t.signal:(new AbortController).signal)}normalizeRasterFetchOptions(e){const{multidimensionalInfo:t}=this.serviceRasterInfo??{};if(null==t)return e;let s=e.multidimensionalDefinition||this.multidimensionalDefinition;s?.length||(s=D(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset}));const r=e.timeExtent||this.timeExtent;if(null!=s&&null!=r&&(null!=r.start||null!=r.end)){s=s.map((e=>e.clone()));const i=t.variables.find((({name:e})=>e===s[0].variableName))?.dimensions?.find((({name:e})=>"StdTime"===e)),o=s.find((({dimensionName:e})=>"StdTime"===e));if(!i||!o)return{...e,multidimensionalDefinition:null};const{start:n,end:a}=r,l=null==n?null:n.getTime(),c=null==a?null:a.getTime(),m=l??c,p=c??l;if(null!=i.values){const e=i.values.filter((e=>{if(Array.isArray(e)){if(m===p)return e[0]<=m&&e[1]>=m;const t=e[0]<=m&&e[1]>m||e[0]<p&&e[1]>=p,s=e[0]>=m&&e[1]<=p||e[0]<m&&e[1]>p;return t||s}return m===p?e===m:e>=m&&e<=p}));if(e.length){const t=e.sort(((e,t)=>{const s=Array.isArray(e)?e[0]:e,r=Array.isArray(e)?e[1]:e,i=Array.isArray(t)?t[0]:t,o=Array.isArray(t)?t[1]:t;return m===p?s-i:Math.abs(r-p)-Math.abs(o-p)}))[0];o.values=[t]}else s=null}else if(i.hasRegularIntervals&&i.extent){const[e,t]=i.extent;m>t||p<e?s=null:o.values=m===p?[m]:[Math.max(e,m),Math.min(t,p)]}}return null!=s&&J(s,this.multidimensionalSubset)?{...e,multidimensionalDefinition:null}:{...e,multidimensionalDefinition:s}}async updateRasterFunction(){if(!this.loaded||"imagery-tile"!==this.type||!this.rasterFunction&&!this._cachedRasterFunctionJson||JSON.stringify(this.rasterFunction)===JSON.stringify(this._cachedRasterFunctionJson))return;if(this._isConstructedFromFunctionRaster&&"Function"===this.raster.datasetFormat){const e=this.raster.rasterFunction.toJSON();return!this.rasterFunction&&e&&this._set("rasterFunction",b.fromJSON(e)),void(this._cachedRasterFunctionJson=this.rasterFunction?.toJSON())}let e,t=this.raster,s=!1;"Function"===t.datasetFormat?(e=t.primaryRasters.rasters,t=e[0],s=!0):e=[t];const{rasterFunction:r}=this;if(r){const s={raster:t};e.length>1&&e.forEach((e=>s[e.url]=e));const i=he(r.functionDefinition?.toJSON()??r.toJSON(),s),o=new _e({rasterFunction:i});o.rasterJobHandler=this._rasterJobHandler.instance,await o.open(),this._cachedRasterFunctionJson=this.rasterFunction?.toJSON(),this.raster=o}else this.raster=t,this._cachedRasterFunctionJson=null,await t.open();if(this._cachedRendererJson=null,!s&&!r)return;const{bandIds:i}=this,{bandCount:o}=this.raster.rasterInfo,n=i?.length?i.some((e=>e>=o)):o>=3;i&&(n||this.renderer&&"raster-stretch"!==this.renderer.type)&&this._set("bandIds",null),this._configDefaultRenderer("auto")}async updateRenderer(){const{loaded:e,symbolizer:t}=this;if(!e||!t||!this.renderer)return;const{rasterInfo:s}=this.raster,r=M(s,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),i=r?.name,o=ye({...this.renderer.toJSON(),variableName:i});if(JSON.stringify(this._cachedRendererJson)===JSON.stringify(o))return;const n=this._rasterJobHandler.instance;n&&(t.rasterInfo=ge(s,i),t.rendererJSON=o,t.bind(),await n.updateSymbolizer(t),this._cachedRendererJson=o)}async applyRenderer(e,t){const s=e?.pixelBlock;if(!(null!=s&&s.pixels&&s.pixels.length>0))return null;let r;await this.updateRenderer();const i=this._rasterJobHandler.instance,o=this.bandIds??[];return r=i?await i.symbolize({...e,simpleStretchParams:t,bandIds:o}):this.symbolizer.symbolize({...e,simpleStretchParams:t,bandIds:o}),r}getTileUrl(e,t,s){return"RasterTileServer"===this.raster.datasetFormat?`${this.url}/tile/${e}/${t}/${s}`:""}getCompatibleTileInfo(e,t,s=!1){if(!this.loaded||null==t)return null;if(s&&e.equals(this.spatialReference))return this.tileInfo;const r=d(e);return I.create({size:256,spatialReference:e,origin:r?{x:r.origin[0],y:r.origin[1]}:{x:t.xmin,y:t.ymax}})}getCompatibleFullExtent(e){return this.loaded?(this._compatibleFullExtent?.spatialReference.equals(e)||(this._compatibleFullExtent=this.raster.computeExtent(e)),this._compatibleFullExtent):null}async fetchTile(e,t,s,r={}){if(w(this),r.requestAsImageElement){const o=this.getTileUrl(e,t,s);return i(o,{responseType:"image",query:{...this.refreshParameters,...this.raster.ioConfig.customFetchParameters},signal:r.signal}).then((e=>e.data))}const{serviceRasterInfo:o}=this;if(null!=o.multidimensionalInfo&&null==(r=this.normalizeRasterFetchOptions(r)).multidimensionalDefinition){const i=r.tileInfo||o.storageInfo.tileInfo;return{extent:this.raster.getTileExtentFromTileInfo(e,t,s,i),pixelBlock:null}}return await this._initJobHandler(),await this.updateRasterFunction(),"raster-shaded-relief"===this.renderer?.type&&(r={...r,buffer:{cols:1,rows:1}}),this.raster.fetchTile(e,t,s,r)}async fetchPixels(e,t,s,r={}){return null!=this.serviceRasterInfo.multidimensionalInfo&&null==(r=this.normalizeRasterFetchOptions(r)).multidimensionalDefinition?{extent:e,pixelBlock:null}:(await this._initJobHandler(),await this.updateRasterFunction(),t=Math.round(t),s=Math.round(s),this.raster.fetchPixels(e,t,s,r))}async identify(e,t={}){await this.load();const{raster:s,serviceRasterInfo:r}=this;if(null!=r?.multidimensionalInfo&&!(r.hasMultidimensionalTranspose&&(F(t.multidimensionalDefinition)||t.transposedVariableName||t.timeExtent)||null!=(t=this.normalizeRasterFetchOptions(t)).multidimensionalDefinition))return{location:e,value:null};const i=this.multidimensionalSubset?.areaOfInterest;if(i&&!i.contains(e))throw new n("imagery-tile-mixin:identify","the request cannot be fulfilled when falling outside of the multidimensional subset");return s.identify(e,t)}increaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount++}decreaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount--,this._rasterJobHandler.refCount<=0&&this._shutdownJobHandler()}hasStandardTime(){const e=this.serviceRasterInfo?.multidimensionalInfo;if(null==e||"standard-time"!==this.serviceRasterInfo?.dataType)return!1;const t=this.multidimensionalDefinition,s=t?.[0]?.variableName;return e.variables.some((e=>e.name===s&&(!t?.[0].dimensionName||e.dimensions.some((e=>"StdTime"===e.name)))))}getStandardTimeValue(e){return new Date(24*(e-25569)*3600*1e3).toString()}getMultidimensionalSubsetVariables(e){const t=e??this.serviceRasterInfo?.multidimensionalInfo;return H(this.multidimensionalSubset,t)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||(this.multidimensionalDefinition=D(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset})),this.rasterFunction&&"Function"===this.raster.datasetFormat&&(this._cachedRasterFunctionJson=this.rasterFunction.toJSON()),this._configDefaultRenderer()}_initJobHandler(){if(null!=this._rasterJobHandler.connectionPromise)return this._rasterJobHandler.connectionPromise;const e=new R;return this._rasterJobHandler.connectionPromise=e.initialize().then((async()=>{w(this),this._rasterJobHandler.instance=e,this.raster.rasterJobHandler=e,"Function"===this.raster.datasetFormat&&this.raster.syncJobHandler(),this.rasterFunction&&await this.updateRasterFunction().catch((()=>{})),this.renderer&&this.updateRenderer()})).catch((()=>{})),this._rasterJobHandler.connectionPromise}_shutdownJobHandler(){this._rasterJobHandler.instance&&this._rasterJobHandler.instance.destroy(),this._rasterJobHandler.instance=null,this._rasterJobHandler.connectionPromise=null,this._rasterJobHandler.refCount=0,this._cachedRendererJson=null,this.raster&&(this.raster.rasterJobHandler=null)}_configDefaultInterpolation(){if(null==this.interpolation){w(this);const{raster:e}=this,t=xe(e.rasterInfo,e.tileType,this.sourceJSON?.defaultResamplingMethod);this._set("interpolation",t)}}_configDefaultRenderer(e="no"){w(this);const{rasterInfo:t}=this.raster,s=M(t,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),r=s?.name,i=be({variableName:r,rasterFunctionName:this.rasterFunction?.functionName,presetRenderers:this.presetRenderers});if(!this.bandIds&&t.bandCount>1&&(this.bandIds=i?.bandIds??je(t)),!this.renderer||"override"===e){const e=Re(this.raster),s=i?.renderer??Ie(t,{bandIds:this.bandIds,variableName:r,rasterFunctionColorRamp:e}),o=t.statistics,n=o&&o.length>0?o[0]:null,a=n?.max??0,l=n?.min??0;"WCSServer"===this.raster.datasetFormat&&"raster-stretch"===s.type&&(a>1e24||l<-1e24)&&(s.dynamicRangeAdjustment=!0,s.customStatistics=null,"none"===s.stretchType&&(s.stretchType="min-max")),this.renderer=s}const o=ye({...this.renderer.toJSON(),variableName:r}),n=ge(t,r);this.symbolizer?(this.symbolizer.rendererJSON=o,this.symbolizer.rasterInfo=n):this.symbolizer=new A({rendererJSON:o,rasterInfo:n});const l=this.symbolizer.bind();if(l.success){if("auto"===e){const{colormap:e}=this.raster.rasterInfo,t=this.renderer;if(null!=e&&"raster-colormap"===t.type){const e=Ie(this.raster.rasterInfo);JSON.stringify(e)!==JSON.stringify(t)&&this._configDefaultRenderer("override")}else if("raster-stretch"===t.type){const e=this.bandIds?.length,s=t.customStatistics?.length;!t.dynamicRangeAdjustment&&s&&e&&s!==e&&this._configDefaultRenderer("override")}}}else a.getLogger(this).warn("imagery-tile-mixin",l.error||"The given renderer is not supported by the layer."),"auto"===e&&this._configDefaultRenderer("override")}};function w(e){if(!e.raster||!e.serviceRasterInfo)throw new n("imagery-tile","no raster")}return e([l({clonable:!1})],S.prototype,"_cachedRendererJson",void 0),e([l({clonable:!1})],S.prototype,"_cachedRasterFunctionJson",void 0),e([l({clonable:!1})],S.prototype,"_compatibleFullExtent",void 0),e([l({clonable:!1})],S.prototype,"_isConstructedFromFunctionRaster",void 0),e([l({clonable:!1})],S.prototype,"_rasterJobHandler",void 0),e([l({type:[m],json:{write:{overridePolicy(){return{enabled:!this.loaded||"Raster"===this.raster.tileType||"0,1,2"!==this.bandIds?.join(",")}}}}})],S.prototype,"bandIds",void 0),e([l({json:{origins:{service:{read:{source:"copyrightText"}}}}})],S.prototype,"copyright",void 0),e([l({json:{read:!1}})],S.prototype,"fullExtent",null),e([l({json:{write:{overridePolicy(){return{enabled:!this.loaded||"Raster"===this.raster.tileType||"bilinear"!==this.interpolation}}}}}),p(j)],S.prototype,"interpolation",void 0),e([l()],S.prototype,"ioConfig",void 0),e([l({type:[g],json:{write:!0}})],S.prototype,"multidimensionalDefinition",null),e([l({type:x,json:{write:!0}})],S.prototype,"multidimensionalSubset",void 0),e([l()],S.prototype,"raster",void 0),e([l({type:b,json:{name:"renderingRule",write:!0}})],S.prototype,"rasterFunction",null),e([l({readOnly:!0})],S.prototype,"rasterInfo",null),e([l()],S.prototype,"serviceRasterInfo",void 0),e([l()],S.prototype,"sourceJSON",void 0),e([l({readOnly:!0,type:me,json:{read:!1}})],S.prototype,"spatialReference",void 0),e([l({type:I})],S.prototype,"tileInfo",void 0),e([l(y)],S.prototype,"url",null),e([l()],S.prototype,"renderer",null),e([l({types:t,json:{name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy(){const e="raster-stretch"===this.renderer?.type&&"none"===this.renderer.stretchType&&!this.renderer.useGamma;return{enabled:!this.loaded||"Raster"===this.raster.tileType||!e}}},origins:{"web-scene":{types:s,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy:e=>({enabled:e&&"vector-field"!==e.type&&"flow"!==e.type})}}}}})],S.prototype,"internalRenderer",null),e([u("internalRenderer")],S.prototype,"readRenderer",null),e([l({clonable:!1})],S.prototype,"symbolizer",void 0),S=e([h("esri.layers.mixins.ImageryTileMixin")],S),S};export{Te as B,_e as F,Ce as ImageryTileMixin};
