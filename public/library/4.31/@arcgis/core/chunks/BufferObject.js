/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{j as t,k as e,l as s,m as i}from"../core/lang.js";import{L as n}from"./Logger.js";import{c as r}from"./Texture.js";import{B as _,U as a,R as u,D as f}from"./enums.js";const h=()=>n.getLogger("esri.views.webgl.BufferObject");class c{static createIndex(t,e,s){return new c(t,_.ELEMENT_ARRAY_BUFFER,e,s)}static createVertex(t,e,s){return new c(t,_.ARRAY_BUFFER,e,s)}static createUniform(t,e,s){return new c(t,_.UNIFORM_BUFFER,e,s)}static createPixelPack(t,e=a.STREAM_READ,s){const i=new c(t,_.PIXEL_PACK_BUFFER,e);return s&&i.setSize(s),i}static createPixelUnpack(t,e=a.STREAM_DRAW,s){return new c(t,_.PIXEL_UNPACK_BUFFER,e,s)}static createTransformFeedback(t,e=a.STATIC_DRAW,s){const i=new c(t,_.TRANSFORM_FEEDBACK_BUFFER,e);return i.setSize(s),i}constructor(t,e,s,i){this._context=t,this.bufferType=e,this.usage=s,this._glName=null,this._size=-1,this._indexType=void 0,t.instanceCounter.increment(u.BufferObject,this),this._glName=this._context.gl.createBuffer(),r(this._context.gl),i&&this.setData(i)}get glName(){return this._glName}get size(){return this._size}get indexType(){return this._indexType}get usedMemory(){if(this.bufferType===_.ELEMENT_ARRAY_BUFFER){if(this._indexType===f.UNSIGNED_INT)return 4*this._size;if(this._indexType===f.UNSIGNED_SHORT)return 2*this._size}return this._size}get _isVAOAware(){return this.bufferType===_.ELEMENT_ARRAY_BUFFER||this.bufferType===_.ARRAY_BUFFER}dispose(){this._context?.gl?(this._glName&&(this._context.gl.deleteBuffer(this._glName),this._glName=null),this._context.instanceCounter.decrement(u.BufferObject,this),this._context=null):this._glName&&h().warn("Leaked WebGL buffer object")}setSize(t,e=null){if(this.bufferType===_.ELEMENT_ARRAY_BUFFER&&null!=e)switch(this._indexType=e,e){case f.UNSIGNED_SHORT:t*=2;break;case f.UNSIGNED_INT:t*=4}this._setBufferData(t)}setData(i){if(!i)return;let n=i.byteLength;this.bufferType===_.ELEMENT_ARRAY_BUFFER&&(t(i)?this._indexType=f.UNSIGNED_BYTE:e(i)?(n/=2,this._indexType=f.UNSIGNED_SHORT):s(i)&&(n/=4,this._indexType=f.UNSIGNED_INT)),this._setBufferData(n,i)}_setBufferData(t,e=null){this._size=t;const s=this._context.getBoundVAO();this._isVAOAware&&this._context.bindVAO(null),this._context.bindBuffer(this);const i=this._context.gl;null!=e?i.bufferData(this.bufferType,e,this.usage):i.bufferData(this.bufferType,t,this.usage),r(i),this._isVAOAware&&this._context.bindVAO(s)}setSubData(t,e,s,i){if(!t)return;const n=this._context.getBoundVAO();this._isVAOAware&&this._context.bindVAO(null),this._context.bindBuffer(this);const{gl:_}=this._context;_.bufferSubData(this.bufferType,e*t.BYTES_PER_ELEMENT,t,s,i-s),r(_),this._isVAOAware&&this._context.bindVAO(n)}getSubData(t,e=0,s,n){if(s<0||n<0)return;const r=i(t)?t.BYTES_PER_ELEMENT:1;if(r*((s??0)+(n??0))>t.byteLength)return;e+r*(n??0)>this.usedMemory&&h().warn("Potential problem getting subdata: requested data exceeds buffer size!");const a=this._context.gl;this.bufferType===_.TRANSFORM_FEEDBACK_BUFFER?(this._context.bindBuffer(this,_.TRANSFORM_FEEDBACK_BUFFER),a.getBufferSubData(_.TRANSFORM_FEEDBACK_BUFFER,e,t,s,n),this._context.unbindBuffer(_.TRANSFORM_FEEDBACK_BUFFER)):(this._context.bindBuffer(this,_.COPY_READ_BUFFER),a.getBufferSubData(_.COPY_READ_BUFFER,e,t,s,n),this._context.unbindBuffer(_.COPY_READ_BUFFER))}async getSubDataAsync(t,e=0,s,i){await this._context.clientWaitAsync(),this.getSubData(t,e,s,i)}}export{c as B};
