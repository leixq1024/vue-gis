/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{id as e}from"../kernel.js";import r from"../request.js";import t from"../core/Error.js";import{throwIfAbortError as n}from"../core/promiseUtils.js";import{p as a}from"./arcgisLayerUrl.js";import o from"../portal/Portal.js";import i from"../portal/PortalItem.js";async function s(s,u){const f=a(s);if(!f)throw new t("invalid-url","Invalid scene service url");const y={...u,sceneServerUrl:f.url.path,layerId:f.sublayer??void 0};if(y.sceneLayerItem??=await async function(t){const a=(await l(t)).serviceItemId;if(!a)return null;const s=new i({id:a,apiKey:t.apiKey}),c=await async function(t){const a=e?.findServerInfo(t.sceneServerUrl);if(a?.owningSystemUrl)return a.owningSystemUrl;const o=t.sceneServerUrl.replace(/(.*\/rest)\/.*/i,"$1")+"/info";try{const e=(await r(o,{query:{f:"json"},responseType:"json",signal:t.signal})).data.owningSystemUrl;if(e)return e}catch(e){n(e)}return null}(t);null!=c&&(s.portal=new o({url:c}));try{return await s.load({signal:t.signal})}catch(e){return n(e),null}}(y),null==y.sceneLayerItem)return c(y.sceneServerUrl.replace("/SceneServer","/FeatureServer"),y);const m=await async function({sceneLayerItem:e,signal:r}){if(!e)return null;try{const t=(await e.fetchRelatedItems({relationshipType:"Service2Service",direction:"reverse"},{signal:r})).find((e=>"Feature Service"===e.type))||null;if(!t)return null;const n=new i({portal:t.portal,id:t.id});return await n.load(),n}catch(e){return n(e),null}}(y);if(!m?.url)throw new t("related-service-not-found","Could not find feature service through portal item relationship");y.featureServiceItem=m;const p=await c(m.url,y);return p.portalItem=m,p}async function l(e){if(e.rootDocument)return e.rootDocument;const t={query:{f:"json",...e.customParameters,token:e.apiKey},responseType:"json",signal:e.signal};try{const n=await r(e.sceneServerUrl,t);e.rootDocument=n.data}catch{e.rootDocument={}}return e.rootDocument}async function c(e,n){const o=a(e);if(!o)throw new t("invalid-feature-service-url","Invalid feature service url");const i=o.url.path,s=n.layerId;if(null==s)return{serverUrl:i};const c=l(n),u=n.featureServiceItem?await n.featureServiceItem.fetchData("json"):null,f=(u?.layers?.[0]||u?.tables?.[0])?.customParameters,y=e=>{const t={query:{f:"json",...f},responseType:"json",authMode:e,signal:n.signal};return r(i,t)},m=y("anonymous").catch((()=>y("no-prompt"))),[p,d]=await Promise.all([m,c]),v=d?.layers,w=p.data&&p.data.layers;if(!Array.isArray(w))throw new Error("expected layers array");if(Array.isArray(v)){for(let e=0;e<Math.min(v.length,w.length);e++)if(v[e].id===s)return{serverUrl:i,layerId:w[e].id}}else if(null!=s&&s<w.length)return{serverUrl:i,layerId:w[s].id};throw new Error("could not find matching associated sublayer")}export{s as f};
