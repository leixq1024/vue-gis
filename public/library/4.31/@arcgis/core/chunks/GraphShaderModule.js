/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{_ as e}from"./tslib.es6.js";import"../core/lang.js";import{L as t,n as r}from"./Logger.js";import n from"../core/Error.js";import{B as i}from"./BindType.js";import{a as s}from"./Util.js";import{g as o}from"../config.js";import"./Texture.js";import"./enums.js";import{P as a}from"./Program.js";import"./GLObjectType.js";import{b as c}from"./dataViewUtils.js";var u;!function(e){e[e.AnimatedMarker=0]="AnimatedMarker",e[e.Blend=1]="Blend",e[e.ComplexFill=2]="ComplexFill",e[e.ComplexOutlineFill=3]="ComplexOutlineFill",e[e.DotDensity=4]="DotDensity",e[e.Fill=5]="Fill",e[e.Grid=6]="Grid",e[e.Heatmap=7]="Heatmap",e[e.Label=8]="Label",e[e.Line=9]="Line",e[e.Magnifier=10]="Magnifier",e[e.Marker=11]="Marker",e[e.OutlineFill=12]="OutlineFill",e[e.Overlay=13]="Overlay",e[e.PatternFill=14]="PatternFill",e[e.PatternOutlineFill=15]="PatternOutlineFill",e[e.PieChart=16]="PieChart",e[e.Test=17]="Test",e[e.Text=18]="Text",e[e.TexturedLine=19]="TexturedLine"}(u||(u={}));class d{constructor(){this._includedModules=new Map}include(e,t){this._includedModules.has(e)?this._includedModules.get(e):(this._includedModules.set(e,t),e(this.builder,t))}}class h extends d{constructor(){super(...arguments),this.vertex=new f,this.fragment=new f,this.attributes=new m,this.varyings=new y,this.extensions=new g,this.constants=new b}get fragmentUniforms(){return this.fragment.uniforms.entries}get builder(){return this}generate(e,t=!0){const r=this.extensions.generateSource(e),n=this.attributes.generateSource(e),i=this.varyings.generateSource(e),s="vertex"===e?this.vertex:this.fragment,o=s.uniforms.generateSource(),a=s.code.generateSource(),c="vertex"===e?_:"#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n  precision highp sampler2D;\n#else\n  precision mediump float;\n  precision mediump sampler2D;\n#endif\n",u=this.constants.generateSource().concat(s.constants.generateSource());return`${t?"#version 300 es":""}\n${r.join("\n")}\n${c}\n${u.join("\n")}\n${o.join("\n")}\n${n.join("\n")}\n${i.join("\n")}\n${a.join("\n")}`}generateBindPass(e){const t=new Map;this.vertex.uniforms.entries.forEach((e=>{const r=e.bind[i.Pass];r&&t.set(e.name,r)})),this.fragment.uniforms.entries.forEach((e=>{const r=e.bind[i.Pass];r&&t.set(e.name,r)}));const r=Array.from(t.values()),n=r.length;return(t,i)=>{for(let s=0;s<n;++s)r[s](e,t,i)}}generateBindDraw(e){const t=new Map;this.vertex.uniforms.entries.forEach((e=>{const r=e.bind[i.Draw];r&&t.set(e.name,r)})),this.fragment.uniforms.entries.forEach((e=>{const r=e.bind[i.Draw];r&&t.set(e.name,r)}));const r=Array.from(t.values()),n=r.length;return(t,i,s)=>{for(let o=0;o<n;++o)r[o](e,s,t,i)}}}class l{constructor(){this._entries=new Map}add(...e){for(const t of e)this._add(t)}get(e){return this._entries.get(e)}_add(e){if(null!=e){if(this._entries.has(e.name)&&!this._entries.get(e.name).equals(e))throw new n(`Duplicate uniform name ${e.name} for different uniform type`);this._entries.set(e.name,e)}else t.getLogger("esri.views.3d.webgl-engine.core.shaderModules.shaderBuilder").error(`Trying to add null Uniform from ${(new Error).stack}.`)}generateSource(){return Array.from(this._entries.values()).map((e=>null!=e.arraySize?`uniform ${e.type} ${e.name}[${e.arraySize}];`:`uniform ${e.type} ${e.name};`))}get entries(){return Array.from(this._entries.values())}}class p{constructor(){this._entries=new Array}add(e){this._entries.push(e)}generateSource(){return this._entries}}class f extends d{constructor(){super(...arguments),this.uniforms=new l,this.code=new p,this.constants=new b}get builder(){return this}}class m{constructor(){this._entries=new Array}add(e,t){this._entries.push([e,t])}generateSource(e){return"fragment"===e?[]:this._entries.map((e=>`in ${e[1]} ${e[0]};`))}}class y{constructor(){this._entries=new Map}add(e,t){this._entries.has(e)&&s(this._entries.get(e)===t),this._entries.set(e,t)}generateSource(e){const t=new Array;return this._entries.forEach(((r,n)=>t.push("vertex"===e?`out ${r} ${n};`:`in ${r} ${n};`))),t}}class g{constructor(){this._entries=new Set}add(e){this._entries.add(e)}generateSource(e){const t="vertex"===e?g.ALLOWLIST_VERTEX:g.ALLOWLIST_FRAGMENT;return Array.from(this._entries).filter((e=>t.includes(e))).map((e=>`#extension ${e} : enable`))}}g.ALLOWLIST_FRAGMENT=["GL_EXT_shader_texture_lod","GL_OES_standard_derivatives"],g.ALLOWLIST_VERTEX=[];class b{constructor(){this._entries=new Set}add(e,t,r){let n="ERROR_CONSTRUCTOR_STRING";switch(t){case"float":n=b._numberToFloatStr(r);break;case"int":n=b._numberToIntStr(r);break;case"bool":n=r.toString();break;case"vec2":n=`vec2(${b._numberToFloatStr(r[0])},                            ${b._numberToFloatStr(r[1])})`;break;case"vec3":n=`vec3(${b._numberToFloatStr(r[0])},                            ${b._numberToFloatStr(r[1])},                            ${b._numberToFloatStr(r[2])})`;break;case"vec4":n=`vec4(${b._numberToFloatStr(r[0])},                            ${b._numberToFloatStr(r[1])},                            ${b._numberToFloatStr(r[2])},                            ${b._numberToFloatStr(r[3])})`;break;case"ivec2":n=`ivec2(${b._numberToIntStr(r[0])},                             ${b._numberToIntStr(r[1])})`;break;case"ivec3":n=`ivec3(${b._numberToIntStr(r[0])},                             ${b._numberToIntStr(r[1])},                             ${b._numberToIntStr(r[2])})`;break;case"ivec4":n=`ivec4(${b._numberToIntStr(r[0])},                             ${b._numberToIntStr(r[1])},                             ${b._numberToIntStr(r[2])},                             ${b._numberToIntStr(r[3])})`;break;case"mat2":case"mat3":case"mat4":n=`${t}(${Array.prototype.map.call(r,(e=>b._numberToFloatStr(e))).join(", ")})`}return this._entries.add(`const ${t} ${e} = ${n};`),this}static _numberToIntStr(e){return e.toFixed(0)}static _numberToFloatStr(e){return Number.isInteger(e)?e.toFixed(1):e.toString()}generateSource(){return Array.from(this._entries)}}const _="precision highp float;\nprecision highp sampler2D;";function w(e,t){const r=[];for(r.push(t);r.length;){const t=r.pop();if("object"==typeof t&&!e.has(t.uid)){e.add(t.uid);for(const e of t.children)r.push(e)}}}class v{constructor(){this.uid=v.NodeCount++,this._debugName=null,this._isMutable=!1,this.isImplicit=!1}get isMutable(){return this._isMutable}setMutable(){return this._isMutable=!0,this}setDebugName(e){return e=e.split(" ").map(((e,t)=>t>0?e.charAt(0).toUpperCase()+e.slice(1):e)).join(""),this._debugName=e,this.isImplicit&&this.children[0]instanceof v&&this.children[0].setDebugName(e),this}get debugInfo(){return{name:this._debugName??""}}cloneInto(e){e._debugName=this._debugName,e._isMutable=this._isMutable,e.isImplicit=this.isImplicit,e.uid=this.uid}}function $(e){return"object"==typeof e?e.clone():e}v.NodeCount=0;class x extends v{constructor(){super(...arguments),this.shaderType="primitive-node"}}class I extends v{constructor(e){super(),this.child=e,this.shaderType="scope-node"}get children(){return[this.child]}clone(){const e=new I($(this.child));return this.cloneInto(e),e}}class T extends v{constructor(e,t,r){super(),this.property=e,this.target=t,this.returnType=r,this.shaderType="property-access-node"}get children(){const e=[this.target];return"string"!=typeof this.property&&e.push(this.property),e}clone(){const e=new T(this.property,$(this.target),this.returnType);return this.cloneInto(e),e}}class S extends v{constructor(e,t,r){super(),this.condition=e,this.ifTrue=t,this.ifFalse=r,this.shaderType="condition-node"}get children(){return[this.condition,this.ifTrue,this.ifFalse]}clone(){const e=$(this.ifTrue),t=this.ifFalse?$(this.ifFalse):null,r=new S(this.condition,e,t);return this.cloneInto(r),r}}class N extends v{constructor(e,t,r,n){super(),this.captureList=e,this.returnType=t,this.generator=n,this.shaderType="block-node",r&&(this.subgraph=new I(r))}get children(){return Object.keys(this.captureList).map((e=>this.captureList[e])).concat(this.subgraph??[])}clone(){const e={};for(const t in this.captureList)e[t]=$(this.captureList[t]);const t=new N(e,this.returnType,this.subgraph?$(this.subgraph.child):this.subgraph,this.generator);return this.cloneInto(t),t}}class F extends v{constructor(e,t,r,n,i,s=!1){super(),this.token=e,this._children=t,this.isInfix=r,this.isPropertyAccess=n,this.returnType=i,this.isTernary=s,this.shaderType="function-node"}get children(){return this._children}clone(){const e=new F(this.token,this._children.map($),this.isInfix,this.isPropertyAccess,this.returnType,this.isTernary);return this.cloneInto(e),e}}var k,M,E,P,C,U,O,K,j,L,B,V,A,D;function G(e){return new Proxy(e,{get(t,r){if("constructor"===r)return new Proxy(t.constructor,{construct:(e,t,r)=>G(new e(...t))});if(r in t)return t[r];if("string"==typeof r){const t=function(e){const t=[["float","vec2","vec3","vec4"],["int","ivec2","ivec3","ivec4"],["uint","uvec2","uvec3","uvec4"],["bool","bvec2","bvec3","bvec4"]];for(const r of t)if(r.includes(e))return r.map((e=>fe[e]));throw new Error("Unable to find type family")}(e.type);return ve(e,r,t[r.length-1])}}})}function z(e){return new Proxy(e,{construct:(e,t,r)=>G(new e(...t))})}class R extends Error{}let H=k=class extends x{constructor(e,t){super(),this.elementType=e,this.size=t,this.children=[],this.type="array"}clone(){const e=new k(this.elementType,this.size);return super.cloneInto(e),e}get(e){if("number"==typeof e){const t=new ae(e);return t.isImplicit=!0,ve(this,t,this.elementType.constructor)}return ve(this,e,this.elementType.constructor)}last(){return this.get(this.size-1)}first(){return this.get(0)}findIndex(e,t,r){return function(e,t,r=0,n=e.size){const i=new ae(r).setMutable().setDebugName("FindIndexIterator"),s=t(e.get(i)).setDebugName("FindIndexPredicate"),o=Ne({iter:i},ae,s,(({out:e,iter:t,subgraph:r})=>`\n${e} = -1;\n\nfor (; ${t} < ${n}; ${t}++) {\n\n${r.body}\n\n  if (${r.varName}) {\n    ${e} = ${t};\n    break;\n  }\n\n}\n`)).setDebugName("FindIndexBlock");return o}(this,e,t,r)}glslFindIndex(e,t,r){return function(e,t,r=0,n=e.size){const i=Ne({array:e},ae,null,(({out:e,array:i})=>`\n${e} = -1;\nfor (int i = ${r}; i < ${n}; i++) {\n  bool condition;\n  ${t({array:i,i:"i",out:"condition"})}\n  if (condition) {\n    ${e} = i;\n    break;\n  }\n}\n`)).setDebugName("GlslFindIndexBlock");return i}(this,e,t,r)}static ofType(e,t){const r={construct:(r,n)=>new k(new e,t)};return new Proxy(k,r)}};H.type="array",H=k=e([function(e){return new Proxy(e,{construct:(e,t,r)=>{return n=new e(...t),new Proxy(n,{get(e,t){if(t in e)return e[t];if("string"==typeof t){const e=parseInt(t,10);if(!isNaN(e))return ve(n,`[${e}]`,n.elementType.constructor)}}});var n}})}],H);class q extends x{constructor(){super(...arguments),this.type="sampler2D",this.children=[]}clone(){const e=new q;return e.children=this.children.map($),super.cloneInto(e),e}}q.type="sampler2D";class W extends x{constructor(e){super(),this.type="float",this.children=[e]}clone(){const e=new W($(this.children[0]));return super.cloneInto(e),e}multiply(e){return Me(this,"number"==typeof e?se(e,W):e)}divide(e){return Ee(this,"number"==typeof e?se(e,W):e)}add(e){return Pe(this,"number"==typeof e?se(e,W):e)}subtract(e){return Ce(this,"number"==typeof e?se(e,W):e)}}W.type="float";let X=M=class extends x{constructor(e,t){super(),this.type="vec2",this.children=[e,t].filter((e=>null!=e))}clone(){const e=new M($(this.children[0]),$(this.children[1]));return super.cloneInto(e),e}get 0(){return ve(this,"[0]",W)}get 1(){return ve(this,"[1]",W)}get 2(){throw new R}get 3(){throw new R}multiply(e){return Me(this,"number"==typeof e?se(e,W):e)}divide(e){return Ee(this,"number"==typeof e?se(e,W):e)}add(e){return Pe(this,"number"==typeof e?se(e,W):e)}subtract(e){return Ce(this,"number"==typeof e?se(e,W):e)}};X.type="vec2",X=M=e([z],X);let J=E=class extends x{constructor(e,t,r){super(),this.type="vec3",this.children=[e,t,r].filter((e=>null!=e))}get 0(){return ve(this,"[0]",W)}get 1(){return ve(this,"[1]",W)}get 2(){return ve(this,"[2]",W)}get 3(){throw new R}clone(){const e=new E($(this.children[0]),$(this.children[1]),$(this.children[2]));return super.cloneInto(e),e}multiply(e){return Me(this,"number"==typeof e?se(e,W):e)}divide(e){return Ee(this,"number"==typeof e?se(e,W):e)}add(e){return Pe(this,"number"==typeof e?se(e,W):e)}subtract(e){return Ce(this,"number"==typeof e?se(e,W):e)}};J.type="vec3",J=E=e([z],J);let Q=P=class extends x{constructor(e,t,r,n){super(),this.type="vec4",this.children=[e,t,r,n].filter((e=>null!=e))}clone(){const e=new P($(this.children[0]),$(this.children[1]),$(this.children[2]),$(this.children[3]));return super.cloneInto(e),e}get 0(){return ve(this,"[0]",W)}get 1(){return ve(this,"[1]",W)}get 2(){return ve(this,"[2]",W)}get 3(){return ve(this,"[3]",W)}multiply(e){return Me(this,"number"==typeof e?se(e,W):e)}divide(e){return Ee(this,"number"==typeof e?se(e,W):e)}add(e){return Pe(this,"number"==typeof e?se(e,W):e)}subtract(e){return Ce(this,"number"==typeof e?se(e,W):e)}};Q.type="vec4",Q=P=e([z],Q);let Y=C=class extends x{constructor(e){super(),this.type="uint",this.children=[e]}clone(){const e=new C($(this.children[0]));return super.cloneInto(e),e}};Y.type="uint",Y=C=e([z],Y);let Z=U=class extends x{constructor(e,t){super(),this.type="uvec2",this.children=[e,t].filter((e=>null!=e))}clone(){const e=new U($(this.children[0]),$(this.children[1]));return super.cloneInto(e),e}};Z.type="uvec2",Z=U=e([z],Z);let ee=O=class extends x{constructor(e,t,r){super(),this.type="uvec3",this.children=[e,t,r].filter((e=>null!=e))}clone(){const e=new O($(this.children[0]),$(this.children[1]),$(this.children[2]));return super.cloneInto(e),e}};ee.type="uvec3",ee=O=e([z],ee);let te=K=class extends x{constructor(e,t,r,n){super(),this.type="uvec4",this.children=[e,t,r,n].filter((e=>null!=e))}clone(){const e=new K($(this.children[0]),$(this.children[1]),$(this.children[2]),$(this.children[3]));return super.cloneInto(e),e}};te.type="uvec4",te=K=e([z],te);class re extends x{constructor(e){super(),this.type="bool",this.children=[e]}and(e){return Ge(this,e)}or(e){return De(this,e)}clone(){const e=new re($(this.children[0]));return super.cloneInto(e),e}}re.type="bool";let ne=j=class extends x{constructor(e,t){super(),this.type="bvec2",this.children=[e,t].filter((e=>null!=e))}all(){return Re(this)}any(){return He(this)}clone(){const e=new j($(this.children[0]),$(this.children[1]));return super.cloneInto(e),e}};ne.type="bvec2",ne=j=e([z],ne);let ie=L=class extends x{constructor(e,t,r){super(),this.type="bvec3",this.children=[e,t,r].filter((e=>null!=e))}all(){return Re(this)}any(){return He(this)}clone(){const e=new L($(this.children[0]),$(this.children[1]),$(this.children[2]));return super.cloneInto(e),e}};function se(e,t){return"number"==typeof e?new t(e):e}ie.type="bvec3",ie=L=e([z],ie);let oe=B=class extends x{constructor(e,t,r,n){super(),this.type="bvec4",this.children=[e,t,r,n].filter((e=>null!=e))}all(){return Re(this)}any(){return He(this)}clone(){const e=new B($(this.children[0]),$(this.children[1]),$(this.children[2]),$(this.children[3]));return super.cloneInto(e),e}};oe.type="bvec4",oe=B=e([z],oe);class ae extends x{constructor(e){super(),this.type="int",this.children=[e]}multiply(e){return Me(this,se(e,ae))}add(e){return Pe(this,se(e,ae))}subtract(e){return Ce(this,se(e,ae))}divide(e){return Ee(this,se(e,ae))}clone(){const e=new ae($(this.children[0]));return super.cloneInto(e),e}}ae.type="int";let ce=V=class extends x{constructor(e,t){super(),this.type="ivec2",this.children=[e,t].filter((e=>null!=e))}clone(){const e=new V($(this.children[0]),$(this.children[1]));return super.cloneInto(e),e}};ce.type="ivec2",ce=V=e([z],ce);let ue=A=class extends x{constructor(e,t,r){super(),this.type="ivec3",this.children=[e,t,r].filter((e=>null!=e))}clone(){const e=new A($(this.children[0]),$(this.children[1]),$(this.children[2]));return super.cloneInto(e),e}};ue.type="ivec3",ue=A=e([z],ue);let de=D=class extends x{constructor(e,t,r,n){super(),this.type="ivec4",this.children=[e,t,r,n].filter((e=>null!=e))}clone(){const e=new D($(this.children[0]),$(this.children[1]),$(this.children[2]),$(this.children[3]));return super.cloneInto(e),e}};de.type="ivec4",de=D=e([z],de);class he extends x{constructor(e,t,r,n){super(),this.type="mat2",this.children=[e,t,r,n]}clone(){const e=new he($(this.children[0]),$(this.children[1]),$(this.children[2]),$(this.children[3]));return super.cloneInto(e),e}multiply(e){return Me(this,e)}}he.type="mat2";class le extends x{static identity(){return new le(1,0,0,0,1,0,0,0,1)}static fromRotation(e){const t=dt(e),r=Je(e);return new le(r,t,0,Se(t),r,0,0,0,1)}constructor(e,t,r,n,i,s,o,a,c){super(),this.type="mat3",this.children=[e,t,r,n,i,s,o,a,c]}add(e){return Pe(this,e)}multiply(e){return Me(this,e)}clone(){const e=new le($(this.children[0]),$(this.children[1]),$(this.children[2]),$(this.children[3]),$(this.children[4]),$(this.children[5]),$(this.children[6]),$(this.children[7]),$(this.children[8]));return super.cloneInto(e),e}}le.type="mat3";class pe extends x{static identity(){return new pe(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)}constructor(e,t,r,n,i,s,o,a,c,u,d,h,l,p,f,m){super(),this.type="mat4",this.children=[e,t,r,n,i,s,o,a,c,u,d,h,l,p,f,m]}static fromColumns(e,t,r,n){return new pe(e.x,e.y,e.z,e.w,t.x,t.y,t.z,t.w,r.x,r.y,r.z,r.w,n.x,n.y,n.z,n.w)}multiply(e){return Me(this,e)}clone(){const e=new pe($(this.children[0]),$(this.children[1]),$(this.children[2]),$(this.children[3]),$(this.children[4]),$(this.children[5]),$(this.children[6]),$(this.children[7]),$(this.children[8]),$(this.children[9]),$(this.children[10]),$(this.children[11]),$(this.children[12]),$(this.children[13]),$(this.children[14]),$(this.children[15]));return super.cloneInto(e),e}}pe.type="mat4";const fe={float:W,vec2:X,vec3:J,vec4:Q,int:ae,ivec2:ce,ivec3:ue,ivec4:de,uint:Y,uvec2:Z,uvec3:ee,uvec4:te,bool:re,bvec2:ne,bvec3:ie,bvec4:oe},me=(...e)=>new ae(...e),ye=(...e)=>new W(...e),ge=(...e)=>new X(...e),be=(...e)=>new J(...e),_e=(...e)=>new Q(...e),we=(...e)=>new le(...e);function ve(e,t,r){const n=new r(new T(t,e,r));return n.isImplicit=!0,n}function $e(e,t,r,n=null){if(n){const i=new n,s=new n(new F(e,[t,r],!0,!1,i));return s.isImplicit=!0,s}if("float"===t.type||"int"===t.type){const n=new r.constructor(new F(e,[t,r],!0,!1,r.constructor));return n.isImplicit=!0,n}if(("mat2"===t.type||"mat3"===t.type||"mat4"===t.type)&&"float"!==r.type){const n=new r.constructor(new F(e,[t,r],!0,!1,r.constructor));return n.isImplicit=!0,n}const i=new t.constructor(new F(e,[t,r],!0,!1,t.constructor));return i.isImplicit=!0,i}function xe(e,t,r=t.constructor){const n=new r(new F(e,[t],!1,!1,r));return n.isImplicit=!0,n}function Ie(e,t,r,n=t.constructor){const i=new n(new F(e,[t,r],!1,!1,n));return i.isImplicit=!0,i}function Te(e,t,r,n,i=t.constructor){const s=new i(new F(e,[t,r,n],!1,!1,i));return s.isImplicit=!0,s}function Se(e){return Me(e,ye(-1))}function Ne(e,t,r,n){return new t(new N(e,t,r,n))}function Fe(e,t,r){const n="function"==typeof t?t():t,i="function"==typeof r?r():r,s=new n.constructor(new S(e,n,i));return s.isImplicit=!0,s}function ke(...e){const t=e.map((([e,t])=>"function"==typeof t?[e,t()]:[e,t])),r=t[0][1].constructor,n=t.findIndex((e=>!0===e[0]));if(-1===n)throw new Error("A cond must have a fallthrough case with `true`/; ");const i=t.slice(0,n),s=t[n][1],o=new r(i.reduceRight(((e,t)=>Fe(t[0],t[1],e)),s));return o.isImplicit=!0,o}function Me(e,t){return $e("*",e,t)}function Ee(e,t){return $e("/",e,t)}function Pe(e,t){return $e("+",e,t)}function Ce(e,t){return $e("-",e,t)}function Ue(e,t){return $e("%",e,t)}function Oe(e,t){return $e(">>",e,t)}function Ke(e,t){return $e("&",e,t)}function je(e,t){return $e("==",e,t,re)}function Le(e,t){return $e("<",e,t,re)}function Be(e,t){return $e("<=",e,t,re)}function Ve(e,t){return $e(">",e,t,re)}function Ae(e,t){return $e(">=",e,t,re)}function De(...e){return e.length<=1?e[0]:e.slice(1).reduce(((e,t)=>$e("||",e,t,re)),e[0])}function Ge(...e){return e.length<=1?e[0]:e.slice(1).reduce(((e,t)=>$e("&&",e,t,re)),e[0])}function ze(e){return xe("abs",e)}function Re(e){return xe("all",e,re)}function He(e){return xe("any",e,re)}function qe(e,t){return null==t?xe("atan",e):Ie("atan",e,t,e.constructor)}function We(e){return xe("ceil",e)}function Xe(e,t,r){return Te("clamp",e,t,r,e.constructor)}function Je(e){return xe("cos",e)}function Qe(e,t){return Ie("distance",e,t,W)}function Ye(e,t){return Ie("dot",e,t,W)}function Ze(e){return xe("floor",e)}function et(e){return xe("fract",e)}function tt(e){return xe("length",e,W)}function rt(e,t){return Ie("max",e,t)}function nt(e,t){return Ie("min",e,t)}function it(e,t,r){return Te("mix",e,t,r)}function st(e,t){return Ie("mod",e,t)}function ot(e){return xe("normalize",e)}function at(e){return"bool"===e.type?xe("!",e):xe("not",e)}function ct(e,t){return Ie("pow",e,t)}function ut(e){return xe("round",e)}function dt(e){return xe("sin",e)}function ht(e,t,r){return Te("smoothstep",e,t,r)}function lt(e){return xe("sqrt",e)}function pt(e,t){return Ie("step",e,t,t.constructor)}function ft(e,t){return Ie("texture",e,t,Q)}function mt(e,t,r){const n=t.split("\n");for(const t of n)if(t.trim().length){{let t="";null!=r&&(t+=`/*id:${r??"000"}*/   `),e.body+=t.padEnd(14)}e.body+=" ".repeat(e.indent)+t+"\n"}}class yt{write(e){for(const t of e.rootOutputNodes())e.shouldPruneOutputNode(t)||(t.variableName=this._write(e,t.node));return e}_createVarName(e,t){let r="";return"boolean"!=typeof t&&"number"!=typeof t&&t.debugInfo.name&&(r=`${t.debugInfo.name}_`),`${r}v${e.varCount++}`}_write(e,t,r=!1){if("number"==typeof t)return t.toString();if("boolean"==typeof t)return t.toString();let n=e.getEmit(t);if(n)return n;switch(t.shaderType){case"scope-node":n=this._writeScopeNode(e,t);break;case"primitive-node":n=this._writePrimitiveNode(e,t,r);break;case"function-node":n=this._writeFunctionNode(e,t);break;case"property-access-node":n=this._writePropertyAccessNode(e,t);break;case"text-node":n=t.text;break;case"block-node":n=this._writeBlockNode(e,t);break;case"condition-node":n=this._writeConditionNode(e,t)}return e.setEmit(t,n),n}_writeScopeNode(e,t){const r=new t.child.constructor;r.setDebugName(t.debugInfo.name);const n=this._write(e,r,!0);return mt(e,`{ /*ScopeStart: ${t.uid} ${t.debugInfo.name}*/`),e.indent+=2,mt(e,`${n} = ${this._write(e,t.child)};`),e.indent-=2,mt(e,`} /*ScopeEnd: ${t.uid} ${t.debugInfo.name}*/`),n}_writeConditionNode(e,t){const r=new t.ifTrue.constructor,n=this._write(e,r,!0);mt(e,`if (${this._write(e,t.condition)}) {`),e.indent+=2;const i=e.createSubgraphContext(),s=this._write(i,t.ifTrue);if(e.body+=i.body,s&&mt(e,`${n} = ${s};`),e.indent-=2,mt(e,"}"),t.ifFalse){mt(e,"else {"),e.indent+=2;const r=e.createSubgraphContext(),i=this._write(r,t.ifFalse);e.body+=r.body,i&&mt(e,`${n} = ${i};`),e.indent-=2,mt(e,"}")}return n}_writeBlockNode(e,t){const{captureList:r,generator:n,returnType:i}=t,s={};for(const t in r){if(!r[t])continue;const n=this._write(e,r[t]);s[t]=n}const o=new i,a=this._write(e,o,!0);if(s.out=a,t.subgraph){const r=e.createSubgraphContext(),n=this._write(r,t.subgraph.child),i=r.body;s.subgraph={varName:n,body:i}}const c=n(s);return mt(e,"{\n"),e.indent+=2,mt(e,c),e.indent-=2,mt(e,"}\n"),a}_writePropertyAccessNode(e,t){const r=this._write(e,t.target);return"string"==typeof t.property&&t.property.includes("[")?`${r}${t.property}`:"string"!=typeof t.property?`${r}[${this._write(e,t.property)}]`:`${r}.${t.property}`}_writeFunctionNode(e,t){const r=t.returnType.type;if(t.isInfix){const[n,i]=t.children.map((t=>this._write(e,t))),s=this._createVarName(e,t);return mt(e,`${r.padEnd(5)} ${s} = ${n} ${t.token} ${i};`,t.uid),s}const n=t.children.map((t=>this._write(e,t))).join(", "),i=this._createVarName(e,t);return mt(e,`${r.padEnd(5)} ${i} = ${t.token}(${n});`,t.uid),i}_writePrimitiveNode(e,t,r=!1){const n=e.getInput(t);if(n)return n.isUsed=!0,n.variableName;const i=1===t.children.length&&t.children[0]?.type===t.type;if(t.isImplicit||i)return this._write(e,t.children[0]);const s=this._createVarName(e,t);if(r)return mt(e,`${t.type.padEnd(5)} ${s};`,t.uid),s;const o=!t.debugInfo.name&&!t.isMutable;if(o&&"float"===t.type&&"number"==typeof t.children[0])return Number.isInteger(t.children[0])?t.children[0].toFixed(1):t.children[0].toString();if(o&&"int"===t.type&&"number"==typeof t.children[0]&&Number.isInteger(t.children[0]))return t.children[0].toString();const a=t.children.map((t=>this._write(e,t))).join(", ");return"array"===t.type?(mt(e,`${t.type.padEnd(5)} ${s} = [${a}];`,t.uid),s):o?`${t.type}(${a})`:(mt(e,`${t.type.padEnd(5)} ${s} = ${t.type}(${a});`,t.uid),s)}}class gt{constructor(e,t,r){this.variableName=e,this.variableInputType=t,this.node=r,this.type="shader-input",this.isUsed=!1}clone(){return new gt(this.variableName,this.variableInputType,$(this.node))}}class bt{constructor(e,t,r){this.outVariableName=e,this.outVariableType=t,this.node=r,this.type="shader-output"}clone(){const e=new bt(this.outVariableName,this.outVariableType,$(this.node));return e.variableName=this.variableName,e}}class _t{static createVertex(e,t,r,n,i,s){const o=[];for(const t in e){const n=e[t],i=r.get(t);i?o.push(new gt(i,"builtin",n)):o.push(new gt("a_"+t,"in",n))}for(const e of n){const t=e.uniformHydrated;o.push(new gt(e.uniformName,"uniform",t))}const a=[];for(const e in t){const r=t[e];"glPosition"===e?a.push(new bt("gl_Position","builtin",r)):"glPointSize"===e?a.push(new bt("gl_PointSize","builtin",r)):a.push(new bt("v_"+e,"out",r))}return new _t(o,a,i,s)}static createFragment(e,t,r,n,i,s){const o=[],a=Array.from(i.rootOutputNodes());for(const t in e){const n=e[t],i=r.get(t);if(i){o.push(new gt(i,"builtin",n));continue}const s=a.find((e=>e.node===n));s&&o.push(new gt(s.outVariableName,"in",n))}for(const e of n){const t=e.uniformHydrated;o.push(new gt(e.uniformName,"uniform",t))}const c=[];for(const e in t){const n=t[e],i=r.get(e);"discard"===e?c.push(new bt(null,"discard",n)):i?c.push(new bt(i,"builtin",n)):c.push(new bt(e,"out",n))}return new _t(o,c,s)}constructor(e,t,r,n){this.type="shader-graph-context",this.indent=0,this.body="",this.varCount=0,this._inputShaderTypesByNodeUid=new Map,this._nodeEmitMap=new Map;for(const t of e)this._inputShaderTypesByNodeUid.set(t.node.uid,t);this._outputShaderTypes=t,this._transformFeedbackBindings=r,this._transformFeedbackNames=new Set(r.map((e=>"v_"+e.propertyKey))),this._usedInFragmentShader=n}shouldPruneOutputNode(e){return!!this._usedInFragmentShader&&"builtin"!==e.outVariableType&&!this._transformFeedbackNames.has(e.outVariableName)&&!this._usedInFragmentShader.has(e.node.uid)}setEmit(e,t){this._nodeEmitMap.set(e.uid,t)}getEmit(e){return this._nodeEmitMap.get(e.uid)}inputs(){return this._inputShaderTypesByNodeUid.values()}getInput(e){return this._inputShaderTypesByNodeUid.get(e.uid)}*rootOutputNodes(){for(const e of this._outputShaderTypes)yield e}*nodes(){const e=[];for(const t of this._outputShaderTypes.values())e.push(t.node);for(;e.length;){const t=e.pop();"number"!=typeof t&&"boolean"!=typeof t&&e.push(...t.children.filter(Boolean)),yield t}}*nodesOfTypeOrFunction(){for(const e of this.nodes())"number"!=typeof e&&"boolean"!=typeof e&&(yield e)}createSubgraphContext(){const e=this.clone();return e.body="",e.indent=this.indent+2,e._nodeEmitMap=new Map(this._nodeEmitMap),e}clone(){const e=new _t([],this._outputShaderTypes,this._transformFeedbackBindings,this._usedInFragmentShader);return e._inputShaderTypesByNodeUid=this._inputShaderTypesByNodeUid,e.indent=this.indent,e.body=this.body,e.varCount=this.varCount,e._nodeEmitMap=this._nodeEmitMap,e}insertVertexShader(e){e.vertex.code.add(""),this._insertInputs(e,"vertex"),e.vertex.code.add(""),e.vertex.code.add("// OUTPUTS: "),e.vertex.code.add("// --------------------------------------------------------- ");for(const t of this.rootOutputNodes()){const r="builtin"===t.outVariableType;this.shouldPruneOutputNode(t)||(r?e.vertex.code.add(`// ${t.outVariableType.padEnd(7)} ${t.node.type.padEnd(9)} ${t.outVariableName};`):e.vertex.code.add(`${t.outVariableType.padEnd(10)} ${t.node.type.padEnd(9)} ${t.outVariableName};`))}e.vertex.code.add(""),e.vertex.code.add("void main() {"),e.vertex.code.add("  "+this.body.split("\n").join("\n  "));for(const t of this.rootOutputNodes())this.shouldPruneOutputNode(t)||e.vertex.code.add(`  ${t.outVariableName} = ${t.variableName};`);e.vertex.code.add("}")}insertFragmentShader(e){this._insertInputs(e,"fragment"),e.fragment.code.add(""),e.fragment.code.add("// OUTPUTS: "),e.fragment.code.add("// --------------------------------------------------------- ");for(const t of this.rootOutputNodes())"builtin"===t.outVariableType?e.fragment.code.add(`// ${t.outVariableType.padEnd(7)} ${t.node.type.padEnd(9)} ${t.outVariableName};`):e.fragment.code.add(`${t.outVariableType.padEnd(10)} ${t.node.type.padEnd(9)} ${t.outVariableName};`);e.fragment.code.add(""),e.fragment.code.add("void main() {"),e.fragment.code.add("  "+this.body.split("\n").join("\n  "));for(const t of this.rootOutputNodes())"discard"===t.outVariableType?(e.fragment.code.add("  // TODO: Should ensure codegen for discard appears first in fragment shader"),e.fragment.code.add(`  if (${t.variableName}) {`),e.fragment.code.add("    discard;"),e.fragment.code.add("  }"),e.fragment.code.add("  ")):e.fragment.code.add(`  ${t.outVariableName} = ${t.variableName};`);e.fragment.code.add("}")}_insertInputs(e,t){e[t].code.add("// INPUTS: "),e[t].code.add("// --------------------------------------------------------- ");for(const r of this.inputs())r.isUsed&&"builtin"!==r.variableInputType&&("array"===r.node.type?e[t].code.add(`${r.variableInputType.padEnd(10)} ${r.node.elementType.type.padEnd(9)} ${r.variableName}[${r.node.size}];`):e[t].code.add(`${r.variableInputType.padEnd(10)} ${r.node.type.padEnd(9)} ${r.variableName};`))}}function wt(e,r,i){const s=r.length;if(s!==i){const o=new n("Invalid Uniform",`Invalid length, expected ${i} but got ${s}`,{uniformName:e,values:r});t.getLogger("esri.views.2d.engine.webgl.shaderGraph.typed.TypedShaderProgram").errorOnce(o)}}class vt{constructor(e,t,r,n,i,s){this._program=null,this._vao=null,this._temporaryTextures=[],this.vertexShader=e,this.fragmentShader=t,this._locations=r,this._locationInfo=n,this._uniformBindings=i,this._transformFeedbackBindings=s}destroy(){this._program&&this._program.dispose(),this.cleanupTemporaryTextures()}get locations(){return this._locations}get locationInfo(){return this._locationInfo}setUniforms(e){this._uniforms=e}cleanupTemporaryTextures(){for(const e of this._temporaryTextures)e.dispose();this._temporaryTextures=[]}bind(e){const t=this._uniforms;if(!this._program){const t=new Map;for(const[e,r]of this._locations)t.set(e,r);const r=[];for(const e of this._transformFeedbackBindings??[]){const{index:t,propertyKey:n}=e;r[t]=`v_${n}`}this._program=new a(e,this.vertexShader,this.fragmentShader,t,new Map,r)}const r=this._program;e.useProgram(r);for(const n of this._uniformBindings){const{shaderModulePath:i,uniformName:s,uniformType:a,uniformArrayLength:u}=n,d=o(i,t);if(null==d){if("sampler2D"===a)continue;throw new Error(`Failed to find uniform value for ${i}`)}switch("array"===a?n.uniformArrayElementType:a){case"sampler2D":{const{unit:t,texture:n}=d;if(r.setUniform1i(s,t),"type"in n)e.bindTexture(n,t);else{const r=c(e,n.descriptor,n.data);e.bindTexture(r,t)}break}case"int":if(!u){r.setUniform1i(s,d);break}wt(n.uniformName,d,u),r.setUniform1iv(s,d);break;case"float":if(!u){r.setUniform1f(s,d);break}wt(n.uniformName,d,u),r.setUniform1fv(s,d);break;case"vec2":if(!u){r.setUniform2f(s,d[0],d[1]);break}wt(n.uniformName,d,u),r.setUniform2fv(s,d.flat());break;case"vec3":if(!u){r.setUniform3f(s,d[0],d[1],d[2]);break}wt(n.uniformName,d,u),r.setUniform3fv(s,d.flat());break;case"vec4":if(!u){r.setUniform4f(s,d[0],d[1],d[2],d[3]);break}wt(n.uniformName,d,u),r.setUniform4fv(s,d.flat());break;case"mat3":r.setUniformMatrix3fv(s,d);break;case"mat4":r.setUniformMatrix4fv(s,d);break;default:throw new Error(`Unable to set uniform for type ${a}`)}}}}function $t(e){return new e}function xt(e,t,r){const n=e.constructor[t]??[];e.constructor.hasOwnProperty(t)||Object.defineProperty(e.constructor,t,{value:n.slice()}),e.constructor[t].push(r)}function It(e,t){return(r,n)=>{xt(r,"locations",{typeCtor:t,propertyKey:n,parameterIndex:null,index:e})}}const Tt=e=>(t,r,n)=>{xt(t,"inputs",{inputCtor:e,propertyKey:r,parameterIndex:n})},St=e=>(t,r)=>{xt(t,"uniforms",{typeCtor:e,propertyKey:r})},Nt=e=>(t,r)=>{xt(t,"options",{typeCtor:e,propertyKey:r})},Ft=(e,t)=>{xt(e,"defines",{propertyKey:t})},kt=(e,t)=>(r,n)=>{r.constructor.builtins.push({builtin:e,propertyKey:n,typeCtor:t})};class Mt{}Mt.builtins=[],e([kt("gl_VertexID",ae)],Mt.prototype,"glVertexID",void 0);class Et{}class Pt{}Pt.builtins=[],e([kt("gl_FragCoord",Q)],Pt.prototype,"glFragCoord",void 0),e([kt("gl_PointCoord",X)],Pt.prototype,"glPointCoord",void 0);class Ct{}class Ut{constructor(){this.type="uniform-group"}get _uniforms(){return this.constructor.uniforms??[]}}class Ot{constructor(){this.logShader=!1,this.computeAttributes={}}get vertexInput(){const e=this._shaderModuleClass.inputs.findLast((e=>"vertex"===e.propertyKey&&0===e.parameterIndex));if(!e)throw new Error("Unable to find vertex input parameter");return e}get computeInput(){return this._shaderModuleClass.inputs.findLast((e=>"vertex"===e.propertyKey&&1===e.parameterIndex))}get fragmentInput(){const e=this._shaderModuleClass.inputs.findLast((e=>"fragment"===e.propertyKey));if(!e)throw new Error("Unable to find fragment input parameter");return e}get transformFeedbackBindings(){return this.fragmentInput.inputCtor.transformFeedbackBindings??[]}get locations(){return[...this.vertexInput.inputCtor.locations,...this.computeInput?.inputCtor.locations??[]]}get locationsMap(){const e=new Map,r=new Set;for(const n of this.locations)r.has(n.index)?t.getLogger("esri.views.2d.engine.webgl.shaderGraph.GraphShaderModule").warnOnce("mapview-rendering",`Unable to assigned attribute ${n.propertyKey} to ${n.index}. Index already in use`,{locationsMap:e}):(e.set(n.propertyKey,n.index),r.add(n.index));return e}get locationInfo(){if(!this._locationInfo){const e=this.locationsMap,t=Array.from(e.entries()).map((([e,t])=>`${e}.${t}`)).join("."),n=r(t),i=this.computeAttributes;this._locationInfo={hash:n,locations:e,computeAttributeMap:i}}return this._locationInfo}get renamedLocationsMap(){const e=new Map;for(const t of this.locations)e.set("a_"+t.propertyKey,t.index);return e}get optionPropertyKeys(){if(!this._optionPropertyKeys){const e=new Set;for(const t of this._options)e.add(t.propertyKey);this._optionPropertyKeys=e}return this._optionPropertyKeys}get _shaderModuleClass(){return this.constructor}get _defines(){return this._shaderModuleClass.defines??[]}get _options(){return this._shaderModuleClass.options??[]}get _uniforms(){return this._shaderModuleClass.uniforms??[]}getProgram(e,t,r,n){try{const{vertex:i,fragment:s,uniformBindings:o}=this._generateShaders(e,t,r,n);return new vt(i,s,this.renamedLocationsMap,this.locationInfo,o,this.transformFeedbackBindings)}catch(e){return new vt("","",this.renamedLocationsMap,this.locationInfo,[],this.transformFeedbackBindings)}}getDebugUniformClassInfo(e){const t=this._options.find((t=>t.propertyKey===e));if(t)return{type:"option",className:t.typeCtor};const r=this._uniforms.find((t=>t.propertyKey===e));if(!r)throw new Error(`Unable to find uniform class type for property: ${e}`);return{type:"required",className:r.typeCtor}}getShaderKey(e,t,r,n){const i=Object.keys(e).map((t=>`${t}.${e[t]}`)).join("."),s=Object.keys(r).map((e=>`${e}.${r[e]}`)).join("."),o=Object.keys(n).map((e=>`${e}.${n[e]}`)).join("."),a=Object.keys(t).filter((e=>this.optionPropertyKeys.has(e)&&t[e])).join(".");return`${this.constructor.name}.${i}.${s}.${o}.${a}`}_generateShaders(e,t,r,n){const i=[];this._setDefines(r),this._setOptionalUniforms(i,t),this._setRequiredUniforms(i);const s=this._hydrateVertexInput(n),o=this._injectPackPrecisionFactor(s,e),a=this._hydrateComputeInput(),c=a&&this._injectComputePackPrecisionFactor(a,e),u=this.vertex(o,c),d=this._hydrateFragmentInput(u),h=this.fragment(d),l=new Set;for(const e in h)w(l,h[e]);const p=this._getVertexInputBuiltins(),f=_t.createVertex({...s,...a},u,p,i,this.transformFeedbackBindings,l);(new yt).write(f);const m=this._getFragmentInputBuiltins(h);m.set("glPointCoord","gl_PointCoord");const y=_t.createFragment(d,h,m,i,f,this.transformFeedbackBindings);(new yt).write(y);const g=this._createShaderBuilder(f,y),b=g.generate("vertex",!0),_=g.generate("fragment",!0);return this.logShader&&(console.log(b),console.log(_)),{vertex:b,fragment:_,uniformBindings:i}}_setDefines(e){for(const t in e)this[t]=e[t]}_setOptionalUniforms(e,t){for(const r of this._options)t[r.propertyKey]?this[r.propertyKey]=this._hydrateUniformGroup(e,r):this[r.propertyKey]=null}_setRequiredUniforms(e){for(const t of this._uniforms)this[t.propertyKey]=this._hydrateUniformGroup(e,t)}_hydrateUniformGroup(e,t){const r=new(0,t.typeCtor);for(const n of r._uniforms??[]){const i=$t(n.typeCtor),s=`u_${t.propertyKey}_${n.propertyKey}`,o=i.type,a=[t.propertyKey,n.propertyKey].join(".");if("type"in n.typeCtor&&"array"===n.typeCtor.type){const t=i;e.push({shaderModulePath:a,uniformName:s,uniformType:o,uniformArrayLength:t.size,uniformArrayElementType:t.elementType.type,uniformHydrated:i})}else e.push({shaderModulePath:a,uniformName:s,uniformType:o,uniformHydrated:i});r[n.propertyKey]=i}return r}_hydrateVertexInput(e){const t=this.vertexInput.inputCtor,r=t.locations.reduce(((t,r)=>!1===e[r.propertyKey]?t:{...t,[r.propertyKey]:$t(r.typeCtor)}),{});for(const{propertyKey:e,typeCtor:n}of t.builtins){const t=$t(n);r[e]=t}return r}_hydrateComputeInput(){return null==this.computeInput?null:this.computeInput.inputCtor.locations.reduce(((e,t)=>({...e,[t.propertyKey]:$t(t.typeCtor)})),{})}_injectPackPrecisionFactor(e,t){const r={};for(const n in e){const i=e[n],s=t[n];if(s){if("float"!==i.type&&"vec2"!==i.type&&"vec3"!==i.type&&"vec4"!==i.type)throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${i.type}`);r[n]=i.divide(new W(s))}else r[n]=i}return r}_injectComputePackPrecisionFactor(e,t){const r={},n=new Map;for(const e in this.computeAttributes)for(const t of this.computeAttributes[e]??[])n.set(t,e);for(const i in e){const s=e[i],o=n.get(i);if(!o)continue;const a=t[o];if(a){if("float"!==s.type&&"vec2"!==s.type&&"vec3"!==s.type&&"vec4"!==s.type)throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${s.type}`);r[i]=s.divide(new W(a))}else r[i]=s}return r}_hydrateFragmentInput(e){const t={};for(const r in e)t[r]=e[r];for(const{propertyKey:e,typeCtor:r}of Pt.builtins){const n=$t(r);t[e]=n}return t}_getVertexInputBuiltins(){const e=this.vertexInput.inputCtor,t=new Map;for(const{builtin:r,propertyKey:n}of e.builtins)t.set(n,r);return t}_getFragmentInputBuiltins(e){const t=e.constructor,r=new Map;for(const e of t.builtins??[])r.set(e.propertyKey,e.builtin);return r}_createShaderBuilder(e,t){const r=new h;return this._insertDebugInfo(r),e.insertVertexShader(r),t.insertFragmentShader(r),r}_insertDebugInfo(e){e.vertex.code.add("// DEFINES: "),e.vertex.code.add("// --------------------------------------------------------- ");for(const t of this._defines)this[t.propertyKey]?e.vertex.code.add(`//   ${t.propertyKey}: true`):e.vertex.code.add(`//   ${t.propertyKey}: false`);e.vertex.code.add(""),e.vertex.code.add("// OPTIONS: "),e.vertex.code.add("// --------------------------------------------------------- ");for(const t of this._options)this[t.propertyKey]?e.vertex.code.add(`//   ${t.propertyKey}: true`):e.vertex.code.add(`//   ${t.propertyKey}: false`)}}export{Ge as $,Je as A,dt as B,et as C,ht as D,ut as E,W as F,Ot as G,Ue as H,ae as I,Me as J,it as K,ye as L,le as M,st as N,Ze as O,be as P,_e as Q,ge as R,q as S,u as T,Ut as U,Mt as V,me as W,We as X,Nt as Y,Et as Z,Qe as _,J as a,at as a0,ot as a1,H as a2,Ae as a3,De as a4,re as a5,we as a6,Se as a7,pe as a8,Ne as a9,he as aa,Oe as ab,Ke as ac,vt as ad,X as b,Q as c,Ye as d,Ct as e,Pt as f,Ft as g,Fe as h,Tt as i,je as j,Xe as k,It as l,ze as m,rt as n,nt as o,ke as p,Be as q,Ve as r,pt as s,ft as t,St as u,lt as v,Le as w,qe as x,ct as y,tt as z};
