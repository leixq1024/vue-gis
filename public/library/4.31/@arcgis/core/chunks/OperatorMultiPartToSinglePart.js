/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{G as e,w as t,x as s,E as r,p as n,y as a,i as o,z as i,n as m,A as l,a as g,P as h,B as u,C as c}from"./converterAPI.js";import{a as p,G as P,g as y,t as _}from"./Transformation2D.js";class d{getOperatorType(){return 10700}accelerateGeometry(e,t,s){return!1}canAccelerateGeometry(e){return!1}supportsCurves(){return!0}executeMany(e,t,s,r=1){return new I(e,t,s,r)}}class I extends e{constructor(e,t,s,r){super(),this.m_progressTracker=s,this.m_inputGeoms=e,this.m_spatialReference=t,this.m_currentGeometry=null,this.m_singlePartIndex=-1,this.m_singlePartCount=-1,this.m_polygonStart=-1,this.m_index=-1,this.m_options=r}tock(){return!0}getRank(){return 1}next(){if(this.m_singlePartIndex===this.m_singlePartCount){const h=this.m_inputGeoms.next();if(null===h)return null;if(p(h),h.getGeometryType()===P.enumPolygon)if(1===this.m_options)this.m_currentGeometry=(new t).execute(h,this.m_spatialReference,!1,this.m_progressTracker);else if(2===this.m_options)if(h.getPathCount()<2)this.m_currentGeometry=h;else{const e=[0],t=h.getImpl().getIsSimple(0,e);if(s(t))this.m_currentGeometry=h;else{const e=new r,t=e.addGeometry(h);let s=null;if(e.hasCurves()){s=new c;const t=new n;h.queryEnvelope(t);const r=a(null,h,!0),m=o(r.total(),t);i(e,m,r.total(),12e3,null,s,null,this.m_progressTracker)}const u=e.createPathUserIndex();{let s=0;for(let r=e.getFirstPath(t);r!==m;r=e.getNextPath(r))e.setPathUserIndex(r,u,s++)}const p=l(e,t,this.m_progressTracker);y(p>=0);const P=[];for(let s=e.getFirstPath(t);s!==m;s=e.getNextPath(s))P.push(s);P.sort(((t,s)=>Math.abs(e.getPathUserIndex(t,p))-Math.abs(e.getPathUserIndex(s,p))));const _=h,d=new g({vd:h.getDescription()});d.reserveParts(_.getPointCount(),_.getPathCount());for(let t=0,s=P.length;t<s;t++){const s=P[t],r=e.getPathUserIndex(s,u),n=_.calculateRingArea2D(r)>0,a=e.getPathUserIndex(s,p)>=0;d.addPath(_,r,n===a)}this.m_currentGeometry=d}}else _("");else this.m_currentGeometry=h;this.m_singlePartCount=(e=this.m_currentGeometry).isEmpty()?1:u(e),this.m_singlePartIndex=0,this.m_polygonStart=0,this.m_index=this.m_inputGeoms.getGeometryID()}var e;const h=this.getSingleGeometry(this.m_singlePartIndex,this.m_singlePartCount,this.m_polygonStart,this.m_currentGeometry);return h.getGeometryType()===P.enumPolygon&&(this.m_polygonStart+=h.getPathCount()),this.m_singlePartIndex++,h}getGeometryID(){return this.m_index}getSingleGeometry(e,t,s,r){let n=null;switch(r.getGeometryType()){case P.enumMultiPoint:n=new h({vd:r.getDescription()}),r.isEmpty()||r.getPointByVal(e,n);break;case P.enumPolyline:if(1===t)n=r;else{n=r.createInstance(),n.getImpl().addPath(r.getImpl(),e,!0);const t=[0],s=r.getImpl().getIsSimple(0,t);n.getImpl().setIsSimple(s,t[0],!0)}break;case P.enumPolygon:if(1===t)n=r;else{n=r.createInstance();const e=n.getImpl(),t=r.getImpl(),a=t.getPathFlagsStreamRef();let o=s;const i=t.getPathCount();do{e.addPath(t,o,!0),o++}while(o<i&&!(8&a.read(o)));e.getPathFlagsStreamRef().setBits(0,8);const m=[0],l=t.getIsSimple(0,m);e.setIsSimple(l,m[0],!0)}break;default:n=r}return n}}export{d as O};
