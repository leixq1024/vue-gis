/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{l as e}from"./unitUtils.js";import{T as t}from"./TileKey2.js";import{_ as s}from"./tslib.es6.js";import i,{h as o,x as l}from"../core/Accessor.js";import{g as r}from"./ensureType.js";import{d as n}from"./maybe.js";import{property as h}from"../core/accessorSupport/decorators/property.js";import"../core/lang.js";import"./Logger.js";import{subclass as a}from"../core/accessorSupport/decorators/subclass.js";import{u as c,p as u}from"./vec2.js";import{Q as f}from"./QueueProcessor.js";import{c as d,k as m}from"./aaBoundingRect.js";function g(e,t){return[e,t]}function y(e,t,s){return e[0]=t,e[1]=s,e}const p=new t("0/0/0/0");class _{static create(t,s,i=null){const o=e(t.spatialReference),l=s.origin||g(t.origin.x,t.origin.y),r=g(t.size[0]*s.resolution,t.size[1]*s.resolution),n=g(-1/0,-1/0),h=g(1/0,1/0),a=g(1/0,1/0);null!=i&&(y(n,Math.max(0,Math.floor((i.xmin-l[0])/r[0])),Math.max(0,Math.floor((l[1]-i.ymax)/r[1]))),y(h,Math.max(0,Math.floor((i.xmax-l[0])/r[0])),Math.max(0,Math.floor((l[1]-i.ymin)/r[1]))),y(a,h[0]-n[0]+1,h[1]-n[1]+1));const{cols:c,rows:u}=s;let f,d,m,p;return!i&&c&&u&&(y(n,c[0],u[0]),y(h,c[1],u[1]),y(a,c[1]-c[0]+1,u[1]-u[0]+1)),t.isWrappable?(f=g(Math.ceil(Math.round((o.valid[1]-o.valid[0])/s.resolution)/t.size[0]),a[1]),d=!0,m=o.origin,p=o.valid):(f=a,d=!1),new _(s.level,s.resolution,s.scale,l,n,h,a,r,f,d,m,p)}constructor(e,t,s,i,o,l,r,n,h,a,c,u){this.level=e,this.resolution=t,this.scale=s,this.origin=i,this.first=o,this.last=l,this.size=r,this.norm=n,this.worldSize=h,this.wrap=a,this._spatialReferenceOrigin=c,this._spatialReferenceValid=u}normalizeCol(e){if(!this.wrap)return e;const t=this.worldSize[0];return e<0?t-1-Math.abs((e+1)%t):e%t}normalizeKey(e){if(!this.wrap)return;const t=this.worldSize[0],s=e.col;s<0?(e.col=s+t,e.world-=1):s>=t&&(e.col=s-t,e.world+=1)}denormalizeCol(e,t){return this.wrap?this.worldSize[0]*t+e:e}getWorldForColumn(e){return this.wrap?Math.floor(e/this.worldSize[0]):0}getFirstColumnForWorld(e){return e*this.worldSize[0]+this.first[0]}getLastColumnForWorld(e){return e*this.worldSize[0]+this.first[0]+this.size[0]-1}getColumnForX(e){return(e-this.origin[0])/this.norm[0]}getXForColumn(e){const t=this.origin[0]+e*this.norm[0],s=this._spatialReferenceOrigin,i=this._spatialReferenceValid;return this.wrap&&s&&i?t===s[0]?i[0]:this.origin[0]===s[0]&&e===this.worldSize[0]?i[1]:t:t}getRowForY(e){return(this.origin[1]-e)/this.norm[1]}getYForRow(e){return this.origin[1]-e*this.norm[1]}getTileBounds(e,t,s=!1){p.set(t);const i=s?p.col:this.denormalizeCol(p.col,p.world),o=p.row;return function(e,t,s,i,o){e[0]=t,e[1]=s,e[2]=i,e[3]=o}(e,this.getXForColumn(i),this.getYForRow(o+1),this.getXForColumn(i+1),this.getYForRow(o)),e}getTileCoords(e,t,s=!1){p.set(t);const i=s?p.col:this.denormalizeCol(p.col,p.world);return Array.isArray(e)?y(e,this.getXForColumn(i),this.getYForRow(p.row)):(e.x=this.getXForColumn(i),e.y=this.getYForRow(p.row)),e}}class v{constructor(){this.spans=[]}acquire(e){this.lodInfo=e}release(){this.lodInfo=null,this.spans.length=0}*keys(){const e=this.lodInfo;for(const{row:s,colFrom:i,colTo:o}of this.spans)for(let l=i;l<=o;l++){const i=e.getWorldForColumn(l);yield new t(e.level,s,e.normalizeCol(l),i)}}forEach(e,t){const{spans:s,lodInfo:i}=this,{level:o}=i;if(0!==s.length)for(const{row:l,colFrom:r,colTo:n}of s)for(let s=r;s<=n;s++)e.call(t,o,l,i.normalizeCol(s),i.getWorldForColumn(s))}}v.pool=new o(v);class w{constructor(e,t,s){this.row=e,this.colFrom=t,this.colTo=s}}const I=new t("0/0/0/0");class T{static create(e,t){e[1]>t[1]&&([e,t]=[t,e]);const[s,i]=e,[o,l]=t,r=o-s,n=l-i,h=0!==n?r/n:0,a=(Math.ceil(i)-i)*h,c=(Math.floor(i)-i)*h;return new T(s,Math.floor(i),Math.ceil(l),h,r<0?a:c,r<0?c:a,r<0?o:s,r<0?s:o)}constructor(e,t,s,i,o,l,r,n){this.x=e,this.ymin=t,this.ymax=s,this.invM=i,this.leftAdjust=o,this.rightAdjust=l,this.leftBound=r,this.rightBound=n}incrRow(){this.x+=this.invM}getLeftCol(){return Math.max(this.x+this.leftAdjust,this.leftBound)}getRightCol(){return Math.min(this.x+this.rightAdjust,this.rightBound)}}const S=[[0,0],[0,0],[0,0],[0,0]];class C{constructor(e,t=null,s=e.lods[0].level,i=e.lods[e.lods.length-1].level){this.tileInfo=e,this.fullExtent=t,this.scales=[],this._infoByScale={},this._infoByLevel={};const o=e.lods.filter((e=>e.level>=s&&e.level<=i));this.minScale=o[0].scale,this.maxScale=o[o.length-1].scale;const l=this._lodInfos=o.map((s=>_.create(e,s,t)));o.forEach(((e,t)=>{this._infoByLevel[e.level]=l[t],this._infoByScale[e.scale]=l[t],this.scales[t]=e.scale}),this),this._wrap=e.isWrappable}get spatialReference(){return this.tileInfo.spatialReference}getLODInfoAt(e){return this._infoByLevel["number"==typeof e?e:e.level]}getTileBounds(e,t,s=!1){I.set(t);const i=this._infoByLevel[I.level];return i?i.getTileBounds(e,I,s):e}getTileCoords(e,t,s=!1){I.set(t);const i=this._infoByLevel[I.level];return i?i.getTileCoords(e,I,s):e}getTileCoverage(e,t=192,s=!0,i="closest"){if(!s&&(e.scale>this.minScale||e.scale<this.maxScale))return null;const o="closest"===i?this.getClosestInfoForScale(e.scale):this.getSmallestInfoForScale(e.scale),l=v.pool.acquire(o),r=this._wrap;let n,h,a,c=1/0,u=-1/0;const f=l.spans;S[0][0]=S[0][1]=S[1][1]=S[3][0]=-t,S[1][0]=S[2][0]=e.size[0]+t,S[2][1]=S[3][1]=e.size[1]+t;for(const t of S)e.toMap(t,t),t[0]=o.getColumnForX(t[0]),t[1]=o.getRowForY(t[1]);const d=[];let m=3;for(let e=0;e<4;e++){if(S[e][1]===S[m][1]){m=e;continue}const t=T.create(S[e],S[m]);c=Math.min(t.ymin,c),u=Math.max(t.ymax,u),void 0===d[t.ymin]&&(d[t.ymin]=[]),d[t.ymin].push(t),m=e}if(null==c||null==u||u-c>100)return null;let g=[];for(n=c;n<u;){null!=d[n]&&(g=g.concat(d[n])),h=1/0,a=-1/0;for(let e=g.length-1;e>=0;e--){const t=g[e];h=Math.min(h,t.getLeftCol()),a=Math.max(a,t.getRightCol())}if(h=Math.floor(h),a=Math.floor(a),n>=o.first[1]&&n<=o.last[1])if(r)if(o.size[0]<o.worldSize[0]){const e=Math.floor(a/o.worldSize[0]);for(let t=Math.floor(h/o.worldSize[0]);t<=e;t++)f.push(new w(n,Math.max(o.getFirstColumnForWorld(t),h),Math.min(o.getLastColumnForWorld(t),a)))}else f.push(new w(n,h,a));else h>o.last[0]||a<o.first[0]||(h=Math.max(h,o.first[0]),a=Math.min(a,o.last[0]),f.push(new w(n,h,a)));n+=1;for(let e=g.length-1;e>=0;e--){const t=g[e];t.ymax>=n?t.incrRow():g.splice(e,1)}}return l}getTileParentId(e){I.set(e);const t=this._infoByLevel[I.level],s=this._lodInfos.indexOf(t)-1;return s<0?null:(this._getTileIdAtLOD(I,this._lodInfos[s],I),I.id)}getTileResolution(e){const t=this._infoByLevel["object"==typeof e?e.level:e];return t?t.resolution:-1}getTileScale(e){const t=this._infoByLevel[e.level];return t?t.scale:-1}intersects(e,t){I.set(t);const s=this._infoByLevel[I.level],i=e.lodInfo;if(i.resolution>s.resolution){this._getTileIdAtLOD(I,i,I);const t=i.denormalizeCol(I.col,I.world);for(const s of e.spans)if(s.row===I.row&&s.colFrom<=t&&s.colTo>=t)return!0}if(i.resolution<s.resolution){const[t,o,l,r]=e.spans.reduce(((e,t)=>(e[0]=Math.min(e[0],t.row),e[1]=Math.max(e[1],t.row),e[2]=Math.min(e[2],t.colFrom),e[3]=Math.max(e[3],t.colTo),e)),[1/0,-1/0,1/0,-1/0]),n=s.denormalizeCol(I.col,I.world),h=i.getColumnForX(s.getXForColumn(n)),a=i.getRowForY(s.getYForRow(I.row)),c=i.getColumnForX(s.getXForColumn(n+1))-1,u=i.getRowForY(s.getYForRow(I.row+1))-1;return!(h>r||c<l||a>o||u<t)}const o=i.denormalizeCol(I.col,I.world);return e.spans.some((e=>e.row===I.row&&e.colFrom<=o&&e.colTo>=o))}normalizeBounds(t,s,i){if(t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3],this._wrap){const s=e(this.tileInfo.spatialReference),o=-i*(s.valid[1]-s.valid[0]);t[0]+=o,t[2]+=o}return t}getSmallestInfoForScale(e){const t=this.scales;if(this._infoByScale[e])return this._infoByScale[e];if(e>t[0])return this._infoByScale[t[0]];for(let s=1;s<t.length-1;s++)if(e>t[s]+1e-6)return this._infoByScale[t[s-1]];return this._infoByScale[t[t.length-1]]}getClosestInfoForScale(e){const t=this.scales;return this._infoByScale[e]||(e=t.reduce(((t,s)=>Math.abs(s-e)<Math.abs(t-e)?s:t),t[0])),this._infoByScale[e]}scaleToLevel(e){const t=this.scales;if(this._infoByScale[e])return this._infoByScale[e].level;for(let s=t.length-1;s>=0;s--)if(e<t[s])return s===t.length-1?this._infoByScale[t[t.length-1]].level:this._infoByScale[t[s]].level+(t[s]-e)/(t[s]-t[s+1]);return this._infoByScale[t[0]].level}scaleToZoom(e){return this.tileInfo.scaleToZoom(e)}zoomToScale(e){return this.tileInfo.zoomToScale(e)}_getTileIdAtLOD(e,t,s){const i=this._infoByLevel[s.level];return e.set(s),t.resolution<i.resolution?null:(t.resolution===i.resolution||(e.level=t.level,e.col=Math.floor(s.col*i.resolution/t.resolution+.01),e.row=Math.floor(s.row*i.resolution/t.resolution+.01)),e)}}const x=[0,0];let F=class extends i{constructor(e){super(e),this._keyToItem=new Map,this._tilesByScale=new Map,this.concurrency=6}initialize(){const{concurrency:e,process:t,scheduler:s,priority:i}=this;this._queue=new f({concurrency:e,scheduler:s,priority:i,process:(e,s)=>{const i=this._keyToItem.get(e);return t(i,{signal:s})},peeker:e=>this._peek(e)})}destroy(){this.clear(),this._queue=n(this._queue)}get length(){return this._queue?this._queue.length:0}abort(e){const t="string"==typeof e?e:e.id;this._queue.abort(t)}clear(){this._queue.clear(),this._keyToItem.clear(),this._tilesByScale.clear()}has(e){return"string"==typeof e?this._keyToItem.has(e):this._keyToItem.has(e.id)}pause(){this._queue.pause()}push(e){const t=e.key.id;if(this._queue.has(t))return this._queue.get(t);const s=this._queue.push(t),i=this.tileInfoView.getTileScale(e.key),o=r(this._tilesByScale,i,(()=>new Set)),l=()=>{o.delete(e.key),0===o.size&&this._tilesByScale.delete(i),this._keyToItem.delete(t)};return o.add(e.key),this._keyToItem.set(t,e),s.then(l,l),s}reset(){this._queue.reset()}resume(){this._queue.resume()}_peek(e){if(!this.state)return e.values().next().value;const t=new Set;for(const s of e)t.add(this._keyToItem.get(s).key);const s=this.state.scale;let i,o=Number.POSITIVE_INFINITY;for(const[e,r]of this._tilesByScale){const n=l(r,(e=>t.has(e)));if(n){const t=Math.abs(e-s);t<o&&(i=r,o=t)}}return this._getClosestTileKey(i,e).id}_getClosestTileKey(e,t){const s=this.tileInfoView,i=this.state.center;let o,l=Number.POSITIVE_INFINITY;for(const r of e)if(t.has(r.id)){s.getTileCoords(x,r);const e=c(x,i);e<l&&(l=e,o=r)}return o}};s([h({constructOnly:!0})],F.prototype,"concurrency",void 0),s([h({constructOnly:!0})],F.prototype,"priority",void 0),s([h({constructOnly:!0})],F.prototype,"process",void 0),s([h({constructOnly:!0})],F.prototype,"scheduler",void 0),s([h()],F.prototype,"state",void 0),s([h({constructOnly:!0})],F.prototype,"tileInfoView",void 0),F=s([a("esri.views.2d.tiling.TileQueue")],F);const M=F;class z{constructor(e,t,s){this.maxSize=e,this._tileInfoView=t,this._removedFunc=s,this._tilePerId=new Map,this._tileKeysPerLevel=[]}clear(){this._tilePerId.clear(),this._tileKeysPerLevel=[]}has(e){return this._tilePerId.has(e)}get(e){return this._tilePerId.get(e)}pop(e){const t=this._tilePerId.get(e);if(!t)return;const s=t.key.level,i=this._tileKeysPerLevel[s];B(this._tilePerId,e);for(let t=0;t<i.length;t++)if(i[t].id===e){i.splice(t,1);break}return t.visible=!0,t}add(e){e.visible=!1;const t=e.key,s=t.id;if(this._tilePerId.has(s))return;this._tilePerId.set(s,e);const i=t.level;this._tileKeysPerLevel[i]||(this._tileKeysPerLevel[i]=[]),this._tileKeysPerLevel[i].push(t)}prune(e,t,s){let i=this._tilePerId.size;if(i<=this.maxSize)return;let o=this._tileKeysPerLevel.length-1;for(;i>this.maxSize&&o>=0;)o!==e&&(i=this._pruneAroundCenterTile(i,t,s,o)),o--;i>this.maxSize&&(i=this._pruneAroundCenterTile(i,t,s,e))}_pruneAroundCenterTile(e,t,s,i){const o=this._tileKeysPerLevel[i];if(!o||0===o.length)return e;const{size:l,origin:r}=this._tileInfoView.tileInfo,n=s*l[0],h=s*l[1],a=[0,0],c=[0,0];for(o.sort(((e,s)=>(a[0]=r.x+n*(e.col+.5),a[1]=r.y-h*(e.row+.5),c[0]=r.x+n*(s.col+.5),c[1]=r.y-h*(s.row+.5),u(a,t)-u(c,t))));o.length>0;){const t=o.pop();if(this._removeTile(t.id),--e===this.maxSize)break}return e}_removeTile(e){const t=this._tilePerId.get(e);this._removedFunc&&t&&this._removedFunc(t),B(this._tilePerId,e)}}function B(e,t){e.delete(t)}const P=new t(0,0,0,0),k=new Map,R=[],b=[];class L{constructor(e){this._previousScale=Number.POSITIVE_INFINITY,this.cachePolicy="keep",this.coveragePolicy="closest",this.resampling=!0,this.tileIndex=new Map,this.tiles=[],this.buffer=192,this.acquireTile=e.acquireTile,this.releaseTile=e.releaseTile,this.tileInfoView=e.tileInfoView,null!=e.resampling&&(this.resampling=e.resampling),e.cachePolicy&&(this.cachePolicy=e.cachePolicy),e.coveragePolicy&&(this.coveragePolicy=e.coveragePolicy),null!=e.buffer&&(this.buffer=e.buffer),e.cacheSize&&(this._tileCache=new z(e.cacheSize,this.tileInfoView,(e=>{this.releaseTile(e)})))}destroy(){this.tileIndex.clear()}update(e){const{resampling:t,tileIndex:s}=this,{scale:i,center:o,resolution:l}=e.state,{minScale:r,maxScale:n}=this.tileInfoView,h=!e.stationary&&i>this._previousScale;if(this._previousScale=i,!t&&(i>r||i<n))return this.tiles.length=0,void this.clear();const a=this.tileInfoView.getTileCoverage(e.state,this.buffer,this.resampling,this.coveragePolicy);if(!a)return this.tiles.length=0,void this.clear();const{spans:c,lodInfo:u}=a,{level:f}=u;this.tiles.length=0,s.forEach((e=>e.visible=!0));let d=0,m=0;if(c.length>0)for(const{row:e,colFrom:t,colTo:i}of c)for(let o=t;o<=i;o++){d++;const t=P.set(f,e,u.normalizeCol(o),u.getWorldForColumn(o)).id;let i=s.get(t);if(i)i.isReady?(k.set(t,i),m++):h||this._addParentTile(t,k);else{if(this._tileCache?.has(t)){if(i=this._tileCache.pop(t),this.tileIndex.set(t,i),i.isReady){k.set(t,i),m++;continue}}else i=this.acquireTile(P),this.tileIndex.set(t,i);h||this._addParentTile(t,k)}}const g=m===d;for(const[e,t]of s){if(k.has(e))continue;P.set(e);const s=this.tileInfoView.intersects(a,P),i="purge"===this.cachePolicy?P.level!==f:P.level>f;!s||!h&&g?!i&&s||R.push(t):t.isReady?i&&"purge"===this.cachePolicy&&this._hasReadyAncestor(P,f)?R.push(t):b.push(t):i&&R.push(t)}for(const e of b)e.isReady&&k.set(e.key.id,e);for(const e of R)this._tileCache?this._tileCache.add(e):this.releaseTile(e),s.delete(e.key.id);for(const e of k.values())this.tiles.push(e);for(const e of s.values())k.has(e.key.id)||(e.visible=!1);this._tileCache?.prune(f,o,l),v.pool.release(a),b.length=0,R.length=0,k.clear()}clear(){const{tileIndex:e}=this;for(const t of e.values())this.releaseTile(t);e.clear()}refresh(e){for(const t of this.tileIndex.values())e(t);this._tileCache?.clear()}updateCacheSize(e){this._tileCache&&(this._tileCache.maxSize=e)}_addParentTile(e,t){let s=e,i=null;for(;s=this.tileInfoView.getTileParentId(s),s;)if(this.tileIndex.has(s)){if(i=this.tileIndex.get(s),i?.isReady){t.has(i.key.id)||t.set(i.key.id,i);break}}else if(this._tileCache?.has(s)&&(i=this._tileCache.pop(s),this.tileIndex.set(s,i),i?.isReady)){t.has(i.key.id)||t.set(i.key.id,i);break}}_hasReadyAncestor(e,t){const s=d();this.tileInfoView.getTileBounds(s,e,!0);for(const i of this.tileIndex.values())if(i.isReady&&i.key.level>=t&&i.key.level<e.level){const e=d();if(this.tileInfoView.getTileBounds(e,i.key,!0),m(e,s))return!0}return!1}}export{C as T,M as a,L as b,v as c};
