/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{a as e,b as t}from"./tslib.es6.js";import{t as r,a as o,G as s,c as i,E as a}from"./Transformation2D.js";import{O as n}from"./OperatorShapePreservingLength.js";import{ay as m,b as p,O as c,N as l,az as j,aA as g,M as u,a1 as y,a2 as d,a3 as x}from"./converterAPI.js";import"../geometry.js";import"./ensureType.js";import"../core/lang.js";import"./Logger.js";import"../config.js";import"../geometry/Extent.js";import"../core/accessorSupport/decorators/property.js";import"./utils.js";import"./handleUtils.js";import"./metadata.js";import"../core/Error.js";import"../core/accessorSupport/decorators/subclass.js";import"./tracking.js";import"../geometry/Geometry.js";import"../core/JSONSupport.js";import"../core/Accessor.js";import"../core/Handles.js";import"./maybe.js";import"./ObservableBase.js";import"../core/scheduling.js";import"../core/promiseUtils.js";import"./reader.js";import"../geometry/SpatialReference.js";import"./unitUtils.js";import"./jsonMap.js";import"./assets.js";import"../request.js";import"../kernel.js";import"../core/urlUtils.js";import"./writer.js";import"../geometry/Point.js";import"../core/accessorSupport/decorators/cast.js";import"../geometry/support/webMercatorUtils.js";import"../geometry/Multipoint.js";import"./zmUtils.js";import"../geometry/Polygon.js";import"./coordsUtils.js";import"./Axis.js";import"./extentUtils.js";import"./boundsUtils.js";import"./aaBoundingRect.js";import"./mathUtils.js";import"../geometry/Polyline.js";import"./typeUtils.js";import"../geometry/support/jsonUtils.js";class S{getOperatorType(){return 10311}supportsCurves(){return!0}accelerateGeometry(e,t,r){return!1}canAccelerateGeometry(e){return!1}execute(e,t,y,d){if(4===y)return(new n).execute(e,t,d);if(0===t.getCoordinateSystemType()&&r(""),o(e),e.isEmpty()||e.getDimension()<1)return 0;const S=t.getGCS(),h=x();S.querySpheroidData(h);const f=h.majorSemiAxis,U=h.e2,P=S.getUnit().getUnitToBaseFactor();let b;const E=e.getGeometryType();if(E===s.enumPolygon?b=e.getBoundary():E===s.enumEnvelope?b=m(e):i(E)?(b=new p({vd:e.getDescription()}),b.addSegment(e,!0)):b=e,b.hasNonLinearSegments()&&(b=(new c).execute(b,0,t.getTolerance(0),0,d)),S!==t){const r=t.getSRToGCSTransform();if(t.isPannable()){b=l(b,t),E===s.enumPolyline&&b===e&&(b=e.clone());const r=new a;t.getPannableExtent().queryIntervalX(r);for(let e=0,t=b.getPointCount();e<t;e++){const t=b.getXY(e);t.x=j(t.x,r),b.setXY(e,t)}}const o=b.createInstance();b=g(r,b,o,d)?o:(new u).execute(b,r,d)}return this._ExecuteMultiPathGeodeticLength(b,y,f,U,P)}_ExecuteMultiPathGeodeticLength(r,o,s,i,a){const n={stack:[],error:void 0,hasError:!1};try{const t=e(n,new y,!1);let m=0;const p=r.querySegmentIterator();for(;p.nextPath();)for(;p.hasNextSegment();){const e=p.nextSegment(),r=e.getStartXY(),n=e.getEndXY();r.scale(a),n.scale(a),d.geodeticDistance(s,i,r.x,r.y,n.x,n.y,t,null,null,o),m+=t.val}return m}catch(e){n.error=e,n.hasError=!0}finally{t(n)}}}export{S as OperatorGeodeticLength};
