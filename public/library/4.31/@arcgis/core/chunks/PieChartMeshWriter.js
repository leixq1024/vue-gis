/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{D as t}from"./enums.js";import{a as e}from"./screenUtils.js";import{d as s,e as r,S as i,G as o,f as n}from"./CIMSymbolHelper.js";import{T as a,G as c,j as u}from"./GeometryUtils.js";import{f as l,h,j as p,p as f,s as d,k as x,l as m,q as y,r as _,M as g}from"./UpdateTracking2D.js";import{a as k,y as S,s as P,t as v,H as b,I as w,b as T,g as E}from"./definitions.js";import{h as M}from"../core/lang.js";import{t as z,l as I}from"./libtess.js";import{v as D,p as N,i as A,j as Y}from"./dataViewUtils.js";import{c as B}from"./mathUtils.js";import{b as L,c as G,s as F}from"./shapingUtils.js";import{o as C}from"./utils7.js";import{L as R,C as O,a as W,J as U,c as H}from"./enums2.js";import{L as X}from"./TurboLine.js";import"./earcut.js";import{O as V}from"./OptimizedGeometry.js";import{c as Z,t as j,r as q}from"./mat2d.js";import{c as Q}from"./mat2df32.js";import{t as J}from"./vec2.js";import{m as K}from"./constants.js";import $ from"../Color.js";import tt from"../core/Error.js";import{L as et}from"./Logger.js";import{c as st}from"../geometry/Polygon.js";function rt(t,e){return[!!t?.minScale&&e.scaleToZoom(t.minScale)||0,!!t?.maxScale&&e.scaleToZoom(t.maxScale)||100]}function it(t){return 1<<t}function ot(t){let e=0;for(const[s,r]of t)r&&(e|=1<<s);return e}function nt(t){let e;if(!t)return[0,0,0,0];if("string"==typeof t){const s=$.fromString(t);if(!s)return et.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.meshWriterUtils").errorOnce(new tt("mapview:mesh-processing","Unable to parse string into color",{color:t})),[0,0,0,0];e=s.toArray()}else e=t;const[s,r,i,o]=e;return[s*(o/255),r*(o/255),i*(o/255),o]}function at(t,e){return Math.round(Math.min(Math.sqrt(t*e),255))}function ct(t,e){return Math.round(t*e)/e}const ut=96/72;class lt{static executeEffects(t,e,o,n){const a=ut,c=s(t);let u=new i(e);for(const e of t){const t=r(e);t&&(u=t.execute(u,e,a,o,n,c))}return u}static applyEffects(t,e,n){if(!t)return e;const a=s(t);let c,u=new i(o.fromJSONCIM(e));for(const e of t){const t=r(e);t&&(u=t.execute(u,e,1,null,n,a))}const l=[];let h=null;for(;c=u.next();)l.push(...st(c)),h=c.geometryType;return 0===l.length||null===h?null:"esriGeometryPolygon"===h?{rings:l}:{paths:l}}}let ht=null;function pt(){return ht}function ft(e){switch(e){case t.BYTE:case t.UNSIGNED_BYTE:return 1;case t.SHORT:case t.UNSIGNED_SHORT:case t.HALF_FLOAT:return 2;case t.FLOAT:case t.INT:case t.UNSIGNED_INT:return 4}}class dt{static fromVertexSpec(t,e){const{attributes:s,optionalAttributes:r}=t;let i,o,n;const a=[];for(const t in s){const e=s[t];"position"===e.pack?i={...e,name:t,offset:0}:"id"===e.pack?o={...e,name:t,offset:4}:"bitset"===t?n={...e,name:t,offset:7}:a.push({...e,name:t})}for(const t in r)if(!0===e[t]){const e=r[t];a.push({...e,name:t})}const c=function(t){const e=[],s=[],r=[];for(const i of t){const t=ft(i.type)*i.count;switch(t%2||t%4||4){case 4:e.push(i);continue;case 2:s.push(i);continue;case 1:r.push(i);continue;default:throw new Error("Found unexpected dataType byte count")}}return e.push(...s),e.push(...r),e}(a),u=[];let l=8,h=1;for(const t of c)u.push({...t,offset:l}),l+=ft(t.type)*t.count,t.packAlternating&&(h=Math.max(t.packAlternating.count,h));const p=Uint32Array.BYTES_PER_ELEMENT,f=l%p;return new dt(i,o,n,u,l+(f?p-f:0),h)}constructor(t,e,s,r,i,o){this.position=t,this.id=e,this.bitset=s,this.standardAttributes=r,this.stride=i,this.packVertexCount=o,r.push(s),this._attributes=[t,e,s,...r]}get attributeLayout(){if(!this._attributeLayout){const t=D(this._attributes),e=this._attributes.map((t=>({name:t.name,count:t.count,offset:t.offset,type:t.type,packPrecisionFactor:t.packPrecisionFactor,normalized:t.normalized??!1})));this._attributeLayout={attributes:e,hash:t,stride:this.stride}}return this._attributeLayout}}class xt{static fromVertexSpec(t,e){const s=dt.fromVertexSpec(t,e);return new xt(s)}constructor(t){this._spec=t,this._packed=new Uint8Array(this._spec.stride*this._spec.packVertexCount),this._packedU32View=new Uint32Array(this._packed.buffer),this._dataView=new DataView(this._packed.buffer)}get attributeLayout(){return this._spec.attributeLayout}get stride(){return this._spec.stride}writeVertex(t,e,s,r,i,o){for(let t=0;t<this._spec.packVertexCount;t++){const n=t*this._spec.stride;this._packPosition(s,r,n),this._packId(e,n);const a=this._spec.bitset;if(o){if(a.packTessellation){const t=a.packTessellation(o,i);this._pack(t,a,n)}for(const t of this._spec.standardAttributes)if(null!=t.packTessellation){const e=t.packTessellation(o,i);this._pack(e,t,n)}else if(t.packAlternating?.packTessellation){const e=t.packAlternating.packTessellation(o,i);for(let s=0;s<this._spec.packVertexCount;s++){const r=e[s];this._pack(r,t,s*this._spec.stride)}}}}t.vertexWriteRegion(this._packedU32View)}pack(t,e){for(const s of this._spec.standardAttributes)if(s.pack&&"string"!=typeof s.pack){const r=s.pack(t,e);for(let t=0;t<this._spec.packVertexCount;t++)this._pack(r,s,t*this._spec.stride)}else if(s.packAlternating?.pack){const r=s.packAlternating.pack(t,e);for(let t=0;t<this._spec.packVertexCount;t++){const e=r[t];this._pack(e,s,t*this._spec.stride)}}}_packPosition(t,e,s){const{offset:r}=this._spec.position,i=this._spec.position.packPrecisionFactor??1,o=A(t*i,e*i);this._dataView.setUint32(s+r,o,!0)}_packId(t,e){const s=t*(this._spec.id.packPrecisionFactor??1),r=4278190080&this._dataView.getUint32(e+this._spec.id.offset,!0);this._dataView.setUint32(e+this._spec.id.offset,s|r,!0)}_pack(t,e,s){N(this._dataView,t,e,s)}}class mt{constructor(t,e,s,r){this._instanceId=t,this._evaluator=e,this._enabledOptionalAttributes=s,this._viewParams=r,this._evaluator.evaluator=t=>this.vertexSpec.createComputedParams(t)}get _vertexPack(){if(!this._cachedVertexPack){const t=xt.fromVertexSpec(this.vertexSpec,this._enabledOptionalAttributes);this._evaluator.hasDynamicProperties||t.pack(this._evaluator.evaluatedMeshParams,this._viewParams),this._cachedVertexPack=t}return this._cachedVertexPack}get evaluatedMeshParams(){return this._evaluator.evaluatedMeshParams}get hasEffects(){return!!this.evaluatedMeshParams.effects}get instanceId(){return this._instanceId}get attributeLayout(){return this._vertexPack.attributeLayout}setReferences(t){this._references=t}getBoundsInfo(){return null}getTileInfo(){return this._viewParams.tileInfo}async loadDependencies(){(function(t){if(!t)return!1;for(const e of t)switch(e.effect.type){case"CIMGeometricEffectBuffer":case"CIMGeometricEffectOffset":case"CIMGeometricEffectDonut":return!0}return!1})(this._evaluator.inputMeshParams.effects?.effectInfos)&&await async function(){ht=await import("./geometryEngineJSON.js").then((t=>t.g))}()}enqueueRequest(t,e,s){this._evaluator.hasDynamicProperties&&this._evaluator.enqueueRequest(t,e,s)}write(t,e,s,r,i){this.ensurePacked(e,s,r);const n=this.evaluatedMeshParams.effects;if(!n||0===n.length)return void this._write(t,s,void 0,i);const a=s.readGeometryForDisplay()?.clone();if(!a)return;const c=o.fromOptimizedCIM(a,s.geometryType),u=pt();c.invertY();const l=t.id||"",h=lt.executeEffects(n,c,l,u);let p;for(;p=h.next();)p.invertY(),this._write(t,s,p,i)}ensurePacked(t,e,s){if(!this._evaluator.hasDynamicProperties)return;const r=this._evaluator.evaluateMeshParams(t,e,s);this._vertexPack.pack(r,this._viewParams)}_writeVertex(t,e,s,r,i){const o=this.evaluatedMeshParams;this._vertexPack.writeVertex(t,e,s,r,o,i)}}function yt(t,e,s,r,i,o,n){Ot=0;const a=(r-s)*o,c=i&&i.length,u=c?(i[0]-s)*o:a;let l,h,p,f,d,x=_t(e,s,0,0,u,o,!0);if(x&&x.next!==x.prev){if(c&&(x=function(t,e,s,r,i,o){const n=new Array;for(let i=0,a=r.length;i<a;i++){const c=_t(t,e,0,r[i]*o,i<a-1?r[i+1]*o:s*o,o,!1);c===c.next&&(c.steiner=!0),n.push(wt(c))}n.sort(Yt);for(const t of n)i=Tt(t,i);return i}(e,s,r,i,x,o)),a>80*o){l=p=e[0+s*o],h=f=e[1+s*o];for(let t=o;t<u;t+=o){const r=e[t+s*o],i=e[t+1+s*o];l=Math.min(l,r),h=Math.min(h,i),p=Math.max(p,r),f=Math.max(f,i)}d=Math.max(p-l,f-h),d=0!==d?1/d:0}kt(x,t,o,l,h,d,n,0)}}function _t(t,e,s,r,i,o,n){let a;if(n===function(t,e,s,r,i,o){let n=0;for(let s=r,a=i-o;s<i;s+=o)n+=(t[a+e*o]-t[s+e*o])*(t[s+1+e*o]+t[a+1+e*o]),a=s;return n}(t,e,0,r,i,o)>0)for(let s=r;s<i;s+=o)a=vt(s+e*o,t[s+e*o],t[s+1+e*o],a);else for(let s=i-o;s>=r;s-=o)a=vt(s+e*o,t[s+e*o],t[s+1+e*o],a);return a&&At(a,a.next)&&(bt(a),a=a.next),a}function gt(t,e=t){if(!t)return t;let s,r=t;do{if(s=!1,r.steiner||!At(r,r.next)&&0!==Mt(r.prev,r,r.next))r=r.next;else{if(bt(r),r=e=r.prev,r===r.next)break;s=!0}}while(s||r!==e);return e}function kt(t,e,s,r,i,o,n,a){if(!t)return;!a&&o&&(t=Et(t,r,i,o));let c=t;for(;t.prev!==t.next;){const u=t.prev,l=t.next;if(o?Pt(t,r,i,o):St(t))e.push(u.index/s+n),e.push(t.index/s+n),e.push(l.index/s+n),bt(t),t=l.next,c=l.next;else if((t=l)===c){a?1===a?kt(t=Bt(t,e,s,n),e,s,r,i,o,n,2):2===a&&Lt(t,e,s,r,i,o,n):kt(gt(t),e,s,r,i,o,n,1);break}}}function St(t){const e=t.prev,s=t,r=t.next;if(Mt(e,s,r)>=0)return!1;let i=t.next.next;const o=i;let n=0;for(;i!==t.prev&&(0===n||i!==o);){if(n++,It(e.x,e.y,s.x,s.y,r.x,r.y,i.x,i.y)&&Mt(i.prev,i,i.next)>=0)return!1;i=i.next}return!0}function Pt(t,e,s,r){const i=t.prev,o=t,n=t.next;if(Mt(i,o,n)>=0)return!1;const a=i.x<o.x?i.x<n.x?i.x:n.x:o.x<n.x?o.x:n.x,c=i.y<o.y?i.y<n.y?i.y:n.y:o.y<n.y?o.y:n.y,u=i.x>o.x?i.x>n.x?i.x:n.x:o.x>n.x?o.x:n.x,l=i.y>o.y?i.y>n.y?i.y:n.y:o.y>n.y?o.y:n.y,h=Nt(a,c,e,s,r),p=Nt(u,l,e,s,r);let f=t.prevZ,d=t.nextZ;for(;f&&f.z>=h&&d&&d.z<=p;){if(f!==t.prev&&f!==t.next&&It(i.x,i.y,o.x,o.y,n.x,n.y,f.x,f.y)&&Mt(f.prev,f,f.next)>=0)return!1;if(f=f.prevZ,d!==t.prev&&d!==t.next&&It(i.x,i.y,o.x,o.y,n.x,n.y,d.x,d.y)&&Mt(d.prev,d,d.next)>=0)return!1;d=d.nextZ}for(;f&&f.z>=h;){if(f!==t.prev&&f!==t.next&&It(i.x,i.y,o.x,o.y,n.x,n.y,f.x,f.y)&&Mt(f.prev,f,f.next)>=0)return!1;f=f.prevZ}for(;d&&d.z<=p;){if(d!==t.prev&&d!==t.next&&It(i.x,i.y,o.x,o.y,n.x,n.y,d.x,d.y)&&Mt(d.prev,d,d.next)>=0)return!1;d=d.nextZ}return!0}function vt(t,e,s,r){const i=Ct.create(t,e,s);return r?(i.next=r.next,i.prev=r,r.next.prev=i,r.next=i):(i.prev=i,i.next=i),i}function bt(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function wt(t){let e=t,s=t;do{(e.x<s.x||e.x===s.x&&e.y<s.y)&&(s=e),e=e.next}while(e!==t);return s}function Tt(t,e){const s=function(t,e){let s=e;const r=t.x,i=t.y;let o,n=-1/0;do{if(i<=s.y&&i>=s.next.y&&s.next.y!==s.y){const t=s.x+(i-s.y)*(s.next.x-s.x)/(s.next.y-s.y);if(t<=r&&t>n){if(n=t,t===r){if(i===s.y)return s;if(i===s.next.y)return s.next}o=s.x<s.next.x?s:s.next}}s=s.next}while(s!==e);if(!o)return null;if(r===n)return o.prev;const a=o,c=o.x,u=o.y;let l,h=1/0;for(s=o.next;s!==a;)r>=s.x&&s.x>=c&&r!==s.x&&It(i<u?r:n,i,c,u,i<u?n:r,i,s.x,s.y)&&(l=Math.abs(i-s.y)/(r-s.x),(l<h||l===h&&s.x>o.x)&&Dt(s,t)&&(o=s,h=l)),s=s.next;return o}(t,e);if(!s)return e;const r=Ft(s,t);return gt(r,r.next),gt(s,s.next)}function Et(t,e,s,r){let i;for(;i!==t;i=i.next){if(i=i||t,null===i.z&&(i.z=Nt(i.x,i.y,e,s,r)),i.prev.next!==i||i.next.prev!==i)return i.prev.next=i,i.next.prev=i,Et(t,e,s,r);i.prevZ=i.prev,i.nextZ=i.next}return t.prevZ.nextZ=null,t.prevZ=null,function(t){let e,s=1;for(;;){let r,i=t;t=null,e=null;let o=0;for(;i;){o++,r=i;let n=0;for(;n<s&&r;n++)r=r.nextZ;let a=s;for(;n>0||a>0&&r;){let s;0===n?(s=r,r=r.nextZ,a--):0!==a&&r?i.z<=r.z?(s=i,i=i.nextZ,n--):(s=r,r=r.nextZ,a--):(s=i,i=i.nextZ,n--),e?e.nextZ=s:t=s,s.prevZ=e,e=s}i=r}if(e.nextZ=null,s*=2,o<2)return t}}(t)}function Mt(t,e,s){return(e.y-t.y)*(s.x-e.x)-(e.x-t.x)*(s.y-e.y)}function zt(t,e,s,r){return!!(At(t,e)&&At(s,r)||At(t,r)&&At(s,e))||Mt(t,e,s)>0!=Mt(t,e,r)>0&&Mt(s,r,t)>0!=Mt(s,r,e)>0}function It(t,e,s,r,i,o,n,a){return(i-n)*(e-a)-(t-n)*(o-a)>=0&&(t-n)*(r-a)-(s-n)*(e-a)>=0&&(s-n)*(o-a)-(i-n)*(r-a)>=0}function Dt(t,e){return Mt(t.prev,t,t.next)<0?Mt(t,e,t.next)>=0&&Mt(t,t.prev,e)>=0:Mt(t,e,t.prev)<0||Mt(t,t.next,e)<0}function Nt(t,e,s,r,i){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-s)*i)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-r)*i)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function At(t,e){return t.x===e.x&&t.y===e.y}function Yt(t,e){return t.x-e.x}function Bt(t,e,s,r){let i=t;do{const o=i.prev,n=i.next.next;!At(o,n)&&zt(o,i,i.next,n)&&Dt(o,n)&&Dt(n,o)&&(e.push(o.index/s+r),e.push(i.index/s+r),e.push(n.index/s+r),bt(i),bt(i.next),i=t=n),i=i.next}while(i!==t);return i}function Lt(t,e,s,r,i,o,n){let a=t;do{let t=a.next.next;for(;t!==a.prev;){if(a.index!==t.index&&Gt(a,t)){let c=Ft(a,t);return a=gt(a,a.next),c=gt(c,c.next),kt(a,e,s,r,i,o,n,0),void kt(c,e,s,r,i,o,n,0)}t=t.next}a=a.next}while(a!==t)}function Gt(t,e){return t.next.index!==e.index&&t.prev.index!==e.index&&!function(t,e){let s=t;do{if(s.index!==t.index&&s.next.index!==t.index&&s.index!==e.index&&s.next.index!==e.index&&zt(s,s.next,t,e))return!0;s=s.next}while(s!==t);return!1}(t,e)&&Dt(t,e)&&Dt(e,t)&&function(t,e){let s=t,r=!1;const i=(t.x+e.x)/2,o=(t.y+e.y)/2;do{s.y>o!=s.next.y>o&&s.next.y!==s.y&&i<(s.next.x-s.x)*(o-s.y)/(s.next.y-s.y)+s.x&&(r=!r),s=s.next}while(s!==t);return r}(t,e)}function Ft(t,e){const s=Ct.create(t.index,t.x,t.y),r=Ct.create(e.index,e.x,e.y),i=t.next,o=e.prev;return t.next=e,e.prev=t,s.next=i,i.prev=s,r.next=s,s.prev=r,o.next=r,r.prev=o,r}class Ct{constructor(){this.index=0,this.x=0,this.y=0,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}static create(t,e,s){const r=Ot<Rt.length?Rt[Ot++]:new Ct;return r.index=t,r.x=e,r.y=s,r.prev=null,r.next=null,r.z=null,r.prevZ=null,r.nextZ=null,r.steiner=!1,r}}const Rt=[];let Ot=0;for(let t=0;t<8096;t++)Rt.push(new Ct);const Wt=new a(0,0,0,1,0),Ut=new a(0,0,0,1,0);function Ht(t,e,s){let r=0;for(let i=1;i<s;i++){const s=t[2*(e+i-1)],o=t[2*(e+i-1)+1];r+=(t[2*(e+i)]-s)*(t[2*(e+i)+1]+o)}return r}function Xt(t,e,s,r,i){let o=0;for(let n=s;n<r;n+=3){const s=2*(t[n]-i),r=2*(t[n+1]-i),a=2*(t[n+2]-i);o+=Math.abs((e[s]-e[a])*(e[r+1]-e[s+1])-(e[s]-e[r])*(e[a+1]-e[s+1]))}return o}function Vt(t,e){if(null==t)return null;if(!function(t,e,s){let r=0;for(let e=0;e<t.lengths.length;e++){const i=t.lengths[e];for(let e=0;e<i;e++){const i=t.coords[2*(e+r)],o=t.coords[2*(e+r)+1];if(i<-128||i>s||o<-128||o>s)return!0}r+=i}return!1}(t,0,k+128))return t;Wt.setPixelMargin(e),Wt.reset(c.Polygon);let s=0;for(let e=0;e<t.lengths.length;e++){const r=t.lengths[e];let i=t.coords[2*(0+s)],o=t.coords[2*(0+s)+1];Wt.moveTo(i,o);for(let e=1;e<r;e++)i=t.coords[2*(e+s)],o=t.coords[2*(e+s)+1],Wt.lineTo(i,o);Wt.close(),s+=r}const r=Wt.result(!1);if(!r)return null;const i=[],o=[];for(const t of r){let e=0;for(const s of t)o.push(s.x),o.push(s.y),e++;i.push(e)}return new V(i,o)}Wt.setExtent(k),Ut.setExtent(k);const Zt=M("featurelayer-fast-triangulation-enabled");class jt extends mt{async loadDependencies(){await Promise.all([super.loadDependencies(),I()])}_write(t,e,s){const r=s?.asOptimized()??e.readGeometryForDisplay(),i=this._clip(r);i&&(t.recordStart(this.instanceId,this.attributeLayout),this._writeGeometry(t,e,i),t.recordEnd())}_clip(t){return t?Vt(t,this.hasEffects?256:8):null}_writeGeometry(t,e,s){const r=s.maxLength>100,i=[],o=this.createTesselationParams(e);if(!r&&Zt&&function(t,e){const{coords:s,lengths:r}=e,i=t;let o=0;for(let t=0;t<r.length;){let e=t,n=r[t],a=Ht(s,o,n);const c=[];for(;++e<r.length;){const t=r[e],i=Ht(s,o+n,t);if(!(i>0))break;a+=i,c.push(o+n),n+=t}const u=i.length;yt(i,s,o,o+n,c,2,0);const l=Xt(i,s,u,i.length,0),h=Math.abs(a);if(Math.abs((l-h)/Math.max(1e-7,h))>1e-5)return i.length=0,!1;t=e,o+=n}return!0}(i,s))return void(i.length&&this._writeVertices(t,e,s.coords,o,i));const n=function(t){const{coords:e,lengths:s}=t,{buffer:r}=z(e,s);return r}(s);this._writeVertices(t,e,n,o)}_writeVertices(t,e,s,r,i){const o=e.getDisplayId(),n=t.vertexCount(),a=this.hasEffects;let c=0;if(i)for(const e of i){const i=s[2*e],n=s[2*e+1];a&&t.recordBounds(i,n,0,0),this._writeVertex(t,o,i,n,r),c++}else for(let e=0;e<s.length;e+=2){const i=Math.round(s[e]),n=Math.round(s[e+1]);a&&t.recordBounds(i,n,0,0),this._writeVertex(t,o,i,n,r),c++}t.indexEnsureSize(c);for(let e=0;e<c;e++)t.indexWrite(e+n)}}const qt={createComputedParams:t=>t,optionalAttributes:{},attributes:{id:{type:t.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:t.UNSIGNED_BYTE,count:1},pos:{type:t.SHORT,count:2,pack:"position",packPrecisionFactor:10},inverseArea:{type:t.FLOAT,count:1,packTessellation:({inverseArea:t})=>t}}};class Qt extends jt{constructor(){super(...arguments),this.vertexSpec=qt}createTesselationParams(t){return{inverseArea:1/t.readGeometryArea()}}}const Jt={createComputedParams:t=>t,optionalAttributes:{zoomRange:{type:t.SHORT,count:2,packPrecisionFactor:S,pack:({scaleInfo:t},{tileInfo:e})=>rt(t,e)}},attributes:{id:{type:t.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:t.UNSIGNED_BYTE,count:1},pos:{type:t.SHORT,count:2,pack:"position",packPrecisionFactor:10},color:{type:t.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:t})=>nt(t)}}};class Kt extends jt{constructor(){super(...arguments),this.vertexSpec=Jt}createTesselationParams(t){return null}}const $t={createComputedParams:t=>t,optionalAttributes:Jt.optionalAttributes,attributes:{...Jt.attributes,tlbr:{count:4,type:t.UNSIGNED_SHORT,pack:({sprite:t})=>{const{rect:e,width:s,height:r}=t,i=e.x+P,o=e.y+P;return[i,o,i+s,o+r]}},inverseRasterizationScale:{count:1,type:t.BYTE,packPrecisionFactor:16,pack:({sprite:t})=>1/t.rasterizationScale}}};class te extends Kt{constructor(){super(...arguments),this.vertexSpec=$t}_write(t,e,s){const r=s?.asOptimized()??e.readGeometryForDisplay(),i=this._clip(r);if(!i)return;const o=this.evaluatedMeshParams.sprite?.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,o),this._writeGeometry(t,e,i),t.recordEnd()}}function ee(t){const{sprite:s,aspectRatio:r,scaleProportionally:i}=t,o=e(t.height),n=o>0?o:s.height;let a=o*r;return a<=0?a=s.width:i&&(a*=s.width/s.height),{width:a,height:n}}function se(t){const{applyRandomOffset:e,sampleAlphaOnly:s}=t;return ot([[l,e],[h,s]])}const re={createComputedParams:t=>t,optionalAttributes:$t.optionalAttributes,attributes:{...$t.attributes,bitset:{count:1,type:t.UNSIGNED_BYTE,pack:se},width:{count:1,type:t.HALF_FLOAT,pack:t=>ee(t).width},height:{count:1,type:t.HALF_FLOAT,pack:t=>ee(t).height},offset:{count:2,type:t.HALF_FLOAT,pack:({offsetX:t,offsetY:s})=>[e(t),-e(s)]},scale:{count:2,type:t.UNSIGNED_BYTE,packPrecisionFactor:16,pack:({scaleX:t,scaleY:e})=>[t,e]},angle:{count:1,type:t.UNSIGNED_BYTE,pack:({angle:t})=>u(t)}}};class ie extends te{constructor(){super(...arguments),this.vertexSpec=re}}class oe{constructor(){this.extrusionOffsetX=0,this.extrusionOffsetY=0,this.normalX=0,this.normalY=0,this.directionX=0,this.directionY=0,this.distance=0}}const ne={createComputedParams:t=>t,optionalAttributes:{zoomRange:{type:t.SHORT,count:2,packPrecisionFactor:S,pack:({scaleInfo:t},{tileInfo:e})=>rt(t,e)}},attributes:{id:{type:t.UNSIGNED_BYTE,count:3,pack:"id"},pos:{type:t.SHORT,count:2,pack:"position",packPrecisionFactor:10},bitset:{type:t.UNSIGNED_BYTE,count:1},color:{type:t.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:t})=>nt(t)},offset:{type:t.BYTE,count:2,packPrecisionFactor:16,packTessellation:({extrusionOffsetX:t,extrusionOffsetY:e})=>[ct(t,16),ct(e,16)]},normal:{type:t.BYTE,count:2,packPrecisionFactor:16,packTessellation:({normalX:t,normalY:e})=>[ct(t,16),ct(e,16)]},halfWidth:{type:t.HALF_FLOAT,count:1,pack:({width:t})=>e(.5*t)},referenceHalfWidth:{type:t.HALF_FLOAT,count:1,pack:({referenceWidth:t})=>e(.5*t)}}};class ae{constructor(){this.id=0,this.bitset=0,this.indexCount=0,this.vertexCount=0,this.vertexFrom=0,this.vertexBounds=0}}class ce extends mt{constructor(t,e,s,r){super(t,e,s,r),this.vertexSpec=ne,this._currentWrite=new ae,this._tessellationOptions={halfWidth:0,pixelCoordRatio:1,offset:0,wrapDistance:65535,textured:!1},this._tessParams=new oe,this._initializeTessellator()}writeLineVertices(t,e,s){const r=this._getLines(e);null!=r&&this._writeVertices(t,s,r)}_initializeTessellator(){this._lineTessellator=new X(this._writeTesselatedVertex.bind(this),this._writeTriangle.bind(this),!0)}_write(t,e,s){const r=s??o.fromFeatureSetReaderCIM(e);r&&this._writeGeometry(t,e,r)}_writeGeometry(t,e,s,r){t.recordStart(this.instanceId,this.attributeLayout,r),this.writeLineVertices(t,s,e),t.recordEnd()}_getLines(t){return function(t,e){Ut.setPixelMargin(e);const s=Ut,r=-e,i=k+e;let o=[],n=!1;if(!t.nextPath())return null;let a=!0;for(;a;){t.seekPathStart();const e=[];if(!t.pathSize)return null;s.reset(c.LineString),t.nextPoint();let u=t.x,l=t.y;if(n)s.moveTo(u,l);else{if(u<r||u>i||l<r||l>i){n=!0;continue}e.push({x:u,y:l})}let h=!1;for(;t.nextPoint();)if(u=t.x,l=t.y,n)s.lineTo(u,l);else{if(u<r||u>i||l<r||l>i){h=!0;break}e.push({x:u,y:l})}if(h)n=!0;else{if(n){const t=s.resultWithStarts();if(t)for(const e of t)o.push(e)}else o.push({line:e,start:0});a=t.nextPath(),n=!1}}return o=o.filter((t=>t.line.length>1)),0===o.length?null:o}(t,Y(this.evaluatedMeshParams))}_writeVertices(t,s,r){const{_currentWrite:i,_tessellationOptions:o,evaluatedMeshParams:n}=this,{width:a,capType:c,joinType:u,miterLimit:l,hasSizeVV:h}=n,p=e(.5*a);o.halfWidth=p,o.capType=function(t){switch(t){case"butt":case R.Butt:return O.BUTT;case"round":case R.Round:return O.ROUND;case"square":case R.Square:return O.SQUARE}}(c),o.joinType=function(t){switch(t){case"bevel":case W.Bevel:return U.BEVEL;case"miter":case W.Miter:return U.MITER;case"round":case W.Round:return U.ROUND}}(u),o.miterLimit=l;const f=!h;i.out=t,i.id=s.getDisplayId(),i.vertexCount=0,i.indexCount=0,i.vertexFrom=t.vertexCount(),i.vertexBounds=f&&p<v?0:1;for(const{line:t,start:e}of r)o.initialDistance=e%65535,this._lineTessellator.tessellate(t,o,f)}_writeTesselatedVertex(t,e,s,r,i,o,n,a,c,u,l){const{out:h,id:p,vertexBounds:f}=this._currentWrite;return this.hasEffects&&h.recordBounds(t,e,f,f),this._tessParams.extrusionOffsetX=n,this._tessParams.extrusionOffsetY=a,this._tessParams.normalX=c,this._tessParams.normalY=u,this._tessParams.directionX=i,this._tessParams.directionY=o,this._tessParams.distance=l,this._writeVertex(h,p,t,e,this._tessParams),this._currentWrite.vertexFrom+this._currentWrite.vertexCount++}_writeTriangle(t,e,s){const{out:r}=this._currentWrite;r.indexEnsureSize(3),r.indexWrite(t),r.indexWrite(e),r.indexWrite(s),this._currentWrite.indexCount+=3}}const ue={createComputedParams:t=>t,optionalAttributes:ne.optionalAttributes,attributes:{...ne.attributes,bitset:{type:t.UNSIGNED_BYTE,count:1,pack:t=>0},color:{type:t.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:t})=>nt(t)}}},le={createComputedParams:t=>t,optionalAttributes:ne.optionalAttributes,attributes:{...ne.attributes,bitset:{type:t.UNSIGNED_BYTE,count:1,pack:t=>ot([[p,!0]])},color:{type:t.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:t})=>nt(t)}}};class he extends ce{constructor(){super(...arguments),this.vertexSpec=le}}class pe extends Kt{constructor(t,e,s,r){super(t,e,s,r),this.vertexSpec=ue,this._lineMeshWriter=this._createOutlineWriter(t,e,s,r)}_createOutlineWriter(t,e,s,r){return new he(t,e,s,r)}_write(t,e,s){const r=s?.asOptimized()??e.readGeometryForDisplay(),i=this._clip(r);i&&(t.recordStart(this.instanceId,this.attributeLayout),this._writeGeometry(t,e,i),this._lineMeshWriter.writeLineVertices(t,o.fromOptimizedCIM(i,"esriGeometryPolyline"),e),t.recordEnd())}_clip(t){return t?Vt(t,Y(this.evaluatedMeshParams)):null}ensurePacked(t,e,s){super.ensurePacked(t,e,s),this._lineMeshWriter.ensurePacked(t,e,s)}enqueueRequest(t,e,s){super.enqueueRequest(t,e,s),this._lineMeshWriter.enqueueRequest(t,e,s)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}}const fe=re,de=le,xe={createComputedParams:t=>t,optionalAttributes:fe.optionalAttributes,attributes:{...fe.attributes,bitset:{type:t.UNSIGNED_BYTE,count:1,pack:t=>se(t)},aux1:{count:1,type:t.HALF_FLOAT,pack:t=>ee(t).width},aux2:{count:1,type:t.HALF_FLOAT,pack:t=>ee(t).height},aux3:{count:2,type:t.HALF_FLOAT,pack:({offsetX:t,offsetY:s})=>[e(t),e(s)]},aux4:{count:2,type:t.UNSIGNED_BYTE,pack:({scaleX:t,scaleY:e})=>[t*f,e*f]}}},me={createComputedParams:t=>t,optionalAttributes:fe.optionalAttributes,attributes:{...fe.attributes,color:de.attributes.color,bitset:{type:t.UNSIGNED_BYTE,count:1,pack:t=>ot([[p,!0]])},aux1:{count:1,type:t.HALF_FLOAT,pack:t=>e(.5*t.width)},aux2:{count:1,type:t.HALF_FLOAT,pack:t=>e(.5*t.referenceWidth)},aux3:{count:2,type:t.HALF_FLOAT,packTessellation:({extrusionOffsetX:t,extrusionOffsetY:e})=>[t,e]},aux4:{count:2,type:t.UNSIGNED_BYTE,packTessellation:({normalX:t,normalY:e})=>[t*f+d,e*f+d]}}};class ye extends he{constructor(){super(...arguments),this.vertexSpec=me}}class _e extends pe{constructor(){super(...arguments),this.vertexSpec=xe}_createOutlineWriter(t,e,s,r){return new ye(t,e,s,r)}_write(t,e,s){const r=s?.asOptimized()??e.readGeometryForDisplay(),i=this._clip(r);if(!i)return;const n=this.evaluatedMeshParams.sprite?.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,n),this._writeGeometry(t,e,i),this._lineMeshWriter.writeLineVertices(t,o.fromOptimizedCIM(i,"esriGeometryPolyline"),e),t.recordEnd()}ensurePacked(t,e,s){super.ensurePacked(t,e,s),this._lineMeshWriter.ensurePacked(t,e,s)}enqueueRequest(t,e,s){super.enqueueRequest(t,e,s),this._lineMeshWriter.enqueueRequest(t,e,s)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}}const ge={optionalAttributes:$t.optionalAttributes,createComputedParams:t=>t,attributes:{...$t.attributes,...ue.attributes}},ke={optionalAttributes:$t.optionalAttributes,createComputedParams:t=>t,attributes:{...$t.attributes,...le.attributes}};class Se extends he{constructor(){super(...arguments),this.vertexSpec=ke}}class Pe extends pe{constructor(){super(...arguments),this.vertexSpec=ge}_createOutlineWriter(t,e,s,r){return new Se(t,e,s,r)}_write(t,e,s){const r=s?.asOptimized()??e.readGeometryForDisplay(),i=this._clip(r);if(!i)return;const n=this.evaluatedMeshParams.sprite?.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,n),this._writeGeometry(t,e,i),this._lineMeshWriter.writeLineVertices(t,o.fromOptimizedCIM(i,"esriGeometryPolyline"),e),t.recordEnd()}ensurePacked(t,e,s){super.ensurePacked(t,e,s),this._lineMeshWriter.ensurePacked(t,e,s)}enqueueRequest(t,e,s){super.enqueueRequest(t,e,s),this._lineMeshWriter.enqueueRequest(t,e,s)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}}const ve={createComputedParams:t=>t,optionalAttributes:{},attributes:{pos:{type:t.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:t.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:t.UNSIGNED_BYTE,count:1},offset:{type:t.BYTE,count:2,packAlternating:{count:4,pack:()=>[[-1,-1],[1,-1],[-1,1],[1,1]]}}}};class be extends mt{constructor(){super(...arguments),this.vertexSpec=ve}_write(t,e){t.recordStart(this.instanceId,this.attributeLayout);const s=e.getDisplayId();if("esriGeometryPoint"===e.geometryType){const r=e.readXForDisplay(),i=e.readYForDisplay();this._writeQuad(t,s,r,i)}else if("esriGeometryMultipoint"===e.geometryType){const r=e.readGeometryForDisplay();r?.forEachVertex(((e,r)=>{e>=0&&e<=512&&r>=0&&r<=512&&this._writeQuad(t,s,e,r)}))}t.recordEnd()}_writeQuad(t,e,s,r){const i=t.vertexCount();this._writeVertex(t,e,s,r),t.indexWrite(i+0),t.indexWrite(i+1),t.indexWrite(i+2),t.indexWrite(i+1),t.indexWrite(i+3),t.indexWrite(i+2)}}class we{static getPlacement(t,e,s,r,i,o){const a=n(s);return a?(-1===e&&t.invertY(),a.execute(t,s,r,i,o)):null}}class Te{constructor(t){const{offsetX:e,offsetY:s,postAngle:r,fontSize:i,haloSize:o,outlineSize:n,scaleFactor:a,transforms:c}=t;if(this.offsetX=e,this.offsetY=s,this.postAngle=r,this.fontSize=Math.min(i,96),this.haloSize=o??0,this.outlineSize=n??0,this.transforms=c,c&&c.infos.length>1){const t=C(i,r,!1,e,s,c,!1);this.fontSize=Math.min(t.size,96);const o=t.size/i;this.haloSize*=o,this.outlineSize*=o,this.postAngle=t.rotation,this.offsetX=t.offsetX,this.offsetY=t.offsetY}a&&(this.fontSize*=a,this.offsetX*=a,this.offsetY*=a)}}const Ee=28,Me=[4,4],ze=[16,4],Ie={topLeft:ze,topRight:ze,bottomLeft:ze,bottomRight:ze},De=[4,2],Ne=[4,6],Ae={topLeft:De,topRight:De,bottomLeft:Ne,bottomRight:Ne},Ye={topLeft:De,topRight:Ne,bottomLeft:De,bottomRight:Ne},Be={topLeft:Ne,topRight:Ne,bottomLeft:Me,bottomRight:Me},Le={topLeft:Me,topRight:Me,bottomLeft:Ne,bottomRight:Ne},Ge={topLeft:Ne,topRight:Me,bottomLeft:Ne,bottomRight:Me},Fe={topLeft:Me,topRight:Ne,bottomLeft:Me,bottomRight:Ne},Ce={createComputedParams:t=>t,optionalAttributes:{zoomRange:{type:t.UNSIGNED_SHORT,count:2,packPrecisionFactor:S,packTessellation:({minZoom:t,maxZoom:e})=>[t||0,e||28]},clipAngle:{type:t.UNSIGNED_BYTE,count:1,packTessellation:({clipAngle:t})=>Oe(t||0)},referenceSymbol:{type:t.BYTE,count:4,packPrecisionFactor:1,packTessellation:(t,s)=>{const r=t.isLineLabel||!t.referenceBounds,i=L(r?"center":s.horizontalAlignment),o=G(r?"middle":s.verticalAlignment),{offsetX:n,offsetY:a,size:c}=r?{offsetX:0,offsetY:0,size:0}:t.referenceBounds;return[e(n),-e(a),Math.round(e(c)),i+1<<2|o+1]}}},attributes:{pos:{type:t.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:t.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:t.UNSIGNED_BYTE,count:1,packTessellation:({isBackground:t,mapAligned:e})=>ot([[x,t],[m,!!e]])},offset:{type:t.SHORT,count:2,packPrecisionFactor:8,packAlternating:{count:4,packTessellation:({offsets:t})=>{const{bottomLeft:e,bottomRight:s,topLeft:r,topRight:i}=t;return[r,i,e,s]}}},textureUV:{type:t.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,packTessellation:({texcoords:t})=>{const{bottomLeft:e,bottomRight:s,topLeft:r,topRight:i}=t;return[r,i,e,s]}}},color:{type:t.UNSIGNED_BYTE,count:4,normalized:!0,packTessellation:({color:t})=>t},fontSize:{type:t.UNSIGNED_SHORT,count:1,packPrecisionFactor:4,packTessellation:({fontSize:t})=>Math.round(e(t))},referenceSize:{type:t.UNSIGNED_BYTE,count:1,packPrecisionFactor:4,packTessellation:({fontSize:t},{referenceSize:s})=>Math.round(e(s??t))},outlineColor:{type:t.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:t})=>nt(t)},haloColor:{type:t.UNSIGNED_BYTE,count:4,normalized:!0,pack:({haloColor:t})=>nt(t)},outlineAndHaloSize:{type:t.UNSIGNED_SHORT,count:2,packPrecisionFactor:4,packTessellation:({outlineSize:t,haloSize:s})=>[Math.round(e(t)),Math.round(e(s))]}}};class Re extends mt{constructor(){super(...arguments),this.vertexSpec=Ce,this._textMeshParamsPropsInitialized=!1}ensurePacked(t,e,s){super.ensurePacked(t,e,s),this._textMeshParamsPropsInitialized&&!this._evaluator.hasDynamicProperties||(this._textMeshTransformProps=new Te(this.evaluatedMeshParams),this._textMeshParamsPropsInitialized=!0)}_write(t,e,s){const r=this._getShaping();if(!r)return;const i=e.getDisplayId();if(null!=this.evaluatedMeshParams.placement)return this._writePlacedTextMarkers(t,e,r,s);if(s?.nextPath())return s.nextPoint(),this._writeGlyphs(t,i,s.x,s.y,r,0);if("esriGeometryPolygon"===e.geometryType){const s=e.readCentroidForDisplay();if(!s)return;const[o,n]=s.coords;return this._writeGlyphs(t,i,o,n,r,0)}if("esriGeometryMultipoint"===e.geometryType){const s=e.readGeometryForDisplay();return void s?.forEachVertex(((e,s)=>this._writeGlyphs(t,i,e,s,r,0)))}const o=e.readXForDisplay(),n=e.readYForDisplay();return this._writeGlyphs(t,i,o,n,r,0)}_writePlacedTextMarkers(t,s,r,i){const n=i??o.fromFeatureSetReaderCIM(s);if(!n)return;const a=we.getPlacement(n,-1,this.evaluatedMeshParams.placement,e(1),t.id,pt());if(!a)return;const c=s.getDisplayId();let u=a.next();for(;null!=u;){const e=u.tx,s=-u.ty,i=-u.getAngle();this._writeGlyphs(t,c,e,s,r,i),u=a.next()}}_getShaping(t){const s=this._textMeshTransformProps,r=this.evaluatedMeshParams;if(!r.glyphs?.glyphs.length)return null;const i=e(s.fontSize),o=e(s.offsetX),n=e(s.offsetY),a=B(e(r.lineWidth),w,b),c=T*B(r.lineHeightRatio,.25,4);return F(r.glyphs,{scale:i/E,angle:s.postAngle,xOffset:o,yOffset:n,horizontalAlignment:r.horizontalAlignment,verticalAlignment:t||r.verticalAlignment,maxLineWidth:a,lineHeight:c,decoration:r.decoration,borderLineSizePx:e(r.boxBorderLineSize),hasBackground:!!r.boxBackgroundColor,useCIMAngleBehavior:r.useCIMAngleBehavior})}_writeGlyphs(t,s,r,i,o,n,a,c){const u=this.evaluatedMeshParams,l=this._textMeshTransformProps,h=e(l.fontSize),p=l.haloSize,f=l.outlineSize,d=e(l.offsetX),x=e(l.offsetY),[m,y]=rt(u.scaleInfo,this.getTileInfo());0!==n&&o.setRotation(n);const _=o.bounds,g=r+_.x+d,k=i+_.y-x,S=2*(u.minPixelBuffer?u.minPixelBuffer/h:1),P=Math.max(_.width,_.height)*S;o.textBox&&(t.recordStart(this.instanceId,this.attributeLayout,o.glyphs[0].textureBinding),t.recordBounds(g,k,P,P),this._writeTextBox(t,s,r,i,o.textBox,a,c),t.recordEnd());for(const e of o.glyphs){t.recordStart(this.instanceId,this.attributeLayout,e.textureBinding),t.recordBounds(g,k,P,P);const{texcoords:o,offsets:n}=e;this._writeQuad(t,s,r,i,{texcoords:o,offsets:n,fontSize:h,haloSize:p,outlineSize:f,color:nt(u.color),isBackground:!1,referenceBounds:a,minZoom:m,maxZoom:y,...c}),t.recordEnd()}0!==n&&o.setRotation(-n)}_writeTextBox(t,e,s,r,i,o,n){const a=this.evaluatedMeshParams,{fontSize:c,haloSize:u,outlineSize:l}=this._textMeshTransformProps,{boxBackgroundColor:h,boxBorderLineColor:p}=a,f={isBackground:!0,fontSize:c,haloSize:u,outlineSize:l,referenceBounds:o,...n};h&&(this._writeQuad(t,e,s,r,{texcoords:Ie,offsets:i.main,color:nt(h),...f}),p||(this._writeQuad(t,e,s,r,{texcoords:Be,offsets:i.top,color:nt(h),...f}),this._writeQuad(t,e,s,r,{texcoords:Le,offsets:i.bot,color:nt(h),...f}),this._writeQuad(t,e,s,r,{texcoords:Ge,offsets:i.left,color:nt(h),...f}),this._writeQuad(t,e,s,r,{texcoords:Fe,offsets:i.right,color:nt(h),...f}))),p&&(this._writeQuad(t,e,s,r,{texcoords:Ae,offsets:i.top,color:nt(p),...f}),this._writeQuad(t,e,s,r,{texcoords:Ae,offsets:i.bot,color:nt(p),...f}),this._writeQuad(t,e,s,r,{texcoords:Ye,offsets:i.left,color:nt(p),...f}),this._writeQuad(t,e,s,r,{texcoords:Ye,offsets:i.right,color:nt(p),...f}))}_writeQuad(t,e,s,r,i){const o=t.vertexCount();this._writeVertex(t,e,s,r,i),t.indexWrite(o+0),t.indexWrite(o+1),t.indexWrite(o+2),t.indexWrite(o+1),t.indexWrite(o+3),t.indexWrite(o+2)}}const Oe=t=>Math.round(t*(254/360)),We={createComputedParams:t=>t,optionalAttributes:ne.optionalAttributes,attributes:{...ne.attributes,bitset:{type:t.UNSIGNED_BYTE,count:1,pack:({shouldSampleAlphaOnly:t,shouldScaleDash:e,isSDF:s})=>ot([[h,t],[y,e],[_,s]])},tlbr:{type:t.UNSIGNED_SHORT,count:4,pack:({sprite:t})=>{const{rect:e,width:s,height:r}=t,i=e.x+P,o=e.y+P;return[i,o,i+s,o+r]}},accumulatedDistance:{type:t.UNSIGNED_SHORT,count:1,packTessellation:({distance:t})=>t},segmentDirection:{type:t.BYTE,count:2,packPrecisionFactor:16,packTessellation:({directionX:t,directionY:e})=>[t,e]},offsetAlongLine:{type:t.HALF_FLOAT,count:1,pack:({offsetAlongLine:t})=>e(t)},capType:{type:t.UNSIGNED_BYTE,count:1,pack:({capType:t})=>{switch(t){case R.Butt:case"butt":return 0;case R.Square:case"square":return 1;case R.Round:case"round":return 2;default:return 0}}}}};class Ue extends ce{constructor(t,e,s,r){super(t,e,s,r),this.vertexSpec=We,this._tessellationOptions.textured=!0}_write(t,e,s){const r=s??o.fromFeatureSetReaderCIM(e);if(!r)return;const{sprite:i}=this.evaluatedMeshParams;this._writeGeometry(t,e,r,i?.textureBinding)}}class He{static from(t){return"width"in t?this.fromSimpleMeshParams(t):this.fromComplexMeshParams(t)}static fromSimpleMeshParams(t){const s=new He(t.sprite,t.color,t.outlineColor,t.minPixelBuffer,t.placement,t.scaleInfo,t.effects),{type:r,width:i,height:o,angle:n,alignment:a,outlineSize:c,referenceSize:u,sprite:l,overrideOutlineColor:h}=t;return s.rawWidth=e(i),s.rawHeight=e(o),s.angle=n,s.alignment=a,s.outlineSize=e(c),s.referenceSize=e(u),s.overrideOutlineColor=h,s.offsetX=e(t.offsetX),s.offsetY=e(t.offsetY),"simple"!==r||l.sdf||(s.rawWidth=l.width,s.rawHeight=l.height),s._computeSize(t,!1),s}static fromComplexMeshParams(t){const s=new He(t.sprite,t.color,t.outlineColor,t.minPixelBuffer,t.placement,t.scaleInfo,t.effects);let{alignment:r,transforms:i,size:o,scaleX:n,anchorX:a,anchorY:c,angle:u,colorLocked:l,frameHeight:h,widthRatio:p,offsetX:f,offsetY:d,outlineSize:x,referenceSize:m,scaleFactor:y,sizeRatio:_,isAbsoluteAnchorPoint:g,rotateClockwise:k,scaleSymbolsProportionally:S,sprite:P}=t;if(i&&i.infos.length>0){const t=C(o,u,k,f,d,i);o=t.size,u=t.rotation,f=t.offsetX,d=t.offsetY,k=!1}y&&(o*=y,f*=y,d*=y);const v=n*(P.width/P.height);s.alignment=r,s.rawHeight=e(o),s.rawWidth=s.rawHeight*v,s.referenceSize=e(m),s.sizeRatio=_,s.sdfDecodeCoeff=(P.sdfDecodeCoeff??1)*_,s.angle=u,s.rotateClockwise=k,s.anchorX=a,s.anchorY=c,s.offsetX=e(f),s.offsetY=e(d),g&&o&&(P.sdf?s.anchorX=a/(o*p):s.anchorX=a/(o*v),s.anchorY=c/o);const b=S&&h?o/h:1;return s.outlineSize=0===x||isNaN(x)?0:e(x)*b,s.scaleSymbolsProportionally=S,s.colorLocked=l,s._computeSize(t,!0),s}constructor(t,e,s,r,i,o,n){this.sprite=t,this.color=e,this.outlineColor=s,this.minPixelBuffer=r,this.placement=i,this.scaleInfo=o,this.effects=n,this.rawWidth=0,this.rawHeight=0,this.angle=0,this.outlineSize=0,this.referenceSize=0,this.sizeRatio=1,this.sdfDecodeCoeff=1,this.alignment=H.SCREEN,this.scaleSymbolsProportionally=!1,this.overrideOutlineColor=!1,this.colorLocked=!1,this.anchorX=0,this.anchorY=0,this.computedWidth=0,this.computedHeight=0,this.texXmin=0,this.texYmin=0,this.texXmax=0,this.texYmax=0,this.offsetX=0,this.offsetY=0,this.rotateClockwise=!0}get boundsInfo(){return{size:Math.max(this.computedHeight,this.computedWidth),offsetX:this.offsetX,offsetY:this.offsetY}}_computeSize(t,e){const{sprite:s,hasSizeVV:r}=t,i=!!s.sdf,o=s.sdfPaddingRatio??.5,{rawWidth:n,rawHeight:a,sizeRatio:c,outlineSize:u}=this,l=c*(i?1/(1-o):1),h=n*l,p=a*l;if(i&&!r){const t=e&&n>a?h:n,s=a,r=u+2;this.computedWidth=Math.min(t+r,h),this.computedHeight=Math.min(s+r,p)}else this.computedWidth=h,this.computedHeight=p;const f=i?Math.max(s.width,s.height)/Math.max(h,p):1,d=.5*(h-this.computedWidth)*f,x=.5*(p-this.computedHeight)*f,m=s.rect.x+P+d,y=s.rect.y+P+x,_=m+s.width-2*d,g=y+s.height-2*x;this.texXmin=Math.floor(m),this.texYmin=Math.floor(y),this.texXmax=Math.ceil(_),this.texYmax=Math.ceil(g),this.computedWidth*=(this.texXmax-this.texXmin)/(_-m),this.computedHeight*=(this.texYmax-this.texYmin)/(g-y),this.anchorX*=h/this.computedWidth,this.anchorY*=p/this.computedHeight}}const Xe=128/Math.PI,Ve={createComputedParams:t=>He.from(t),optionalAttributes:{zoomRange:{type:t.SHORT,count:2,packPrecisionFactor:S,pack:({scaleInfo:t},{tileInfo:e})=>rt(t,e)}},attributes:{pos:{type:t.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:t.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:t.UNSIGNED_BYTE,count:1,pack:({sprite:t,alignment:e,scaleSymbolsProportionally:s,overrideOutlineColor:r,colorLocked:i})=>{let o=0;return t.sdf&&(o|=it(g.bitset.isSDF)),e===H.MAP&&(o|=it(g.bitset.isMapAligned)),s&&(o|=it(g.bitset.scaleSymbolsProportionally)),r&&(o|=it(g.bitset.overrideOutlineColor)),i&&(o|=it(g.bitset.colorLocked)),o}},offset:{type:t.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:({angle:t,computedWidth:e,computedHeight:s,anchorX:r,anchorY:i,offsetX:o,offsetY:n,rotateClockwise:a})=>{const c=function(t,e,s,r,i=!1){const o=Q(),n=i?1:-1;return Z(o),(e||s)&&j(o,o,[e,-s]),r&&q(o,o,.017453292519944444*n*-r),o}(0,o,n,-t,a),u=-(.5+r)*e,l=-(.5-i)*s,h=[u,l],p=[u+e,l],f=[u,l+s],d=[u+e,l+s];return J(h,h,c),J(p,p,c),J(f,f,c),J(d,d,c),[h,p,f,d]}}},textureUV:{type:t.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:({texXmax:t,texXmin:e,texYmax:s,texYmin:r})=>[[e,r],[t,r],[e,s],[t,s]]}},color:{type:t.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:t})=>nt(t)},outlineColor:{type:t.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:t})=>nt(t)},sizing:{type:t.UNSIGNED_BYTE,count:4,pack:({rawWidth:t,rawHeight:e,outlineSize:s,referenceSize:r})=>[at(Math.max(t,e),128),at(s,128),at(r,128),0]},placementAngle:{type:t.UNSIGNED_BYTE,count:1,packTessellation:({placementAngle:t})=>{return e=t*Xe,e%=256,Math.abs(e>=0?e:e+256);var e}},sdfDecodeCoeff:{type:t.UNSIGNED_SHORT,count:1,packPrecisionFactor:64,pack:({sdfDecodeCoeff:t})=>t}}};class Ze extends mt{constructor(){super(...arguments),this.vertexSpec=Ve}getBoundsInfo(){return this.evaluatedMeshParams.boundsInfo}_write(t,e,s){const r=this.evaluatedMeshParams.sprite?.textureBinding,i=e.getDisplayId();t.recordStart(this.instanceId,this.attributeLayout,r);const o=this.evaluatedMeshParams.minPixelBuffer,n=Math.max(this.evaluatedMeshParams.computedWidth,o),a=Math.max(this.evaluatedMeshParams.computedHeight,o),c=-this.evaluatedMeshParams.anchorX*this.evaluatedMeshParams.computedWidth,u=this.evaluatedMeshParams.anchorY*this.evaluatedMeshParams.computedHeight,l=this.evaluatedMeshParams.offsetX+c,h=-this.evaluatedMeshParams.offsetY+u;if(null!=this.evaluatedMeshParams.placement)this._writePlacedMarkers(t,e,s,n,a);else if(s?.nextPath()){s.nextPoint();const e=s.x,r=s.y;t.recordBounds(e+l,r+h,n,a),this._writeQuad(t,i,e,r)}else if("esriGeometryPolygon"===e.geometryType){const s=e.readCentroidForDisplay();if(!s)return;const[r,o]=s.coords;t.recordBounds(r+l,o+h,n,a),this._writeQuad(t,i,r,o)}else if("esriGeometryPoint"===e.geometryType){const s=e.readXForDisplay(),r=e.readYForDisplay();t.recordBounds(s+l,r+h,n,a),this._writeQuad(t,i,s,r)}else{const s=e.readGeometryForDisplay();s?.forEachVertex(((e,s)=>{t.recordBounds(e+l,s+h,n,a),Math.abs(e)>K||Math.abs(s)>K||this._writeQuad(t,i,e,s)}))}t.recordEnd()}_writePlacedMarkers(t,s,r,i,n){const a=r??o.fromFeatureSetReaderCIM(s)?.clone();if(!a)return;const c=we.getPlacement(a,-1,this.evaluatedMeshParams.placement,e(1),t.id,pt());if(!c)return;const u=s.getDisplayId();let l=c.next();const h=this.evaluatedMeshParams.offsetX,p=-this.evaluatedMeshParams.offsetY;for(;null!=l;){const e=l.tx,s=-l.ty;if(Math.abs(e)>K||Math.abs(s)>K){l=c.next();continue}const r=-l.getAngle();t.recordBounds(e+h,s+p,i,n),this._writeQuad(t,u,e,s,r),l=c.next()}}_writeQuad(t,e,s,r,i){const o=t.vertexCount(),n=null==i?null:{placementAngle:i};this._writeVertex(t,e,s,r,n),t.indexWrite(o+0),t.indexWrite(o+1),t.indexWrite(o+2),t.indexWrite(o+1),t.indexWrite(o+3),t.indexWrite(o+2)}}const je={createComputedParams:t=>t,optionalAttributes:{},attributes:{pos:{type:t.SHORT,count:2,packPrecisionFactor:10,pack:"position"},id:{type:t.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:t.UNSIGNED_BYTE,count:1,pack:t=>0},offset:{type:t.SHORT,count:2,packPrecisionFactor:16,packAlternating:{count:4,pack:({size:t})=>{const s=e(t),r=-s/2,i=-s/2;return[[r,i],[r+s,i],[r,i+s],[r+s,i+s]]}}},texCoords:{type:t.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:()=>[[0,1],[1,1],[0,0],[1,0]]}},size:{type:t.UNSIGNED_BYTE,count:2,pack:({size:t})=>[t,t]},referenceSize:{type:t.UNSIGNED_BYTE,count:1,pack:({size:t})=>e(t)},zoomRange:{type:t.UNSIGNED_BYTE,count:2,pack:({scaleInfo:t},{tileInfo:e})=>rt(t,e)}}};class qe extends mt{constructor(){super(...arguments),this.vertexSpec=je}_write(t,s){const r=s.getDisplayId(),i=this.evaluatedMeshParams.minPixelBuffer,o=Math.max(e(this.evaluatedMeshParams.size),i);let n,a;if("esriGeometryPoint"===s.geometryType)n=s.readXForDisplay(),a=s.readYForDisplay();else{const t=s.readCentroidForDisplay();if(!t)return;n=t?.coords[0],a=t?.coords[1]}t.recordStart(this.instanceId,this.attributeLayout),t.recordBounds(n,a,o,o);const c=t.vertexCount();this._writeVertex(t,r,n,a),t.indexWrite(c+0),t.indexWrite(c+1),t.indexWrite(c+2),t.indexWrite(c+1),t.indexWrite(c+3),t.indexWrite(c+2),t.recordEnd()}}export{_e as C,Qt as D,Kt as F,be as H,ce as L,mt as M,pe as O,qe as P,Re as T,rt as a,Ue as b,Ze as c,Pe as d,te as e,ie as f,it as g,lt as h,Ee as m,nt as p};
