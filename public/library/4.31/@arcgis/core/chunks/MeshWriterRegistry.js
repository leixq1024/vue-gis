/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{T as e}from"./GraphShaderModule.js";import{a as t}from"./screenUtils.js";import{y as s}from"./definitions.js";import{M as i,g as r,a as n,T as a,m as o,p as c,H as l,b as h,L as u,P as d,c as m,C as f,d as p,O as _,e as g,f as y,D as x,F as v}from"./PieChartMeshWriter.js";import{M,c as P,g as b,i as w}from"./UpdateTracking2D.js";import{D as S}from"./enums.js";import{r as I}from"./ensureType.js";import{a as k,t as A}from"./mat2d.js";import{c as L}from"./mat2df32.js";import{g as z,k as D,i as E,a as T,e as B}from"./vec2.js";import{f as R}from"./vec2f32.js";import{c as j}from"./vec2f64.js";import{l as F,a as C}from"./featureConversionUtils.js";import{O}from"./OptimizedGeometry.js";import{g as G,a as W}from"./shapingUtils.js";import{L as V,d as N}from"./dataViewUtils.js";import{m as Z}from"./constants.js";import{i as q,clone as Y}from"../core/lang.js";import U from"../core/Error.js";import{L as X}from"./Logger.js";import{a as H,g as Q}from"./grouping.js";import $ from"../Color.js";import{a as J}from"./AttributeStore.js";class K extends i{}function ee(e){const{sprite:t,isMapAligned:s,colorLocked:i,scaleSymbolsProportionally:n,isStroke:a}=e;let o=0;return s&&(o|=r(M.bitset.isMapAligned)),i&&(o|=r(M.bitset.colorLocked)),t.sdf&&(o|=r(M.bitset.isSDF)),n&&(o|=r(M.bitset.scaleSymbolsProportionally)),a&&(o|=r(M.bitset.isStroke)),o}class te extends K{get vertexSpec(){return{createComputedParams:e=>{let{pixelDimensions:s,texelDimensions:i,baseSize:r,referenceSize:n,strokeWidth:a,sizeRatio:o}=e;s||(s=e.sprite.sdf?[0,0]:[e.sprite.width,e.sprite.height]),i||(i=e.sprite.sdf?[0,0]:s),r=t(r),n=t(n),a=t(a);const c=(e.sprite.sdfDecodeCoeff??1)*o;return{...e,pixelDimensions:s,texelDimensions:i,baseSize:r,referenceSize:n,strokeWidth:a,sdfDecodeCoeff:c}},optionalAttributes:{zoomRange:{type:S.SHORT,count:2,packPrecisionFactor:s,pack:({scaleInfo:e},{tileInfo:t})=>n(e,t)}},attributes:{id:{type:S.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:S.UNSIGNED_BYTE,count:1,pack:ee},pos:{type:S.SHORT,count:2,pack:"position",packPrecisionFactor:1},offset:{type:S.FLOAT,count:2,packAlternating:{count:4,pack:e=>{const t=e.texelDimensions;return[[-.5*t[0],-.5*t[1]],[.5*t[0],-.5*t[1]],[-.5*t[0],.5*t[1]],[.5*t[0],.5*t[1]]]}}},uv:{type:S.SHORT,count:2,packPrecisionFactor:1,packAlternating:{count:4,packTessellation:({texXmax:e,texXmin:t,texYmax:s,texYmin:i})=>[[t,i],[e,i],[t,s],[e,s]]}},animationPointerAndBaseSizeAndReferenceSize:{type:S.UNSIGNED_SHORT,count:4,packPrecisionFactor:1,pack:({animations:e,baseSize:t,referenceSize:s})=>[e.dataColumn,e.dataRow,t,s]},sizing:{type:S.UNSIGNED_SHORT,count:4,packPrecisionFactor:8,pack:({strokeWidth:e,pixelDimensions:t,baseSize:s,sprite:i,sizeRatio:r})=>{const n=Math.max(s*i.width/i.height,s),a=i.sdfDecodeCoeff*n*r;return[t[0],t[1],e,a]}},angle:{type:S.BYTE,count:1,packTessellation:({angle:e})=>e}}}}_write(e,t){const s=this.evaluatedMeshParams.sprite,{textureBinding:i}=s;e.recordStart(this.instanceId,this.attributeLayout,i);const r=t.getDisplayId();if("esriGeometryPolygon"===t.geometryType){const s=t.readCentroidForDisplay();if(!s)return;const[i,n]=s.coords;this._writeQuad(e,r,i,n)}else if("esriGeometryPoint"===t.geometryType){const s=t.readXForDisplay(),i=t.readYForDisplay();this._writeQuad(e,r,s,i)}else{const s=t.readGeometryForDisplay();if(s){const{angleToLine:t}=this.evaluatedMeshParams;if(t){let t=!0,i=null,n=null;s.forEachVertex(((s,a)=>{if(null!=i&&null!=n){const o=Math.atan2(a-n,s-i)/P;t&&(this._writeQuad(e,r,i,n,o),t=!1),this._writeQuad(e,r,s,a,o)}i=s,n=a}))}else s.forEachVertex(((t,s)=>{this._writeQuad(e,r,t,s)}))}}e.recordEnd()}_writeQuad(e,t,s,i,r=0){const n=this.evaluatedMeshParams.sprite,{rect:a}=n,o=a.x+2,c=a.y+2,l=a.x+a.width-2,h=a.y+a.height-2,u=e.vertexCount();e.recordBounds(s,i,64,64);const d={texXmin:o,texYmin:c,texXmax:l,texYmax:h,angle:r};for(let r=0;r<4;r++)this._writeVertex(e,t,s,i,d);e.indexEnsureSize(6),e.indexWrite(u),e.indexWrite(u+1),e.indexWrite(u+2),e.indexWrite(u+1),e.indexWrite(u+3),e.indexWrite(u+2)}}function se(e,t,s){return e[0]=t[0]-s[0],e[1]=t[1]-s[1],e}function ie(e,t){return Math.sqrt(e*e+t*t)}function re(e){const t=ie(e[0],e[1]);e[0]/=t,e[1]/=t}function ne(e){return e.length-1}function ae(e,t,s=1){let[i,r]=function(e,t){return e[t+1]}(e,t);return[i,r]=[Math.round(i),Math.round(r)],Math.sqrt(i*i+r*r)*s}class oe{constructor(e,t,s,i,r){this._segments=e,this._index=t,this._distance=s,this._xStart=i,this._yStart=r,this._done=!1}static create(e){return new oe(e,0,0,e[0][0],e[0][1])}clone(){return new oe(this._segments,this._index,this._distance,this.xStart,this.yStart)}equals(e){return this._index===e._index||e._index===this._index-1&&(0===this._distance||1===e._distance)||e._index===this._index+1&&(1===this._distance||0===e._distance)}leq(e){return this._index<e._index||this._index===e._index&&this._distance<=e._distance}geq(e){return this._index>e._index||this._index===e._index&&this._distance>=e._distance}get _segment(){return this._segments[this._index+1]}get angle(){const e=this.dy,t=(0*e+-1*-this.dx)/(1*this.length);let s=Math.acos(t);return e>0&&(s=2*Math.PI-s),s}get xStart(){return this._xStart}get yStart(){return this._yStart}get x(){return this.xStart+this.distance*this.dx}get y(){return this.yStart+this.distance*this.dy}get dx(){return this._segment[0]}get dy(){return this._segment[1]}get xMidpoint(){return this.xStart+.5*this.dx}get yMidpoint(){return this.yStart+.5*this.dy}get xEnd(){return this.xStart+this.dx}get yEnd(){return this.yStart+this.dy}get length(){const{dx:e,dy:t}=this;return Math.sqrt(e*e+t*t)}get remainingLength(){return this.length*(1-this._distance)}get backwardLength(){return this.length*this._distance}get distance(){return this._distance}get done(){return this._done}hasPrev(){return this._index-1>=0}hasNext(){return this._index+1<ne(this._segments)}next(){return this.hasNext()?(this._xStart+=this.dx,this._yStart+=this.dy,this._distance=0,this._index+=1,this):null}prev(){return this.hasPrev()?(this._index-=1,this._xStart-=this.dx,this._yStart-=this.dy,this._distance=1,this):(this._done=!0,null)}_seekBackwards(e,t){const s=this.backwardLength;if(e<=s)return this._distance=(s-e)/this.length,this;let i=this.backwardLength;for(;this.prev();){if(i+this.length>e)return this._seekBackwards(e-i);i+=this.length}return this._distance=0,t?this:null}seek(e,t=!1){if(e<0)return this._seekBackwards(Math.abs(e),t);if(e<=this.remainingLength)return this._distance=(this.backwardLength+e)/this.length,this;let s=this.remainingLength;for(;this.next();){if(s+this.length>e)return this.seek(e-s,t);s+=this.length}return this._distance=1,t?this:null}}function ce(e,t,s,i=!0){const r=function(e){let t=0;for(let s=0;s<ne(e);s++)t+=ae(e,s);return t}(e),n=oe.create(e),a=r/2;if(!i)return n.seek(a),void(Math.abs(n.x)<Z&&Math.abs(n.y)<Z&&s(n.clone(),0,a+0*t,r));const o=Math.max((r-t)/2,0),c=Math.floor(o/t),l=a-c*t;n.seek(l);for(let e=-c;e<=c;e++)Math.abs(n.x)<Z&&Math.abs(n.y)<Z&&s(n.clone(),e,a+e*t,r),n.seek(t)}function le(e,t){const s=t;for(let t=0;t<e.length;t++){let i=e[t];he(i,s);const r=[];r.push(i[0]);for(let e=1;e<i.length;e++){const[t,s]=i[e-1],[n,a]=i[e],o=n-t,c=a-s;r.push([o,c])}e[t]=r,i=r}return e}function he(e,t){const s=1e-6;if(t<=0)return;const i=e.length;if(i<3)return;const r=[];let n=0;r.push(0);for(let t=1;t<i;t++)n+=(a=e[t],o=e[t-1],ie(a[0]-o[0],a[1]-o[1])),r.push(n);var a,o;t=Math.min(t,.2*n);const c=[];c.push(e[0][0]),c.push(e[0][1]);const l=e[i-1][0],h=e[i-1][1],u=se([0,0],e[0],e[1]);re(u),e[0][0]+=t*u[0],e[0][1]+=t*u[1],se(u,e[i-1],e[i-2]),re(u),e[i-1][0]+=t*u[0],e[i-1][1]+=t*u[1];for(let e=1;e<i;e++)r[e]+=t;r[i-1]+=t;const d=.5*t;for(let n=1;n<i-1;n++){let a=0,o=0,l=0;for(let i=n-1;i>=0&&!(r[i+1]<r[n]-d);i--){const c=d+r[i+1]-r[n],h=r[i+1]-r[i],u=r[n]-r[i]<d?1:c/h;if(Math.abs(u)<s)break;const m=u*u,f=u*c-.5*m*h,p=u*h/t,_=e[i+1],g=e[i][0]-_[0],y=e[i][1]-_[1];a+=p/f*(_[0]*u*c+.5*m*(c*g-h*_[0])-m*u*h*g/3),o+=p/f*(_[1]*u*c+.5*m*(c*y-h*_[1])-m*u*h*y/3),l+=p}for(let c=n+1;c<i&&!(r[c-1]>r[n]+d);c++){const i=d-r[c-1]+r[n],h=r[c]-r[c-1],u=r[c]-r[n]<d?1:i/h;if(Math.abs(u)<s)break;const m=u*u,f=u*i-.5*m*h,p=u*h/t,_=e[c-1],g=e[c][0]-_[0],y=e[c][1]-_[1];a+=p/f*(_[0]*u*i+.5*m*(i*g-h*_[0])-m*u*h*g/3),o+=p/f*(_[1]*u*i+.5*m*(i*y-h*_[1])-m*u*h*y/3),l+=p}c.push(a/l),c.push(o/l)}c.push(l),c.push(h);for(let t=0,s=0;t<i;t++)e[t][0]=c[s++],e[t][1]=c[s++]}const ue=I((e=>{let t=0;if(0===e)return 1/0;for(;!(e%2);)t++,e/=2;return t}));class de extends a{constructor(){super(...arguments),this._zoomLevel=0}_write(e,t,s,i){if(this._zoomLevel=i||0,null!=s)throw new Error("InternalError: EffectGeometry not support for LabelMeshWriter");switch(t.geometryType){case"esriGeometryPoint":{const s=t.readXForDisplay(),i=t.readYForDisplay();this._writePoint(e,s,i,t);break}case"esriGeometryEnvelope":case"esriGeometryPolygon":case"esriGeometryMultipoint":{const s=t.readCentroidForDisplay();if(!s)return;const[i,r]=s.coords;this._writePoint(e,i,r,t);break}case"esriGeometryPolyline":this._writeLines(e,t)}}_createLineLabelMetric(e,t,s,i){const r=b(e),n="right"===this.evaluatedMeshParams.horizontalAlignment?-1:1,a="bottom"===this.evaluatedMeshParams.verticalAlignment?-1:1,o=this.evaluatedMeshParams.scaleInfo?.maxScale??0,c=this.evaluatedMeshParams.scaleInfo?.minScale??0;return new V(r,t,s,n,a,o,c,i??null)}_writePoint(e,t,s,i){const r=this._getShaping();if(!r)return;const n=i.getDisplayId(),a=G(this.evaluatedMeshParams.horizontalAlignment),o=W(this.evaluatedMeshParams.verticalAlignment),c=this.evaluatedMeshParams.scaleInfo?.maxScale??0,l=this.evaluatedMeshParams.scaleInfo?.minScale??0,h=b(i.getDisplayId()),u=this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0};e.metricStart(new V(h,t,s,a,o,c,l,u)),this._writeGlyphs(e,n,t,s,r,0,u),e.metricBoxWrite(r.boundsT),e.metricEnd()}_getPointReferenceBounds(){if(!this._references)return null;for(const e of this._references){const t=e.getBoundsInfo();if(t)return t}return null}_writeLines(e,t){const{scaleInfo:s,verticalAlignment:i}=this.evaluatedMeshParams,r=this.evaluatedMeshParams.repeatLabelDistance||128,a=this._getShaping("middle");if(!a)return;const o=(e,t,s,i)=>this._placeSubdivGlyphs(e,t,s,i),c=(a.bounds.width+r)/2;this._current={out:e,id:t.getDisplayId(),shaping:a,zoomRange:n(s,this.getTileInfo()),referenceBounds:this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0},offsetDirection:null},this._verticalPlacement="bottom"===i?"above":"top"===i?"below":null,this._verticalPlacement?this._writeAboveAndBelowAlong(t,o,c):this._writeCenterAlong(t,o,c)}_writeAboveAndBelowAlong(e,t,s){const{repeatLabel:i}=this.evaluatedMeshParams,{shaping:r}=this._current,n=r.bounds.halfHeight,a=e.readGeometryForDisplay();if(!a)return;const o=new O;F(o,a,!1,!1,"esriGeometryPolyline",1);const c=me(new O,o,n),l=me(new O,o,-n),h=C(l,"esriGeometryPolyline",!1,!1),u=le(C(c,"esriGeometryPolyline",!1,!1).paths,r.bounds.width),d=le(h.paths,r.bounds.width);this._current.offsetDirection="above";for(const e of u)ce(e,s,t,!!i);this._current.offsetDirection="below";for(const e of d)ce(e,s,t,!!i)}_writeCenterAlong(e,t,s){const{repeatLabel:i}=this.evaluatedMeshParams,{shaping:r}=this._current,n=le(e.readLegacyGeometryForDisplay().paths,r.bounds.width);for(const e of n)ce(e,s,t,!!i)}_placeSubdivGlyphs(e,t,s,i){const{allowOverrun:r,labelPosition:n,repeatLabelDistance:a}=this.evaluatedMeshParams,c=this._current.zoomRange[0],l=ue(t),h=this._current.shaping.bounds.width/2,u=Math.sqrt(a||128)/2,d=Math.min(s,i-s),m=this._current.shaping.isMultiline?o:Math.log2(d/(u+h/2)),f=0===t?m:Math.min(l,m),p=Math.max(c,this._zoomLevel+1-f),_=this._zoomLevel-p,g=this._current.shaping.bounds.width/2*2**_;this._current.shaping.isMultiline?0===t&&this._placeStraight(e,p):r&&_<0?this._placeStraightAlong(e,c):"parallel"===n?this._placeStraightAlong(e,p):"curved"===n&&this._placeCurved(e,p,g)}_placeStraight(e,t){const{out:s,id:i,shaping:r,referenceBounds:n}=this._current,{x:a,y:o}=e;s.metricStart(this._createLineLabelMetric(i,a,o)),s.metricBoxWrite(r.boundsT);const c=e.angle*(180/Math.PI)%360,l=(e.angle*(180/Math.PI)+180)%360;this._writeGlyphs(s,i,a,o,r,0,n,{clipAngle:c,mapAligned:!0,isLineLabel:!0,minZoom:t}),this._writeGlyphs(s,i,a,o,r,0,n,{clipAngle:l,mapAligned:!0,isLineLabel:!0,minZoom:t}),s.metricEnd()}_placeCurved(e,t,s){const{out:i,id:r}=this._current;i.metricStart(this._createLineLabelMetric(r,e.x,e.y));const n=e.clone(),a=e.angle*(180/Math.PI)%360,o=(e.angle*(180/Math.PI)+180)%360;this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||(this._placeFirst(n,t,1,a),this._placeBack(e,n,t,s,1,a),this._placeForward(e,n,t,s,1,a)),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||(this._placeFirst(n,t,0,o),this._placeBack(e,n,t,s,0,o),this._placeForward(e,n,t,s,0,o)),i.metricEnd()}_placeStraightAlong(e,s){const{out:i,id:r,shaping:n,zoomRange:a,referenceBounds:c}=this._current,{boxBorderLineColor:l,boxBackgroundColor:h}=this.evaluatedMeshParams,u=e.clone(),d=e.angle*(180/Math.PI)%360,m=(e.angle*(180/Math.PI)+180)%360,f=n.glyphs.length>0&&!(!l&&!h);if(i.metricStart(this._createLineLabelMetric(r,e.x,e.y)),f){const l=Math.max(s,a[0],0),h=Math.min(o,a[1]),u=k(L(),-e.angle),f={minZoom:l,maxZoom:h,clipAngle:d,mapAligned:!0,isLineLabel:!0},p=t(this.evaluatedMeshParams.offsetX),_=t(this.evaluatedMeshParams.offsetY);if(!this._verticalPlacement||this._verticalPlacement===this._current.offsetDirection){const t=R(p,-1*_),[s,a]=n.shapeBackground(A(L(),u,t));i.recordStart(this.instanceId,this.attributeLayout,n.glyphs[0].textureBinding);const o=2*Math.max(s.width,s.height);i.recordBounds(e.x+s.x,e.y+s.y,o,o),this._writeTextBox(i,r,e.x,e.y,a,c,f),i.recordEnd()}if(!this._verticalPlacement||this._verticalPlacement!==this._current.offsetDirection){const t=R(p,_),[s,a]=n.shapeBackground(A(L(),u,t));f.clipAngle=m,i.recordStart(this.instanceId,this.attributeLayout,n.glyphs[0].textureBinding);const o=2*Math.max(s.width,s.height);i.recordBounds(e.x+s.x,e.y+s.y,o,o),this._writeTextBox(i,r,e.x,e.y,a,c,f),i.recordEnd()}}this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||this._placeFirst(u,s,1,d,!0),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||this._placeFirst(u,s,0,m,!0),i.metricEnd()}_placeBack(e,t,s,i,r,n){const a=e.clone();let o=e.backwardLength+0;for(;a.prev()&&!(o>=i);)this._placeOnSegment(a,t,o,s,-1,r,n),o+=a.length+0}_placeForward(e,t,s,i,r,n){const a=e.clone();let o=e.remainingLength+0;for(;a.next()&&!(o>=i);)this._placeOnSegment(a,t,o,s,1,r,n),o+=a.length+0}_placeFirst(e,t,s,i,r=!1){const{out:n,id:a,shaping:c,zoomRange:l,referenceBounds:h}=this._current,u=c.glyphs;for(const d of u){const u=d.x>c.bounds.x?s:1-s,m=u*e.remainingLength+(1-u)*e.backwardLength,f=Math.abs(d.x+d.width/2-c.bounds.x),p=Math.max(0,this._zoomLevel+Math.log2(f/(m+0))),_=Math.max(t,r?0:p);d.maxZoom=Math.min(l[1],o),d.angle=e.angle+(1-s)*Math.PI,d.minZoom=Math.max(l[0],_),this._writeLineGlyph(n,a,e.x,e.y,c.bounds,d,i,h,!0),(s||this._current.offsetDirection)&&this._isVisible(d.minZoom,d.maxZoom)&&n.metricBoxWrite(d.bounds)}}_placeOnSegment(e,t,s,i,r,n,a){const{out:o,id:c,shaping:l,referenceBounds:h}=this._current,u=l.glyphs,d=e.dx/e.length,m=e.dy/e.length,f={x:e.x+s*-r*d,y:e.y+s*-r*m};for(const t of u){const u=t.x>l.bounds.x?n:1-n;if(!(u&&1===r||!u&&-1===r))continue;const d=Math.abs(t.x+t.width/2-l.bounds.x),m=Math.max(0,this._zoomLevel+Math.log2(d/s)-.1),p=Math.max(i,this._zoomLevel+Math.log2(d/(s+e.length+0)));0!==m&&(t.angle=e.angle+(1-n)*Math.PI,t.minZoom=p,t.maxZoom=m,this._writeLineGlyph(o,c,f.x,f.y,l.bounds,t,a,h,!0),(n||this._current.offsetDirection)&&this._isVisible(t.minZoom,t.maxZoom)&&o.metricBoxWrite(t.bounds))}}_writeLineGlyph(e,t,s,i,r,n,a,o,l){const h=s+r.x,u=i+r.y,d=2*(this.evaluatedMeshParams.minPixelBuffer?this.evaluatedMeshParams.minPixelBuffer/this._textMeshTransformProps.fontSize:1),m=Math.max(r.width,r.height)*d;e.recordStart(this.instanceId,this.attributeLayout,n.textureBinding),e.recordBounds(h,u,m,m);const{texcoords:f,offsets:p}=n,{fontSize:_,haloSize:g,outlineSize:y}=this._textMeshTransformProps;this._writeQuad(e,t,s,i,{texcoords:f,offsets:p,fontSize:_,haloSize:g,outlineSize:y,color:c(this.evaluatedMeshParams.color),isBackground:!1,referenceBounds:o,minZoom:Math.max(this._current.zoomRange[0],n.minZoom),maxZoom:Math.min(this._current.zoomRange[1],n.maxZoom),clipAngle:a,mapAligned:l,isLineLabel:!0}),e.recordEnd()}_isVisible(e,t){const i=Math.floor(this._zoomLevel*s)/s;return e<=i&&i<=t}}function me(e,t,s){const{coords:i,lengths:r}=t,n=j(),a=j(),o=j(),c=j(),l=j(),h=j();let u=0;for(let t=0;t<r.length;t++){const d=r[t];for(let t=0;t<d;t++){const r=2*(t+u-1),m=2*(t+u),f=2*(t+u+1);t>0?z(n,i[r],i[r+1]):z(n,0,0),z(a,i[m],i[m+1]),t<d-1?z(o,i[f],i[f+1]):z(o,0,0),0===t?z(c,0,0):(D(c,a,n),E(c,c),z(c,c[1],-c[0])),t===d-1?z(l,0,0):(D(l,o,a),E(l,l),z(l,l[1],-l[0])),T(h,c,l),E(h,h);const p=h[0]*l[0]+h[1]*l[1];0!==p&&B(h,h,p),B(h,h,s),e.coords.push(a[0]+h[0],a[1]+h[1])}e.lengths.push(d),u+=d}return e}function fe(e){return e instanceof pe?e:"object"==typeof e&&"type"in e?xe[e.type].hydrate(e):new _e(e)}class pe{constructor(e){this.inputs=e}encode(){const e=[];for(const t of this.inputs)e.push(...t.encode());return e.push(...this.instructions),e}}class _e extends pe{constructor(e){super([]),this.value=e}simplify(){return this}get instructions(){if(Array.isArray(this.value)){const[e,t,s,i]=this.value;return null!=i?w.vector4.encode([e,t||0,s||0,i]):w.vector3.encode([e,t||0,s||0])}return w.scalar.encode(this.value)}}class ge extends pe{constructor(e,t){super([t]),this._config=e,this._parent=t}static hydrate(e){return new ge(e,fe(e.parent))}simplify(){if(this._config.relativeTranslation||this._config.absoluteScale)return this;const e=this._parent.simplify();if(!(e instanceof _e))return this;const[t,s,i,r]=e.value,n=this._config.translation.from[0],a=this._config.translation.from[1],o=this._config.rotation.from,c=this._config.scale.from;if(n===this._config.translation.to[0]&&a===this._config.translation.to[1]&&o===this._config.rotation.to&&c===this._config.scale.to){const e=i+o,l=r*c,h=Math.sin(i),u=Math.cos(i);return new _e([u*r*n-h*r*a+t,h*r*n+u*r*a+s,e,l])}return new ge(this._config,e)}get instructions(){return w.animatedTransform.encode(this._config)}}class ye extends pe{constructor(e,t){super([t]),this._config=e,this._parent=t}static hydrate(e){return new ye(e,fe(e.parent))}simplify(){const e=this._parent.simplify();if(!(e instanceof _e))return this;const[t,s,i,r]=e.value,n=this._config.color.from[0],a=this._config.color.from[1],o=this._config.color.from[2];let c=this._config.color.from[3];const l=this._config.opacity.from;return n===this._config.color.to[0]&&a===this._config.color.to[1]&&o===this._config.color.to[2]&&c===this._config.color.to[3]&&l===this._config.opacity.to?(c*=l,new _e([t*n,s*a,i*o,r*c])):new ye(this._config,e)}get instructions(){return w.animatedColor.encode(this._config)}}const xe={AnimatedTransform:ge,AnimatedColor:ye};function ve(e){const t=[];return t.push(e.transform),t.push(e.fromColor),t.push(e.toColor),t.push(e.colorMix),t.push(e.toOpacity),t.push(e.opacityMix),t}function Me(e){const t=[],s=[];let i=0;for(const r of e){const n=[...r.encode(),...w.ret.encode()];t.push([i+e.length,0,0,0]),s.push(...n),i+=n.length}return[...t,...s]}async function Pe(e,t){const s=e;let i;if("number"==typeof s||"string"==typeof s||"boolean"==typeof s)i=s;else if(Array.isArray(s))i=await Promise.all(s.map((e=>Pe(e,t))));else if("object"==typeof s)if("valueExpressionInfo"in s){const{valueExpressionInfo:e}=s,{expression:r}=e;i={...s,computed:await t.createComputedField({expression:r})}}else{i={};for(const e in s)i[e]=await Pe(s[e],t)}return i}function be(e,t,s){const i=e;let r;if("number"==typeof i||"string"==typeof i||"boolean"==typeof i)r=i;else if(Array.isArray(i))r=i.map((e=>be(e,t,s)));else if("object"==typeof i)if("type"in i&&null!=i.type&&"Process"===i.type)switch(i.op){case"ArcadeColor":{const e=be(i.value,t,s);we(Array.isArray(e)&&4===e.length),r=[e[0]/255,e[1]/255,e[2]/255,e[3]]}break;case"Transparency":{const e=be(i.value,t,s);we("number"==typeof e),r=1-e/100}break;case"Divide":{const e=be(i.left,t,s);we("number"==typeof e);const n=be(i.right,t,s);we("number"==typeof n),r=e/n}break;case"Random":{const e=be(i.seed,t,s),n=be(i.min,t,s),a=be(i.max,t,s),o=t.getObjectId(),c=H(o||0);r=n+Q(c,e)*(a-n)}}else if("computed"in i)r=function(e){if(!("computed"in e))return e;let i=e.computed.readWithDefault(t,s,[255*e.defaultValue[0],255*e.defaultValue[1],255*e.defaultValue[2],e.defaultValue[3]]);if("string"==typeof i){const e=$.fromString(i);e&&(i=[e.r,e.g,e.b,e.a])}return i}(i);else{r={};for(const e in i)r[e]=be(i[e],t,s)}return r}function we(e){if(!e)throw new Error("Assertion failed.")}class Se extends J{constructor(e){super(),this._value=e}resize(e){}read(e,t){return this._value}readWithDefault(e,t,s){return this._value}referencesScale(){return!1}referencesGeometry(){return!1}}async function Ie(e,t,s=!1){const{defaultValue:i,valueExpressionInfo:r,value:n}=t;if(r){const{expression:n}=r,a=await e.createComputedField({expression:n},s);return a?{...t,computed:a,defaultValue:i}:null}return{...t,computed:new Se(n),defaultValue:i}}async function ke(e,t){const{valueExpressionInfo:s}=t,{expression:i}=s,r=await e.createComputedField({expression:i});return r?{...t,computed:r}:null}function Ae(e){return"object"==typeof e&&null!=e&&(!(!("valueExpressionInfo"in e)||!e.valueExpressionInfo)||"type"in e&&"Process"===e.type&&"op"in e&&"Random"===e.op)}function Le(e){if(Array.isArray(e))for(const t of e)if(Le(t))return!0;if("object"==typeof e){if(Ae(e))return!0;for(const t in e)if(Le(e[t]))return!0}return!1}class ze{static async create(e,t,s){const i={},r=new Map,n=new Map,a=new Map,o=new Map,c=new Map,l=new Map;for(const h in s){const u=s[h];if(null!=u&&"object"==typeof u)if(Array.isArray(u)){if("object"==typeof u[0])throw new Error(`InternalError: Cannot handle ${h}. Nested array params are not supported`);i[h]=u}else if("valueExpressionInfo"in u){if(u.value){i[h]=u.value;continue}const t=await ke(e,u);if(!t){i[h]=u.defaultValue;continue}r.set(h,t),i[h]=null}else switch(u.type){case"cim-effect-infos":if(u.effectInfos.some((e=>e.overrides.length))){n.set(h,{effects:await Promise.all(u.effectInfos.map((async t=>{const s=t.overrides.map((t=>Ie(e,t)));return{effect:t.effect,compiledOverrides:(await Promise.all(s)).filter(q)}})))});break}i[h]=u.effectInfos.map((e=>e.effect));break;case"cim-marker-placement-param":u.overrides.length&&a.set(h,{placementInfo:u,compiledOverrides:(await Promise.all(u.overrides.map((t=>Ie(e,t))))).filter(q)}),i[h]=u.placement;break;case"text-rasterization-param":{if(u.overrides.length){const t=u.overrides.map((t=>Ie(e,t,u.useLegacyLabelEvaluationRules)));o.set(h,{compiledOverrides:(await Promise.all(t)).filter(q),rasterizationParam:u,objectIdToResourceId:new Map});continue}const s={type:"cim-rasterization-info",resource:u.resource};i[h]=await t.fetchResourceImmediate(s)??null;break}case"sprite-rasterization-param":{if(u.overrides.length){const t=u.overrides.map((t=>Ie(e,t)));o.set(h,{compiledOverrides:(await Promise.all(t)).filter(q),rasterizationParam:u,objectIdToResourceId:new Map});continue}if("animated"===u.resource.type){o.set(h,{compiledOverrides:[],rasterizationParam:u,objectIdToResourceId:new Map});continue}const s={type:"cim-rasterization-info",resource:u.resource};i[h]=await t.fetchResourceImmediate(s)??null;break}case"cim-marker-transform-param":{const{params:t}=u;if(Le(t)){const s={compiledMarkerInfos:[]};await Promise.all(t.map((async t=>{const i={props:{}};for(const s in t)if(Ae(t[s])){const r=await ke(e,t[s]);i.compiledExpressionMap||(i.compiledExpressionMap=new Map);const n=i.compiledExpressionMap;r&&n.set(s,r)}else i.props[s]=t[s];s.compiledMarkerInfos.push(i)}))),c.set(h,s)}else i[h]={type:"cim-marker-transform-info",infos:t};break}case"animation-params":{const{params:s}=u,r=ve(s);if(Le(r)){const t=await Promise.all(r.map((t=>Pe(t,e))));l.set(h,{params:t,propertyIdToResourceId:new Map,key:h})}else{const e=Me(r.map((e=>be(e))).map((e=>fe(e).simplify()))),s=await t.fetchResourceImmediate({type:"animation-info",resource:e});null!=s&&"sprite"===s.type&&(i[h]={dataRow:s.rect.y,dataColumn:s.rect.x})}break}default:i[h]=u}else i[h]=u}return new ze(s,i,r,n,a,o,c,l)}constructor(e,t,s,i,r,n,a,o){this.inputMeshParams=e,this._resolvedMeshParams=t,this._dynamicProperties=s,this._dynamicEffectProperties=i,this._dynamicPlacementProperties=r,this._dynamicAsyncProperties=n,this._dynamicTransformProperties=a,this._dynamicAsyncAnimations=o,this.evaluator=e=>e}get hasDynamicProperties(){return!!(this._dynamicProperties.size||this._dynamicAsyncProperties.size||this._dynamicEffectProperties.size||this._dynamicTransformProperties.size||this._dynamicPlacementProperties.size||this._dynamicAsyncAnimations.size)}get evaluatedMeshParams(){return this._evaluatedMeshParams||(this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams)),this._evaluatedMeshParams}enqueueRequest(e,t,s){for(const i of this._dynamicAsyncProperties.values()){const r=Y(i.rasterizationParam.resource);"animated"===i.rasterizationParam.resource.type&&i.rasterizationParam.resource.randomizeStartTime&&(r.primitiveName="__RESERVED__PRIMITIVE__NAME__",r.startGroup=H(t.getObjectId()||0));for(const{primitiveName:e,propertyName:n,computed:a,defaultValue:o,valueExpressionInfo:c}of i.compiledOverrides)try{const c="animated"===i.rasterizationParam.resource.type?r.primitiveName:e;N(r,c,n,a,t,s,o)}catch(t){X.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.mesh.MeshWriterInputEvaluator").errorOnce(new U("invalid-arcade-expression",`Encountered an error when evaluating the arcade expression '${c?.expression}' (primitive: '${e}', property: '${n}')`,t))}const n=e.enqueueRequest({type:"cim-rasterization-info",resource:r});i.objectIdToResourceId.set(t.getObjectId(),n)}for(const i of this._dynamicAsyncAnimations.values()){const r=Me(i.params.map((e=>be(e,t,s))).map(fe).map((e=>e.simplify()))),n=e.enqueueRequest({type:"animation-info",resource:r});i.propertyIdToResourceId.set(t.getObjectId()+"."+i.key,n)}}evaluateMeshParams(e,t,s){for(const[e,i]of this._dynamicProperties.entries())this._resolvedMeshParams[e]=i.computed.readWithDefault(t,s,i.defaultValue);for(const[e,i]of this._dynamicPlacementProperties.entries())for(const{computed:r,defaultValue:n,propertyName:a}of i.compiledOverrides){const o=r.readWithDefault(t,s,n);i.placementInfo.placement[a]=o,this._resolvedMeshParams[e]=i.placementInfo.placement}for(const[e,i]of this._dynamicEffectProperties.entries())for(const r of i.effects){for(const{computed:e,defaultValue:i,propertyName:n}of r.compiledOverrides){const a=e.readWithDefault(t,s,i);r.effect[n]=a}this._resolvedMeshParams[e]=i.effects.map((e=>e.effect))}for(const[e,i]of this._dynamicTransformProperties.entries()){const r={type:"cim-marker-transform-info",infos:[]};for(const e of i.compiledMarkerInfos){const i={...e.props};if(e.compiledExpressionMap)for(const[r,n]of e.compiledExpressionMap){const e=n.computed.readWithDefault(t,s,n.defaultValue);i[r]="number"==typeof e||"boolean"==typeof e?e:n.defaultValue}r.infos.push(i)}this._resolvedMeshParams[e]=r}for(const[s,i]of this._dynamicAsyncProperties.entries()){const r=i.objectIdToResourceId.get(t.getObjectId());if(null==r)continue;const n=e.getResource(r);this._resolvedMeshParams[s]=n}for(const[s,i]of this._dynamicAsyncAnimations.entries()){const r=i.propertyIdToResourceId.get(t.getObjectId()+"."+s);if(null==r)continue;const n=e.getResource(r);this._resolvedMeshParams[s]={dataRow:n.rect.y,dataColumn:n.rect.x}}return this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams),this.evaluatedMeshParams}}class De{async createMeshWriter(e,t,s,i){const r=this._getMeshWriter(i.techniqueType),n=await ze.create(e,t,i.inputParams),a=new r(i.id,n,i.optionalAttributes,s);return await a.loadDependencies(),a}_getMeshWriter(t){switch(t){case e.Fill:return v;case e.DotDensity:return x;case e.ComplexFill:return y;case e.PatternFill:return g;case e.OutlineFill:return _;case e.PatternOutlineFill:return p;case e.ComplexOutlineFill:return f;case e.Marker:return m;case e.PieChart:return d;case e.Text:return a;case e.Line:return u;case e.TexturedLine:return h;case e.Heatmap:return l;case e.Label:return de;case e.AnimatedMarker:return te;default:throw new Error("Internal Error: Mesh writer not in the registry")}}}export{Se as D,De as M};
