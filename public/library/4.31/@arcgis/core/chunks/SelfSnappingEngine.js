/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{_ as e}from"./tslib.es6.js";import t from"../core/Accessor.js";import s from"../core/Collection.js";import{property as r}from"../core/accessorSupport/decorators/property.js";import"../core/lang.js";import"./Logger.js";import{subclass as i}from"../core/accessorSupport/decorators/subclass.js";import{a as o,b as n}from"./Cyclical.js";import{v as a,c as p}from"./quantityUtils.js";import{c}from"./vec3f64.js";import{a as l}from"./elevationInfoUtils.js";import{d as h,a as m,m as d,e as g,f}from"./normalizedPoint.js";import{g as j}from"./unitUtils.js";import{u,p as x,s as v,d as y,c as E,b as V,h as w}from"./vec2.js";import{d as S}from"./Settings2.js";import{h as T,j as P,p as L,V as _,s as U}from"./snappingUtils.js";import{v as R,L as C,P as F,a as k,R as M,O as b,b as q}from"./SnappingManager.js";import{r as O,p as D}from"./angularMeasurementUtils.js";import{b as I}from"./geodesicLengthMeasurementUtils.js";import{L as G,p as H,a as N}from"./geometry2dUtils.js";import{c as z}from"./vec2f64.js";import{k as A,a as B,f as Q}from"./vec3.js";import{a as J}from"./RightAngleSnappingHint.js";import"../core/Handles.js";import"./maybe.js";import"./metadata.js";import"./utils.js";import"./handleUtils.js";import"./ObservableBase.js";import"./tracking.js";import"../core/scheduling.js";import"../core/promiseUtils.js";import"../core/Error.js";import"../config.js";import"../core/Evented.js";import"./ensureType.js";import"./shared.js";import"./SimpleObservable.js";import"./mathUtils.js";import"./unitConversionUtils.js";import"./lengthUtils.js";import"./dehydratedPoint.js";import"./jsonMap.js";import"./assets.js";import"../request.js";import"../kernel.js";import"../core/urlUtils.js";import"../core/JSONSupport.js";import"./common.js";import"../Color.js";import"./colorUtils.js";import"./vec4.js";import"./vec4f64.js";import"./geodesicConstants.js";import"../geometry/support/geodesicUtils.js";import"../geometry.js";import"../geometry/Extent.js";import"../geometry/Geometry.js";import"./reader.js";import"../geometry/SpatialReference.js";import"./writer.js";import"../geometry/Point.js";import"../core/accessorSupport/decorators/cast.js";import"../geometry/support/webMercatorUtils.js";import"../geometry/Multipoint.js";import"./zmUtils.js";import"../geometry/Polygon.js";import"./coordsUtils.js";import"./Axis.js";import"./extentUtils.js";import"./boundsUtils.js";import"./aaBoundingRect.js";import"../geometry/Polyline.js";import"./typeUtils.js";import"../geometry/support/jsonUtils.js";import"./plane.js";import"./mat3f64.js";import"./mat4f64.js";import"./quatf64.js";import"./mathUtils2.js";import"./sphere.js";import"./mat4.js";import"./ray.js";import"./mat3.js";import"../core/reactiveUtils.js";import"./asyncUtils.js";import"../core/sql.js";import"./timeUtils.js";import"./date.js";import"./locale.js";import"./datetime.js";import"../rest/support/Query.js";import"./enumeration.js";import"./DataLayerSource.js";import"../layers/support/Field.js";import"./domains.js";import"../layers/support/CodedValueDomain.js";import"../layers/support/Domain.js";import"../layers/support/InheritedDomain.js";import"../layers/support/RangeDomain.js";import"./fieldType.js";import"./FullTextSearch.js";import"../core/Clonable.js";import"./spatialRelationships.js";import"../rest/support/StatisticDefinition.js";import"../time/TimeExtent.js";import"./InputManager.js";import"./Queue.js";import"../core/signal.js";import"./keybindings.js";import"./utils6.js";import"./Version.js";import"./Version2.js";import"../geometry/projection.js";import"./projectBuffer.js";import"../geometry/support/GeographicTransformation.js";import"../geometry/support/GeographicTransformationStep.js";import"./zscale.js";import"../views/interactive/snapping/SnappingOptions.js";import"../views/interactive/snapping/FeatureSnappingLayerSource.js";import"./screenUtils.js";import"./viewUtils.js";import"./projectVectorToVector.js";import"./projectPointToVector.js";import"../geometry/geometryEngine.js";import"./geometryEngineBase.js";import"./_commonjsHelpers.js";import"./hydrated.js";import"./geodesicMeasurementUtils.js";class K{constructor(e,t){this.view=e,this.options=t,this.squaredShortLineThreshold=S.shortLineThreshold*S.shortLineThreshold}snap(e,t){return null!=t.vertexHandle?"vertex"!==t.vertexHandle.type?[]:this.snapExistingVertex(e,t):this.snapNewVertex(e,t)}edgeExceedsShortLineThreshold(e,t){return this.exceedsShortLineThreshold(h(e.leftVertex.pos,this.view,t),h(e.rightVertex.pos,this.view,t),t)}exceedsShortLineThreshold(e,t,{spatialReference:s}){return 0===this.squaredShortLineThreshold||T(R(t,s,l,this.view),R(e,s,l,this.view))>this.squaredShortLineThreshold}isVertical(e,t,{spatialReference:s}){const r=j(s);return u(m(e),m(t))*r<S.verticalLineThresholdMeters}squaredProximityThreshold(e){return"touch"===e?this._squaredTouchProximityThreshold:this._squaredMouseProximityThreshold}get _squaredMouseProximityThreshold(){return this.options.distance*this.options.distance}get _squaredTouchProximityThreshold(){const{distance:e,touchSensitivityMultiplier:t}=this.options,s=e*t;return s*s}}class W extends K{snapNewVertex(e,t){const s=t.editGeometryOperations.data.components[0],r=s.edges.length,i=[];if(r<1)return i;const{spatialReference:o}=t,n=R(e,o,l,this.view),{view:a}=this,p=s.edges[r-1];let c=p;do{if(this.edgeExceedsShortLineThreshold(c,t)){const s=P(c,a,t);this._processCandidateProposal(s.left,s.right,e,n,t,i)}c=c.leftVertex.leftEdge}while(c&&c!==p);return i}snapExistingVertex(e,t){const s=[],r=t.vertexHandle,i=r.component;if(i.edges.length<2)return s;const{view:o}=this,{spatialReference:n}=t,a=R(e,n,l,o),p=r.leftEdge,c=r.rightEdge;p&&c&&this.edgeExceedsShortLineThreshold(p,t)&&this.edgeExceedsShortLineThreshold(c,t)&&this._processCandidateProposal(h(p.leftVertex.pos,o,t),h(c.rightVertex.pos,o,t),e,a,t,s);const m=i.edges[0];let d=m;do{if(d!==r.leftEdge&&d!==r.rightEdge&&this.edgeExceedsShortLineThreshold(d,t)){const r=P(d,o,t);this._processCandidateProposal(r.left,r.right,e,a,t,s)}d=d.rightVertex.rightEdge}while(d&&d!==m);return s}_processCandidateProposal(e,t,s,r,i,h){const{spatialReference:m,pointer:f}=i,j=c();!function(e,t,s,r,i){(function(e,t,s,r,{spatialReference:i}){const c=O(t,s,i,i);if(null==c)return!1;const l=O(s,r,i,i);if(null==l)return!1;const h=I(s,r,i);if(null==h)return!1;const m=Math.abs(o.shortestSignedDiff(c,l))>Math.PI/2?n.normalize(c+Math.PI):c;return D(e,s,i,a(h,"meters"),p(m,"radians","geographic"),"geodesic"),e[2]=r[2],!0})(e,t,s,r,i)||function(e,t,s,r){L(t,{start:s,end:r,type:G.LINE},e),e[2]=t[2]}(e,r,t,s)}(j,e,t,s,i);const u=d(g(j));T(r,R(u,m,l,this.view))<this.squaredProximityThreshold(f)&&h.push(new C({lineStart:e,lineEnd:t,targetPoint:u,isDraped:"on-the-ground"===i.elevationInfo?.mode}))}}class X extends K{snapNewVertex(e,t){const s=t.editGeometryOperations.data.components[0],r=s.edges.length,i=s.vertices.length,o=[];if(r<2)return o;const{view:n}=this,a=R(e,t.spatialReference,l,n),p=h(s.vertices[i-1].pos,n,t),c=h(s.vertices[0].pos,n,t),m=s.edges[r-1];let d=m;do{if(this.edgeExceedsShortLineThreshold(d,t)){const s=P(d,n,t);this._checkEdgeForParallelLines(s,p,e,a,t,o),this._checkEdgeForParallelLines(s,c,e,a,t,o)}d=d.leftVertex.leftEdge}while(d&&d!==m);return o}snapExistingVertex(e,t){const s=[],r=t.vertexHandle,i=r.component;if(i.edges.length<3)return s;const{view:o}=this,n=R(e,t.spatialReference,l,o),a=r.leftEdge,p=r.rightEdge,c=i.vertices[0],m=h(c.pos,o,t),d=i.vertices.length,g=i.vertices[d-1],f=h(g.pos,o,t),j=i.edges[0];let u=j;do{if(u!==a&&u!==p&&this.edgeExceedsShortLineThreshold(u,t)){const i=P(u,o,t);a&&this._checkEdgeForParallelLines(i,h(a.leftVertex.pos,o,t),e,n,t,s),p&&this._checkEdgeForParallelLines(i,h(p.rightVertex.pos,o,t),e,n,t,s),r===c?this._checkEdgeForParallelLines(i,f,e,n,t,s):r===g&&this._checkEdgeForParallelLines(i,m,e,n,t,s)}u=u.rightVertex.rightEdge}while(u&&u!==j);return s}_checkEdgeForParallelLines(e,t,s,r,i,o){const n=e.left,a=e.right;if(H(Y,m(t),m(n),m(a)),x(Y,m(t))<S.parallelLineThreshold)return;H(Y,m(s),m(n),m(a),m(t));const{spatialReference:p,pointer:c}=i,h=d(f(Y[0],Y[1],s[2]));if(T(r,R(h,p,l,this.view))<this.squaredProximityThreshold(c)){if(this.isVertical(h,t,i)||this.isVertical(n,a,i))return;if(function(e,t){const s=e.left,r=e.right;for(const i of t)if(H(Y,m(r),m(i.constraint.start),m(i.constraint.end),m(s)),x(Y,m(r))<S.parallelLineThreshold)return i.addReferenceLine(e),!0;return!1}(e,o))return;o.push(new F({referenceLine:e,lineStart:t,targetPoint:h,isDraped:"on-the-ground"===i.elevationInfo?.mode}))}}}const Y=z();class Z extends K{snapNewVertex(e,t){const s=t.editGeometryOperations.data.components[0],r=[];if(s.vertices.length<2)return r;const{view:i}=this,o=R(e,t.spatialReference,l,i),n=s.vertices.at(-1);this._checkForSnappingCandidate(k.LastVertex,r,n.leftEdge,n,n.leftEdge.leftVertex,e,o,t);const a=s.vertices[0];return this._checkForSnappingCandidate(k.FirstVertex,r,a.rightEdge,a,a.rightEdge.rightVertex,e,o,t),r}snapExistingVertex(e,t){const s=[],r=t.vertexHandle;if(r.component.vertices.length<3)return s;const{view:i}=this,o=R(e,t.spatialReference,l,i),n=r.leftEdge,a=r.rightEdge;if(n?.leftVertex.leftEdge){const r=n.leftVertex.leftEdge;this._checkForSnappingCandidate(k.ExistingEdge,s,r,r.rightVertex,r.leftVertex,e,o,t)}if(a?.rightVertex.rightEdge){const r=a.rightVertex.rightEdge;this._checkForSnappingCandidate(k.ExistingEdge,s,r,r.leftVertex,r.rightVertex,e,o,t)}return s}_checkForSnappingCandidate(e,t,s,r,i,o,l,d){if(!this.edgeExceedsShortLineThreshold(s,d))return;const g=this.view,f=h(r.pos,g,d),j=h(i.pos,g,d);!function(e,t,s,r,i){(function(e,t,s,r,{spatialReference:i}){const o=O(t,s,i,i);if(null==o)return!1;const l=O(s,r,i,i);if(null==l)return!1;const h=Math.sign(n.shortestSignedDiff(o,l))*Math.PI*.5,m=p(o+h,"radians","geographic"),d=c(),g=I(s,r,i);return null!=g&&(D(d,s,i,a(g,"meters"),m,"geodesic"),B(e,d,s),!0)})(e,t,s,r,i)||function(e,t,s){const r=v($,m(s),m(t));Q(e,r[1],-r[0],0)}(e,t,s)}(ee,j,f,o,d),this._checkForSnappingCandidateAlongProjectedRay(e,t,j,f,ee,o,l,d)}_checkForSnappingCandidateAlongProjectedRay(e,t,s,r,i,o,n,a){const{spatialReference:p,pointer:h}=a,j=v($,m(o),m(r)),u=y(i,j)/E(i),x=V($,m(r),i,u),w=d(f(x[0],x[1],o[2]));if(T(n,R(w,p,l,this.view))>this.squaredProximityThreshold(h)||this.isVertical(w,r,a)||this.isVertical(r,s,a))return;const S=A(c(),r,i,Math.sign(u));t.push(new M({targetPoint:w,constraint:new _(r,g(S)),previousVertex:s,otherVertex:r,otherVertexType:b.CENTER,selfSnappingType:e,isDraped:"on-the-ground"===a.elevationInfo?.mode}))}}const $=z(),ee=c();class te extends K{snapNewVertex(e,t){const s=t.editGeometryOperations.data.components[0],r=[],i=s.vertices.length;if("polygon"!==t.editGeometryOperations.data.type||i<2)return r;const{view:o}=this,n=s.vertices[0],a=s.vertices[i-1],p=h(n.pos,o,t),c=h(a.pos,o,t);return this._processCandidateProposal(p,c,e,t,r),r}snapExistingVertex(e,t){const s=[],r=t.vertexHandle,i=r.component;if(i.edges.length<2)return s;if("polyline"===t.editGeometryOperations.data.type&&(0===r.index||r.index===i.vertices.length-1))return s;const{view:o}=this,n=h(r.leftEdge.leftVertex.pos,o,t),a=h(r.rightEdge.rightVertex.pos,o,t);return this._processCandidateProposal(n,a,e,t,s),s}_processCandidateProposal(e,t,s,r,i){if(!this.exceedsShortLineThreshold(e,t,r))return;const o=w(se,m(e),m(t),.5),n=.5*u(m(e),m(t)),a=N(se,m(s),o,n),p=d(f(a[0],a[1],s[2])),{spatialReference:c,pointer:h}=r,g=R(s,c,l,this.view);if(T(g,R(p,c,l,this.view))<this.squaredProximityThreshold(h)){if(this.isVertical(e,p,r)||this.isVertical(p,t,r))return;i.push(new q({targetPoint:p,point1:e,point2:t,isDraped:"on-the-ground"===r.elevationInfo?.mode}))}}}const se=z();let re=class extends t{constructor(e){super(e),this.updating=!1,this._snappers=new s,this._domain=J.SELF}initialize(){this._snappers.push(new X(this.view,this.options),new W(this.view,this.options),new Z(this.view,this.options),new te(this.view,this.options))}set options(e){this._set("options",e);for(const t of this._snappers)t.options=e}async fetchCandidates(e,t,s){if(!(t&this._domain&&this.options.effectiveSelfEnabled))return[];const r=[];for(const t of this._snappers.items)for(const i of t.snap(e,s))r.push(i);return U(e,r),r}};e([r({readOnly:!0})],re.prototype,"updating",void 0),e([r({constructOnly:!0})],re.prototype,"view",void 0),e([r()],re.prototype,"options",null),re=e([i("esri.views.interactive.snapping.SelfSnappingEngine")],re);export{re as SelfSnappingEngine};
