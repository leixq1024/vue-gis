/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import e from"../request.js";import{r as t}from"./asyncUtils.js";import{v as r}from"../core/lang.js";import s from"../core/Error.js";import{L as a}from"./Logger.js";import{N as n}from"./NestedMap.js";import{throwIfAbortError as o}from"../core/promiseUtils.js";import{V as i}from"./Version2.js";import{e as u}from"./vec3f64.js";import{k as l,e as c}from"./aaBoundingBox.js";import{a as p}from"./Indices.js";import{r as m}from"./requestImageUtils.js";import{A as f}from"./Attribute.js";import{C as d,A as y}from"./basicInterfaces.js";import{T as g,G as x}from"./StencilUtils.js";import{V as h}from"./VertexAttribute.js";import{D as w}from"./DefaultMaterial.js";import{T as v}from"./enums.js";const b=()=>a.getLogger("esri.views.3d.layers.graphics.objectResourceUtils");async function A(s,a){const n=await async function(r,s){const a=s?.streamDataRequester;if(a)return async function(e,r,s){const a=await t(r.request(e,"json",s));return!0===a.ok?a.value:(o(a.error),void j(a.error.details.url))}(r,a,s);const n=await t(e(r,s));return!0===n.ok?n.value.data:(o(n.error),void j(n.error))}(s,a),i=await async function(e,t){const r=new Array;for(const s in e){const a=e[s],n=a.images[0].data;if(!n){b().warn("Externally referenced texture data is not yet supported");continue}const o=a.encoding+";base64,"+n,i="/textureDefinitions/"+s,u="rgba"===a.channels?a.alphaChannelUsage||"transparency":"none",l={noUnpackFlip:!0,wrap:{s:v.REPEAT,t:v.REPEAT},preMultiplyAlpha:U(u)!==y.Opaque},c=t?.disableTextures?Promise.resolve(null):m(o,t);r.push(c.then((e=>({refId:i,image:e,parameters:l,alphaChannelUsage:u}))))}const s=await Promise.all(r),a={};for(const e of s)a[e.refId]=e;return a}(n.textureDefinitions??{},a);let u=0;for(const e in i)if(i.hasOwnProperty(e)){const t=i[e];u+=t?.image?t.image.width*t.image.height*4:0}return{resource:n,textures:i,size:u+r(n)}}function j(e){throw new s("",`Request for object resource failed: ${e}`)}function I(e){const t=e.params,r=t.topology;let s=!0;switch(t.vertexAttributes||(b().warn("Geometry must specify vertex attributes"),s=!1),t.topology){case"PerAttributeArray":break;case"Indexed":case null:case void 0:{const e=t.faces;if(e){if(t.vertexAttributes)for(const r in t.vertexAttributes){const t=e[r];t?.values?(null!=t.valueType&&"UInt32"!==t.valueType&&(b().warn(`Unsupported indexed geometry indices type '${t.valueType}', only UInt32 is currently supported`),s=!1),null!=t.valuesPerElement&&1!==t.valuesPerElement&&(b().warn(`Unsupported indexed geometry values per element '${t.valuesPerElement}', only 1 is currently supported`),s=!1)):(b().warn(`Indexed geometry does not specify face indices for '${r}' attribute`),s=!1)}}else b().warn("Indexed geometries must specify faces"),s=!1;break}default:b().warn(`Unsupported topology '${r}'`),s=!1}e.params.material||(b().warn("Geometry requires material"),s=!1);const a=e.params.vertexAttributes;for(const e in a)a[e].values||(b().warn("Geometries with externally defined attributes are not yet supported"),s=!1);return s}function P(e,t){const r=new Array,s=new Array,a=new Array,o=new n,l=e.resource,c=i.parse(l.version||"1.0","wosr");E.validate(c);const m=l.model.name,y=l.model.geometries,v=l.materialDefinitions??{},b=e.textures;let A=0;const j=new Map;for(let e=0;e<y.length;e++){const n=y[e];if(!I(n))continue;const i=M(n),l=n.params.vertexAttributes,c=[],m=e=>{if("PerAttributeArray"===n.params.topology)return null;const t=n.params.faces;for(const r in t)if(r===e)return t[r].values;return null},P=l[h.POSITION],T=P.values.length/P.valuesPerElement;for(const e in l){const t=l[e],r=t.values,s=m(e)??p(T);c.push([e,new f(r,s,t.valuesPerElement,!0)])}const E=i.texture,O=b&&b[E];if(O&&!j.has(E)){const{image:e,parameters:t}=O,r=new g(e,t);s.push(r),j.set(E,r)}const k=j.get(E),q=k?k.id:void 0,C=i.material;let R=o.get(C,E);if(null==R){const e=v[C.slice(C.lastIndexOf("/")+1)].params;1===e.transparency&&(e.transparency=0);const r=O&&O.alphaChannelUsage,s=e.transparency>0||"transparency"===r||"maskAndTransparency"===r,a=O?U(O.alphaChannelUsage):void 0,n={ambient:u(e.diffuse),diffuse:u(e.diffuse),opacity:1-(e.transparency||0),transparent:s,textureAlphaMode:a,textureAlphaCutoff:.33,textureId:q,initTextureTransparent:!0,doubleSided:!0,cullFace:d.None,colorMixMode:e.externalColorMixMode||"tint",textureAlphaPremultiplied:O?.parameters.preMultiplyAlpha??!1};t?.materialParameters&&Object.assign(n,t.materialParameters),R=new w(n,t),o.set(C,E,R)}a.push(R);const B=new x(R,c);A+=c.find((e=>e[0]===h.POSITION))?.[1]?.indices.length??0,r.push(B)}return{engineResources:[{name:m,stageResources:{textures:s,materials:a,geometries:r},pivotOffset:l.model.pivotOffset,numberOfVertices:A,lodThreshold:null}],referenceBoundingBox:T(r)}}function T(e){const t=l();return e.forEach((e=>{const r=e.boundingInfo;null!=r&&(c(t,r.bbMin),c(t,r.bbMax))})),t}function U(e){switch(e){case"mask":return y.Mask;case"maskAndTransparency":return y.MaskBlend;case"none":return y.Opaque;default:return y.Blend}}function M(e){const t=e.params;return{id:1,material:t.material,texture:t.texture,region:t.texture}}const E=new i(1,2,"wosr");export{A as l,P as p};
