/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{t as e,a as t,G as s,u as i,e as n,g as a,P as _,K as r,r as o,B as h,T as m,E as p,x as l,o as u,D as c,s as g,F as d,H as E,I as f}from"./Transformation2D.js";import{a as P,O as S,H as y,w as A,p as x,h as R,at as M,aT as C,M as T,al as w,aU as q,aV as N,aw as b,a3 as I,N as j,aA as v,aW as z,aX as D,a1 as O,a2 as G,ae as k,aY as L,ao as U,aj as $,L as F,as as J}from"./converterAPI.js";import{O as Y}from"./OperatorShapePreservingLength.js";import{a as X,b as B}from"./tslib.es6.js";import{a as H}from"./GeodeticDistanceCalculator-CJvEB3vc.js";import"../geometry.js";import"./ensureType.js";import"../core/lang.js";import"./Logger.js";import"../config.js";import"../geometry/Extent.js";import"../core/accessorSupport/decorators/property.js";import"./utils.js";import"./handleUtils.js";import"./metadata.js";import"../core/Error.js";import"../core/accessorSupport/decorators/subclass.js";import"./tracking.js";import"../geometry/Geometry.js";import"../core/JSONSupport.js";import"../core/Accessor.js";import"../core/Handles.js";import"./maybe.js";import"./ObservableBase.js";import"../core/scheduling.js";import"../core/promiseUtils.js";import"./reader.js";import"../geometry/SpatialReference.js";import"./unitUtils.js";import"./jsonMap.js";import"./assets.js";import"../request.js";import"../kernel.js";import"../core/urlUtils.js";import"./writer.js";import"../geometry/Point.js";import"../core/accessorSupport/decorators/cast.js";import"../geometry/support/webMercatorUtils.js";import"../geometry/Multipoint.js";import"./zmUtils.js";import"../geometry/Polygon.js";import"./coordsUtils.js";import"./Axis.js";import"./extentUtils.js";import"./boundsUtils.js";import"./aaBoundingRect.js";import"./mathUtils.js";import"../geometry/Polyline.js";import"./typeUtils.js";import"../geometry/support/jsonUtils.js";import"./Distance2DCalculator-BX0Ep7eP.js";import"./OperatorShapePreservingDensify.js";import"./OperatorGeodeticDensifyByLength.js";class Q{constructor(e,t,s,i,n=100){this.m_startPt=e.clone(),this.m_endPt=t.clone(),this.m_cE2=i,this.m_cE=Math.sqrt(this.m_cE2),this.m_c1By2e=1/(2*this.m_cE),this.m_cRpu=s.getGCS().getUnit().getUnitToBaseFactor(),this.isPcs=2===s.getCoordinateSystemType(),this.PEProjcs=s.getPECoordSys(),this.m_points=new Array(2*n)}setSegmentEndPoints(e,t){this.m_startPt.assign(e),this.m_endPt.assign(t)}makeFunctor(){return e=>{const t=[0,0];t[0]=this.m_startPt.x*(1-e)+this.m_endPt.x*e,t[1]=this.m_startPt.y*(1-e)+this.m_endPt.y*e,this.isPcs&&b.projToGeogCenter(this.PEProjcs,1,t,0);const s=Math.sin(t[1]*this.m_cRpu);return 0===this.m_cE2?s:-Math.log((1-this.m_cE*s)/(1+this.m_cE*s))*this.m_c1By2e+s/(1-this.m_cE2*s*s)}}makeArrayFunctor(){return a(0),{}}}function V(e,t,s,i,n){const a=(new S).execute(e,t,0,0,n);let _;_=i?(new T).execute(a,i,n):a;const r=1===s.getUnit().getUnitToBaseFactor()?Math.PI/180:1,o=new x;_.queryEnvelope(o);const h=new x,m=new x,p=new x;h.setCoords({xmin:o.xmin,ymin:75*r,xmax:o.xmax,ymax:90*r}),m.setCoords({xmin:o.xmin,ymin:-60*r,xmax:o.xmax,ymax:75*r}),p.setCoords({xmin:o.xmin,ymin:-90*r,xmax:o.xmax,ymax:-60*r}),h.inflateCoords(.01*h.width(),0),m.inflateCoords(.01*m.width(),0),p.inflateCoords(.01*p.width(),0);let l=0;return l+=Z(_,h,s,n),l+=Z(_,m,s,n),l+=Z(_,p,s,n),l}function Z(e,t,s,r){const m=(new M).execute(e,t,s,r);if(null!==m&&!m.isEmpty()){const e=new x;m.queryEnvelope(e);const{first:t,second:p}=function(e,t){const s=function(e,t){const s=e.getUnit().getUnitToBaseFactor(),i=t.getCenter();i.scale(180*s/Math.PI);const r=new _;r.x=0,r.y=0;let m=0;if(0===m){i.y>45?(r.y=o,m=0):i.y<-45?(r.y=-o,m=1):i.x>=45&&i.x<135?(r.x=o,m=2):i.x>=135||i.x<-135?(r.x=o,m=3):i.x<-45&&i.x>=-135?(r.x=-o,m=4):(r.x=0,m=5);const e=s*Math.sqrt(h(t.xmin-t.xmax)+h(t.ymin-t.ymax)),n=r.clone(),a=t.getCenter();if(a.scale(s),m<2&&(n.x=a.x),_.distance(n,a)+.5*e>o)return null}const p=W[m];if(null!==p&&p.getGCS().equalHorizontal(e))return p;const l=e.getText(),u=r.x,c=r.y;let g=0,d=-1;6!==m?d=w.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA:(a(!1),g=0,d=w.PE_PRJ_CYLINDRICAL_EQAREA);const E=q("EqualAreaPCS");let f;d===w.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA?f=`PROJCS["${E}",${l},PROJECTION["Lambert_Azimuthal_Equal_Area"],PARAMETER["False_Easting",0],PARAMETER["False_Northing",0],PARAMETER["Central_Meridian",${u}],PARAMETER["Latitude_of_Origin",${c}],UNIT["Meter",1.0]]`:d===w.PE_PRJ_CYLINDRICAL_EQAREA?f=`PROJCS["${E}",${l},PROJECTION["Cylindrical_Equal_Area"],PARAMETER["False_Easting",0],PARAMETER["False_Northing",0],PARAMETER["Central_Meridian",${u}],PARAMETER["Standard_Parallel_1",${g}],PARAMETER["Latitude_of_Origin",${c}],UNIT["Meter",1.0]]`:n("getEqualAreaPcsFixed");const P=N(f);return W[m]&&W[m].destroy(),W[m]=P,P}(e,t);if(null!==s)return i(s,!1);const r=e.getText(),m=e.getUnit().getUnitToBaseFactor(),p=(t.xmin+t.width()/2)*m,l=(t.ymin+t.height()/2)*m;let u=0,c=0,g=-1;t.ymin*m>=75*Math.PI/180||t.ymax*m<=-60*Math.PI/180?g=w.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA:t.ymin>0||t.ymax<0?(u=(t.ymin+1/3*t.height())*m,c=(t.ymin+2/3*t.height())*m,g=w.PE_PRJ_ALBERS):(u=(t.ymin+2/3*t.height())*m,g=w.PE_PRJ_CYLINDRICAL_EQAREA);const d=q("EqualAreaPCS");let E;return g===w.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA?E=`PROJCS["${d}",${r},PROJECTION["Lambert_Azimuthal_Equal_Area"],PARAMETER["False_Easting",0],PARAMETER["False_Northing",0],PARAMETER["Central_Meridian",${p}],PARAMETER["Latitude_of_Origin",${l}],UNIT["Meter",1.0]]`:g===w.PE_PRJ_ALBERS?E=`PROJCS["${d}",${r},PROJECTION["Albers"],PARAMETER["False_Easting",0],PARAMETER["False_Northing",0],PARAMETER["Central_Meridian",${p}],PARAMETER["Standard_Parallel_1",${u}],PARAMETER["Standard_Parallel_2",${c}],PARAMETER["Latitude_of_Origin",${l}],UNIT["Meter",1.0]]`:g===w.PE_PRJ_CYLINDRICAL_EQAREA?E=`PROJCS["${d}",${r},PROJECTION["Cylindrical_Equal_Area"],PARAMETER["False_Easting",0],PARAMETER["False_Northing",0],PARAMETER["Central_Meridian",${p}],PARAMETER["Standard_Parallel_1",${u}],PARAMETER["Latitude_of_Origin",${l}],UNIT["Meter",1.0]]`:n("getEqualAreaPCSInstance"),i(N(E),!0)}(s,e),l=y(s,t,null),u=(new T).execute(m,l,r).calculateArea2D();return p&&t.destroy(),u}return 0}const W=[null,null,null,null,null,null,null];class K{getOperatorType(){return 10314}supportsCurves(){return!0}accelerateGeometry(e,t,s){return!1}canAccelerateGeometry(e){return!1}execute(n,a,o){if(0===a.getCoordinateSystemType()&&e(""),n.isEmpty()||n.getDimension()<2)return 0;if(t(n),n.getGeometryType()===s.enumEnvelope){const e=new P;return e.addEnvelope(n,!1),this.execute(e,a,o)}let h=n;n.getDescription().getAttributeCount()>1&&(h=n.clone(),h.dropAllAttributes());const m=(new S).execute(h,0,a.getTolerance(0),0,o);let p=null;const l=a.getGCS();l!==a&&(p=y(a,l));let u=(new A).execute(m,a,!1,o);return u.isEmpty()?0:(u===n&&(u=n.clone()),a.isPannable()?function(e,t,s){const i=new x;e.queryEnvelope(i);const n=R(t,i,!0).total(),a=t.getPannableExtent();a.xmin=i.xmin-10*n,a.xmax=i.xmax+10*n;const o=(new M).execute(e,a,t,s).getImpl().querySegmentIterator();o.stripAttributes();const h=I();t.querySpheroidData(h);const m=h.e2,p=0===m?2:1,l=new _(0,0),u=new _(0,0),c=new r(0),g=new Q(l,u,t,m,100);for(;o.nextPath();)for(;o.hasNextSegment();){const e=o.nextSegment();l.assign(e.getStartXY()),u.assign(e.getEndXY()),g.setSegmentEndPoints(l,u);const t=C(6,0,1,1e-12,1e-15,g.makeFunctor());c.pe((u.x-l.x)*t)}const d=h.majorSemiAxis;return p*d*d*(1-m)*Math.PI*c.getResult()/t.getPannableExtent().width()}(u,a,o):function(e,t,s,n,a){const _=function(e,t,s){const n=e.calculateLength2D(),a=(new Y).execute(e,t,s)/25e3,_=n/e.getSegmentCount()*2;let r=Math.min(_,n/a);return 0===r&&(r=1),i(r,n/r)}(e,t,a);let r=V(e,_.first,s,n,a),o=1,h=0,m=0;do{if(o++,_.first*=.5,_.first<50*t.getTolerance(0))return r;_.second*=2,m=V(e,_.first,s,n,a),h=Math.abs(m-r),r=m}while(Math.abs(r)>1&&h>1e-8*Math.abs(r)&&(_.second<65e3&&o<8||o<4));return m}(u,a,l,p,o))}}function ee(){return{m_p_PCS:new _,m_factor:Number.NaN,setValues:te,assign:se}}function te(e,t){this.m_factor=e,this.m_p_PCS.assign(t)}function se(e){this.m_factor=e.m_factor,this.m_p_PCS.assign(e.m_p_PCS)}class ie{constructor(e,t,s,i){this.m_ptStart=new U,this.m_ptEnd=new U,this.m_ptStart.assign(t),this.m_ptEnd.assign(s),this.m_deltaX=this.m_ptEnd.x-this.m_ptStart.x,this.m_deltaY=this.m_ptEnd.y-this.m_ptStart.y,this.m_e=Math.sqrt(e),this.m_e2=e,this.m_c1MinusE2=1-e;const n=Math.sin(i);let a;a=0===this.m_e2?2*n:n*(E(this.m_e*n)+1/(1-this.m_e2*n*n)),this.m_baseA=a}setSegmentEndPoints(e,t){this.m_ptStart.assign(e),this.m_ptEnd.assign(t),this.m_deltaX=this.m_ptEnd.x-this.m_ptStart.x,this.m_deltaY=this.m_ptEnd.y-this.m_ptStart.y}makeFunctor(){return e=>{const t=1-e,s=t*this.m_ptStart.x+e*this.m_ptEnd.x,i=t*this.m_ptStart.y+e*this.m_ptEnd.y,n=t*this.m_ptStart.z+e*this.m_ptEnd.z,a=s*s+i*i,_=n/Math.sqrt(n*n+this.m_c1MinusE2*this.m_c1MinusE2*a);let r;return r=0===this.m_e2?2*_:_*(E(this.m_e*_)+1/(1-this.m_e2*_*_)),(this.m_deltaY*s-this.m_deltaX*i)/a*(r-this.m_baseA)}}}function ne(){return{sin_phi:Number.NaN,one_p_sin_phi:Number.NaN,one_m_sin_phi:Number.NaN,one_m_e_2_sin_2_phi:Number.NaN,sin_half_phi_pf:Number.NaN,sin_half_phi_pz:Number.NaN,sin_half_asin_e_sin_phi_pf:Number.NaN,sin_half_asin_e_sin_phi_pz:Number.NaN,atanh_sin_phi:Number.NaN,atanh_esin_phi:Number.NaN,make_negative:!1,initialize:ae,changeSign:_e,assign:re,clone:oe}}function ae(e,t,s,i){const n=.5*e;this.sin_phi=Math.sin(e);const a=t*this.sin_phi,_=.5*Math.asin(a);this.one_p_sin_phi=1+this.sin_phi,this.one_m_sin_phi=1-this.sin_phi,this.one_m_e_2_sin_2_phi=(1+a)*(1-a),this.sin_half_phi_pf=Math.sin(n+s),this.sin_half_phi_pz=Math.sin(n+i),this.sin_half_asin_e_sin_phi_pf=Math.sin(_+s),this.sin_half_asin_e_sin_phi_pz=Math.sin(_+i),this.atanh_sin_phi=Math.log(this.sin_half_phi_pf/this.sin_half_phi_pz),this.atanh_esin_phi=Math.log(this.sin_half_asin_e_sin_phi_pf/this.sin_half_asin_e_sin_phi_pz)}function _e(){this.sin_phi=-this.sin_phi;let e=this.one_p_sin_phi;this.one_p_sin_phi=this.one_m_sin_phi,this.one_m_sin_phi=e,e=this.sin_half_phi_pf,this.sin_half_phi_pf=this.sin_half_phi_pz,this.sin_half_phi_pz=e,e=this.sin_half_asin_e_sin_phi_pf,this.sin_half_asin_e_sin_phi_pf=this.sin_half_asin_e_sin_phi_pz,this.sin_half_asin_e_sin_phi_pz=e,this.atanh_sin_phi=-this.atanh_sin_phi,this.atanh_esin_phi=-this.atanh_esin_phi}function re(e){this.sin_phi=e.sin_phi,this.one_p_sin_phi=e.one_p_sin_phi,this.one_m_sin_phi=e.one_m_sin_phi,this.one_m_e_2_sin_2_phi=e.one_m_e_2_sin_2_phi,this.sin_half_phi_pf=e.sin_half_phi_pf,this.sin_half_phi_pz=e.sin_half_phi_pz,this.sin_half_asin_e_sin_phi_pf=e.sin_half_asin_e_sin_phi_pf,this.sin_half_asin_e_sin_phi_pz=e.sin_half_asin_e_sin_phi_pz,this.atanh_sin_phi=e.atanh_sin_phi,this.atanh_esin_phi=e.atanh_esin_phi,this.make_negative=e.make_negative}function oe(){return{...this}}class he{constructor(t,s,i){this.m_transformPCS2GCS=null,this.m_scaleToRadians=new m,this.m_scaleToDegrees=new m,this.m_progressTracker=i,a(4!==s),this.m_curveType=s,this.m_inputSR=t,t&&0!==t.getCoordinateSystemType()||e(""),this.m_inputGCS=t.getGCS(),this.m_a=0,this.m_eSquared=0,this.m_b=0,this.m_rpu=0}executePolygonGeodeticArea(e){let t,s=e.clone();if(s.dropAllAttributes(),e.hasNonLinearSegments()&&(s=(new S).execute(s,0,this.m_inputSR.getTolerance(0),0,this.m_progressTracker)),this.m_inputSR.isPannable()){const e=new x;s.queryEnvelope(e);const t=this.m_inputSR.getPannableExtent();if(!t.containsEnvelope(e)){const i=t.getCenterX()-e.getCenterX(),n=new m;n.setShiftCoords(i,0),s.applyTransformation(n),e.move(i,0);const a=new p;t.queryIntervalX(a);const _=new p;e.queryIntervalX(_),s=a.contains(_)?j(s,this.m_inputSR):(new T).foldInto360RangeGeodetic(s,this.m_inputSR,this.m_curveType)}}if(this.m_transformPCS2GCS?(s=(new A).execute(s,this.m_inputSR,!1,this.m_progressTracker),t=s.createInstance(),v(this.m_transformPCS2GCS,s,t,this.m_progressTracker)||(t=(new T).execute(s,this.m_transformPCS2GCS,this.m_progressTracker))):t=(new A).execute(s,this.m_inputGCS,!1,this.m_progressTracker),t.isEmpty())return 0;if(1===this.m_curveType){const e=I();return this.m_inputGCS.querySpheroidData(e),this.m_a=e.majorSemiAxis,this.m_eSquared=e.e2,this.loxodromeArea(t)}const i=t.getImpl();this.m_rpu=this.m_inputGCS.getUnit().getUnitToBaseFactor(),this.m_scaleToRadians.setScale(this.m_rpu),i.applyTransformation(this.m_scaleToRadians),this.m_scaleToDegrees=this.m_scaleToRadians,this.m_scaleToDegrees.invertThis();const n=I();if(this.m_inputGCS.querySpheroidData(n),this.m_a=n.majorSemiAxis,this.m_b=n.minorSemiAxis,this.m_eSquared=n.e2,2===this.m_curveType)return this.executeClippedPolygonGreatEllipticArea(t);{const e={stack:[],error:void 0,hasError:!1};try{const s=z.unit(9101),i=this.m_inputGCS.getPECoordSys(),n=X(e,i.cloneAlterUnits(s),!1);let a,_,r=this.executeClippedPolygonGeodeticArea(t,n,0),o=0;do{o++,a=this.executeClippedPolygonGeodeticArea(t,n,o),_=Math.abs(a-r),r=a}while(Math.abs(a)>1&&_>1e-8*Math.abs(a)&&o<7);return a}catch(t){e.error=t,e.hasError=!0}finally{B(e)}}}executeClippedPolygonGeodeticArea(e,t,s){const i={stack:[],error:void 0,hasError:!1};try{const n=new x;e.queryEnvelope(n);const a=X(i,this.getEqualAreaPCSInstance(t,n),!1),o=e.clone();D(a,o);const h=50,m=o.getImpl().getAttributeStreamRef(0),p=e.getImpl().getAttributeStreamRef(0),g=X(i,new O,!1),d=X(i,new O,!1),E=40,f=[0,0],P=l(ee,E),S=u(E,-1),y=ee(),A=ee();let R,M;const C=a;let T=o.calculateArea2D();const w=new r(0),q=.5*Math.PI,N=1e-10*Math.abs(T)+1e-6,I=e.getPathCount();let j,v,z,k;const L=new _,U=new _,$=new _,F=new _,J=new _,Y=new _;let B,H;for(v=e.getPathStart(0),j=0;j<I;j++,v=z)for(z=e.getPathEnd(j),m.queryPoint2D(z-1<<1,$),p.queryPoint2D(z-1<<1,L),Math.abs(L.y)>q&&(L.y=c(q,L.y)),k=v;k<z;k++,$.assign(F),L.assign(U)){if(m.queryPoint2D(k<<1,F),p.queryPoint2D(k<<1,U),Math.abs(U.y)>q&&(U.y=c(q,U.y)),B=_.distance($,F),B<h||0===L.y&&0===U.y)continue;G.geodeticDistance(this.m_a,this.m_eSquared,L.x,L.y,U.x,U.y,g,d,null,this.m_curveType);const e=g.val,t=d.val;for(y.setValues(0,$),A.setValues(1,F),M=s,P[0].assign(A),S[0]=s,R=0;R>=0;){H=.5*(y.m_factor+A.m_factor),G.geodeticCoordinate(this.m_a,this.m_eSquared,L.x,L.y,e*H,t,g,d,this.m_curveType),J.x=g.val,J.y=d.val,f[0]=J.x,f[1]=J.y,b.geogToProj(C,1,f),Y.x=f[0],Y.y=f[1];const s=.5*-Y.offset(y.m_p_PCS,A.m_p_PCS)*_.distance(y.m_p_PCS,A.m_p_PCS);if(w.pe(s),Math.abs(s)>N||Math.abs(s)>0&&M>0)A.setValues(H,Y),R++,P[R].assign(A),Math.abs(s)<=N?(M--,S[R-1]=M,S[R]=M):(M=S[R-1],S[R]=M);else{if(R<=0)break;y.assign(A),R--,A.assign(P[R]),M=S[R]}}}return T+=w.getResult(),Math.abs(T)}catch(e){i.error=e,i.hasError=!0}finally{B(i)}}executeClippedPolygonGreatEllipticArea(e){const t=[],s=[],i=new _,n=new _,a=k(1,this.m_eSquared,new _(0,.5*Math.PI)),h=new r(0),m=new r(0),p=new r(0),l=new U,u=new U,d=new x;e.queryLooseEnvelope(d);let E=0;d.containsCoords(d.xmin,0)||(E=Math.abs(d.ymin)<Math.abs(d.ymax)?d.ymin:d.ymax);const f=new ie(this.m_eSquared,l,u,E),P=this.m_a*this.m_a,S=e.getImpl().querySegmentIterator();for(S.stripAttributes();S.nextPath();)for(;S.hasNextSegment();){const e=S.nextSegment();i.assign(e.getStartXY()),n.assign(e.getEndXY()),n.x-i.x>Math.PI?i.x+=2*Math.PI:n.x-i.x<-Math.PI&&(n.x+=2*Math.PI),this.splitSegmentCrossingItegralThreshold(e,t,s);for(let e of t)l.assign(k(this.m_a,this.m_eSquared,e.getStartXY())),u.assign(k(this.m_a,this.m_eSquared,e.getEndXY())),f.setSegmentEndPoints(l,u),this.adaptiveIntegrationWithRomberg(f,h);for(let e of s){let t=e.getStartXY(),s=e.getEndXY(),i=E;t.y<0&&(s=g(t,t=s),t.y=-t.y,s.y=-s.y,i=-i);const n=k(1,this.m_eSquared,t),_=k(1,this.m_eSquared,s),r=Math.min(t.y,s.y),h=L(this.m_eSquared,t.x,s.x,i,r);m.pe(h);const l=Math.abs(L(this.m_eSquared,t.x,s.x,r,o)),u=new U;u.setSub(n,a);const d=new U;d.setSub(_,a);const f=new U;f.setCrossProductVector(u,d);let S=P*(l-.5*f.length());S=c(S,s.x-t.x),p.pe(S)}t.length=0,s.length=0}return p.getResult()+P*(.5*(1-this.m_eSquared)*h.getResult()+m.getResult())}getEqualAreaPCSInstance(e,t){const s=t.getCenterX();let i,n;const a=t.height();let _,r;(_=t.ymin>45*Math.PI/180||t.ymax<45*-Math.PI/180)?i=c(.5*Math.PI,t.getCenterY()):(i=t.getCenterY(),n=t.ymin+a*(2/3));const o=q("EqualAreaPCS"),h=e.toString();return r=_?z.fromString(w.PE_TYPE_PROJCS,`PROJCS["${o}", ${h}, PROJECTION["Lambert_Azimuthal_Equal_Area"],PARAMETER["False_Easting",0],PARAMETER["False_Northing", 0],PARAMETER["Central_Meridian", ${s}], PARAMETER["Latitude_of_Origin", ${i}], UNIT["Meter",1.0]]`):z.fromString(w.PE_TYPE_PROJCS,`PROJCS["${o}", ${h}, PROJECTION["Cylindrical_Equal_Area"],PARAMETER["False_Easting", 0],PARAMETER["False_Northing", 0],PARAMETER["Central_Meridian", ${s}],PARAMETER["Standard_Parallel_1", ${n}],PARAMETER["Latitude_of_Origin", ${i}],UNIT["Meter",1.0]]`),r}splitSegmentCrossingItegralThreshold(e,t,s){const i=100,n=400,a=k(this.m_a,this.m_eSquared,new _(0,o)),r=k(this.m_a,this.m_eSquared,new _(0,-o)),h=this.splitSegmentPassingThroughPole(e);for(let e of h){const o=e.getStartXY(),h=e.getEndXY(),m=k(this.m_a,this.m_eSquared,o),p=k(this.m_a,this.m_eSquared,h),l=new _,u=new U;let c=U.sqrDistance(a,m),g=U.sqrDistance(m,p);if(c<=i){if(!(g>n)){s.push(new F({start:o,end:h}));continue}u.assign(p.sub(m)),u.normalizeThis(),u.assign(m.add(u.mul(20))),l.assign($(this.m_a,this.m_eSquared,u)),s.push(new F({start:o,end:l})),o.assign(l)}if(m.assign(k(this.m_a,this.m_eSquared,o)),c=U.sqrDistance(a,p),g=U.sqrDistance(m,p),c<=i){if(!(g>n)){s.push(new F({start:o,end:h}));continue}u.assign(p.sub(m)),u.normalizeThis(),u.assign(p.sub(u.mul(20))),l.assign($(this.m_a,this.m_eSquared,u)),s.push(new F({start:l,end:h})),h.assign(l)}if(m.assign(k(this.m_a,this.m_eSquared,o)),p.assign(k(this.m_a,this.m_eSquared,h)),c=U.sqrDistance(r,m),g=U.sqrDistance(m,p),c<=i){if(!(g>n)){s.push(new F({start:o,end:h}));continue}u.assign(p.sub(m)),u.normalizeThis(),u.assign(m.add(u.mul(20))),l.assign($(this.m_a,this.m_eSquared,u)),s.push(new F({start:o,end:l})),o.assign(l)}if(m.assign(k(this.m_a,this.m_eSquared,o)),p.assign(k(this.m_a,this.m_eSquared,h)),c=U.sqrDistance(r,p),g=U.sqrDistance(m,p),c<=i){if(!(g>n)){s.push(new F({start:o,end:h}));continue}u.assign(p.sub(m)),u.normalizeThis(),u.assign(p.sub(u.mul(20))),l.assign($(this.m_a,this.m_eSquared,u)),s.push(new F({start:l,end:h})),h.assign(l)}t.push(new F({start:o,end:h}))}}splitSegmentPassingThroughPole(e){const t={stack:[],error:void 0,hasError:!1};try{const s=[],i=new U,n=new U,a=new U,r=new _,o=20,h=3.124139361,m=10,p=e.getStartXY(),l=e.getEndXY(),u=X(t,new O,!1);if(G.geodeticDistance(this.m_a,this.m_eSquared,p.x,p.y,l.x,l.y,u,null,null,2),Math.abs(l.x-p.x)>h&&u.val>o){const e=new H(new _(0,90),p.divide(this.m_rpu),l.divide(this.m_rpu),this.m_inputGCS,2,2);let t=J(e.makeFunctor(),0,1,1e-10);if(t.second<=m&&t.first>0&&t.first<1)return i.assign(k(this.m_a,this.m_eSquared,p)),n.assign(k(this.m_a,this.m_eSquared,l)),d(i,n,t.first,a),r.assign($(this.m_a,this.m_eSquared,a)),s.push(new F({start:p,end:r})),s.push(new F({start:r,end:l})),s;if(e.setPointDistFrom(new _(0,-90)),t=J(e.makeFunctor(),0,1,1e-10),t.second<=m&&t.first>0&&t.first<1)return i.assign(k(this.m_a,this.m_eSquared,p)),n.assign(k(this.m_a,this.m_eSquared,l)),d(i,n,t.first,a),r.assign($(this.m_a,this.m_eSquared,a)),s.push(new F({start:p,end:r})),s.push(new F({start:r,end:l})),s}return s.push(new F({start:p,end:l})),s}catch(e){t.error=e,t.hasError=!0}finally{B(t)}}adaptiveIntegrationWithRomberg(e,t){const s=e.makeFunctor();let i=0,n=1,a=s(i),_=s(n);const r=1e-17,o=1e-14;let h=(i+n)/2,m=s(h),p=Math.abs(m-a),l=Math.abs(_-m),u=0;for(;u++<32&&(p/l<.1||l/p<.1);)p<l?(t.pe(C(5,i,h,o,r,s)),i=h,a=m):(t.pe(C(5,h,n,o,r,s)),n=h,_=m),h=(i+n)/2,m=Math.abs(s(h)),p=Math.abs(m-a),l=Math.abs(_-m);t.pe(C(5,i,n,o,r,s))}loxodromeAreaHemi(e,t,s,i,n){const a=s.clone(),_=n.clone();let r,o,h,m,p,l,u,c,g,d,P,S,y,A,x,R;return a.make_negative&&a.changeSign(),_.make_negative&&_.changeSign(),P=i-t,1===Math.abs(a.sin_phi)||1===Math.abs(_.sin_phi)?e.half_qp*P:a.sin_phi===_.sin_phi?(d=.5*e.one_m_e_2*a.sin_phi*(1/a.one_m_e_2_sin_2_phi+E(e.e*a.sin_phi))*P,d):(x=Math.log(_.sin_half_phi_pf*a.sin_half_phi_pz/(_.sin_half_phi_pz*a.sin_half_phi_pf)),R=Math.log(_.sin_half_asin_e_sin_phi_pf*a.sin_half_asin_e_sin_phi_pz/(_.sin_half_asin_e_sin_phi_pz*a.sin_half_asin_e_sin_phi_pf)),1===this.m_eSquared?(p=0,r=.5*(x+_.sin_phi/_.one_m_e_2_sin_2_phi-a.sin_phi/a.one_m_e_2_sin_2_phi),o=0):(p=-2*e.atanh_e_over_e*(Math.log(_.one_p_sin_phi/a.one_p_sin_phi)-e.e*R),r=(x-e.e*R)/e.one_m_e_2,o=(Math.log(_.one_m_e_2_sin_2_phi/a.one_m_e_2_sin_2_phi)+p/e.atanh_e_over_e)/e.one_m_e_2),h=-R*(a.atanh_esin_phi+_.atanh_esin_phi),m=1/a.one_m_e_2_sin_2_phi-1/_.one_m_e_2_sin_2_phi,l=f(_.one_m_sin_phi/e.one_p_e,e.e)-f(a.one_m_sin_phi/e.one_p_e,e.e),u=f(_.one_p_sin_phi/e.one_p_e,e.e)-f(a.one_p_sin_phi/e.one_p_e,e.e),c=f(a.one_m_sin_phi/-e.one_m_e,e.e)-f(_.one_m_sin_phi/-e.one_m_e,e.e),g=f(a.one_p_sin_phi/-e.one_m_e,e.e)-f(_.one_p_sin_phi/-e.one_m_e,e.e),d=.25/r*(o+h+m+p+.5*(l+u+c+g)),d+=e.half_qp,S=.5*e.one_m_e_2*a.sin_phi*(1/a.one_m_e_2_sin_2_phi+E(e.e*a.sin_phi)),y=.5*e.one_m_e_2*_.sin_phi*(1/_.one_m_e_2_sin_2_phi+E(e.e*_.sin_phi)),y<S&&(A=S,S=y,y=A),d<S&&(d=S),d>y&&(d=y),d*=P,d)}loxodromeArea(e){const t=Math.PI/180;let s=0;const i={e:Number.NaN,one_p_e:Number.NaN,one_m_e:Number.NaN,one_m_e_2:Number.NaN,atanh_e_over_e:Number.NaN,half_qp:Number.NaN,f:Number.NaN,z:Number.NaN},n=ne(),a=ne();i.e=Math.sqrt(this.m_eSquared),i.one_p_e=1+i.e,i.one_m_e=1-i.e,i.one_m_e_2=1-this.m_eSquared,i.atanh_e_over_e=E(i.e),this.m_eSquared>=1?i.half_qp=1:i.half_qp=.5*(1+i.atanh_e_over_e*i.one_m_e_2),i.f=.25*Math.PI,i.z=.75*Math.PI,a.initialize(0,i.e,i.f,i.z);const r=e.getPathCount(),o=new _,h=new _,m=e.getImpl().getAttributeStreamRef(0);for(let _=0;_<r;_++){const r=e.getPathStart(_),p=e.getPathEnd(_);if(!(p-r<=1)){m.queryPoint2D(2*(p-1),o);for(let e=r;e<p;e++){m.queryPoint2D(2*e,h);const _=o.y*t,p=h.y*t;if(e===r?(n.initialize(_,i.e,i.f,i.z),n.make_negative=!1):n.assign(a),a.initialize(p,i.e,i.f,i.z),a.make_negative=!1,o.y*h.y<0){if(o.y>=90&&h.y<=-90||h.y>=90&&o.y<=-90)return Number.NaN;const e=ne();e.initialize(0,i.e,i.f,i.z),e.make_negative=!1;const r=n.atanh_sin_phi-i.e*n.atanh_esin_phi,m=a.atanh_sin_phi-i.e*a.atanh_esin_phi,p=(m*o.x-r*h.x)/(m-r);_<0?(n.make_negative=!0,s-=this.loxodromeAreaHemi(i,o.x*t,n,p*t,e),n.make_negative=!1,s+=this.loxodromeAreaHemi(i,p*t,e,h.x*t,a)):(s+=this.loxodromeAreaHemi(i,o.x*t,n,p*t,e),a.make_negative=!0,s-=this.loxodromeAreaHemi(i,p*t,e,h.x*t,a),a.make_negative=!1)}else o.y>=0?s+=this.loxodromeAreaHemi(i,o.x*t,n,h.x*t,a):(n.make_negative=!0,a.make_negative=!0,s-=this.loxodromeAreaHemi(i,o.x*t,n,h.x*t,a),n.make_negative=!1,a.make_negative=!1);o.assign(h)}}}return this.m_a*s*this.m_a}calculate(e){if(e.isEmpty()||e.getDimension()<2)return 0;if(e.getGeometryType()===s.enumEnvelope){const t=new P;return t.addEnvelope(e,!1),this.calculate(t)}return this.m_inputSR!==this.m_inputGCS&&null===this.m_transformPCS2GCS&&(this.m_transformPCS2GCS=y(this.m_inputSR,this.m_inputGCS,null)),this.executePolygonGeodeticArea(e)}}class me{getOperatorType(){return 10311}supportsCurves(){return!0}accelerateGeometry(e,t,s){return!1}canAccelerateGeometry(e){return!1}execute(e,s,i,n){return t(e),4===i?(new K).execute(e,s,n):new he(s,i,n).calculate(e)}}export{me as OperatorGeodeticArea};
