/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{t}from"./common.js";import{e,m as s,g as o,d as i,r}from"./mat3.js";import{c as a}from"./mat3f32.js";import{f as n}from"./vec2f32.js";import{f as p}from"./vec3f32.js";import{normalizeMapX as d}from"../geometry/support/normalizeUtils.js";import{l}from"./unitUtils.js";import{g as c}from"./viewpointUtils.js";import{W as h}from"./featureTechniqueUtils.js";import{W as f}from"./WGLContainer.js";import{d as u}from"./maybe.js";import{T as m,s as v,M as y}from"./Technique.js";import{l as x,u as g,V as w,U as _,G as M,F as S,d as j,a as b,b as A,c as O,t as R,i as T,e as E,M as P,S as U,f as z,T as D}from"./GraphShaderModule.js";import{_ as G,c as W}from"./tslib.es6.js";import{f as I,g as q,D as C,k as L}from"./enums.js";class B extends w{}G([x(0,A)],B.prototype,"pos",void 0),G([x(1,A)],B.prototype,"uv",void 0);class F extends _{}G([g(P)],F.prototype,"dvs",void 0);class N extends _{}G([g(A)],N.prototype,"perspective",void 0),G([g(A)],N.prototype,"texSize",void 0),G([g(S)],N.prototype,"wrapAroundShift",void 0),G([g(S)],N.prototype,"opacity",void 0),G([g(U)],N.prototype,"texture",void 0);class k extends M{vertex(t){const e=t.uv.divide(this.config.texSize),s=new S(1).add(j(e,this.config.perspective)),o=new b(t.pos.add(new A(this.config.wrapAroundShift,0)),1),i=this.transform.dvs.multiply(o);return{uv:e,glPosition:new O(i.xy.multiply(s),0,s)}}fragment(t){const e=R(this.config.texture,t.uv).multiply(this.config.opacity),s=new E;return s.glFragColor=e,s}}G([g(F)],k.prototype,"transform",void 0),G([g(N)],k.prototype,"config",void 0),G([W(0,T(B))],k.prototype,"vertex",null),G([W(0,T(class extends z{}))],k.prototype,"fragment",null);class K extends m{constructor(){super(...arguments),this.type=D.Overlay,this._mesh=null,this.shaders={overlay:new k}}render(t,e){const{context:s,painter:o}=t,i=this._getMesh(t,e);o.setPipelineState(v);const{isWrapAround:r,wrapAroundShift:a}=e.config,n={...e.config,wrapAroundShift:0},p={shader:this.shaders.overlay,uniforms:{transform:e.transform,config:n},defines:null,optionalAttributes:null,useComputeBuffer:!1};o.setPipelineState({...v,stencil:{write:!1,test:{compare:I.EQUAL,op:{fail:q.KEEP,zFail:q.KEEP,zPass:q.REPLACE},ref:0,mask:255}}}),o.submitDrawMeshUntyped(s,p,i),r&&(n.wrapAroundShift=a,o.submitDrawMeshUntyped(s,p,i))}shutdown(){u(this._mesh)}_getMesh(t,e){const{context:s}=t;if(this._mesh){const t=this._mesh.vertexBuffers.get("positions");if(!t)throw new Error("Buffer not found");t.setData(e.position)}else{const t=null!=e.index?e.index.length:e.position.length/2;this._mesh=new y(s,{vertex:{positions:e.position,uvs:e.tex},index:null!=e.index?{index:e.index}:void 0,groups:[{attributes:[{name:"pos",count:2,type:C.FLOAT,location:0,vertex:"positions",stride:8,offset:0},{name:"tex",count:2,type:C.UNSIGNED_SHORT,location:1,vertex:"uvs",stride:4,offset:0}],index:null!=e.index?"index":void 0,primitive:L.TRIANGLE_STRIP}],parts:[{group:0,start:0,count:t}]})}return this._mesh}}class H extends f{constructor(){super(...arguments),this._viewStateId=-1,this._dvsMat3=a(),this._overlayTechnique=new K}get dvsMat3(){return this._dvsMat3}beforeRender(t){this._updateMatrices(t),this._updateOverlays(t,this.children);for(const e of this.children)e.beforeRender(t)}doRender(t){if(t.drawPhase!==h.MAP||!this.visible)return;super.doRender(t);const e=this._overlayTechnique;for(const s of this.children)s.draw(t,e)}onDetach(){this._overlayTechnique.shutdown()}_updateMatrices(a){const{state:l}=a,{id:c,size:h,pixelRatio:f,resolution:u,rotation:m,viewpoint:v,displayMat3:y}=l;if(this._viewStateId===c)return;const x=t(m),g=f*h[0],w=f*h[1];this._localOrigin=v.targetGeometry.clone();const{x:_,y:M}=this._localOrigin,S=d(_,l.spatialReference);this._localOrigin.x=S,this._localOrigin.y=M;const j=u*g,b=u*w,A=e(this._dvsMat3);s(A,A,y),o(A,A,n(g/2,w/2)),i(A,A,p(g/j,-w/b,1)),r(A,A,-x),this._viewStateId=c}_updateOverlays(e,s){const{state:o}=e,{rotation:i,spatialReference:r,worldScreenWidth:a,size:n,viewpoint:p}=o,d=this._localOrigin;let h,f=0;const u=l(r);if(u&&r.isWrappable){const e=n[0],s=n[1],d=t(i),l=Math.abs(Math.cos(d)),m=Math.abs(Math.sin(d)),v=Math.round(e*l+s*m),[y,x]=u.valid,g=c(r),{x:w,y:_}=p.targetGeometry,M=[w,_],S=[0,0];o.toScreen(S,M);const j=[0,0];let b;b=v>a?.5*a:.5*v;const A=Math.floor((w+.5*g)/g),O=y+A*g,R=x+A*g,T=[S[0]+b,0];o.toMap(j,T),j[0]>R&&(f=g),T[0]=S[0]-b,o.toMap(j,T),j[0]<O&&(f=-g),h={worldWidth:g,xBounds:[y,x]}}for(const t of s)t.updateDrawCoords(d,f,r,h)}}export{H as O};
