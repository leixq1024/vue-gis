/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{F as t,S as e,G as s,p as n,a as i,O as r,H as o,I as m,b as a,J as h,h as c,P as u,K as l,M as _,N as f,Q as d,y as g,R as p,U as P,V as x,W as y,X as b,w,Y as C,Z as S,_ as v,E as D,$ as I,a0 as G,a1 as M,a2 as T,a3 as N,a4 as k,a5 as A,a6 as q,a7 as E,a8 as j,a9 as R,aa as z,ab as X,ac as B}from"./converterAPI.js";import{e as Y,d as U,t as O,a as F,k as W,G as J,l as H,c as L,b as V,i as Q,n as K,o as Z,p as $,T as tt,P as et,S as st,q as nt,r as it}from"./Transformation2D.js";import{a as rt,b as ot}from"./tslib.es6.js";import{c as mt}from"./GeometryCleaner-k94LXQsr.js";import"../geometry.js";import"./ensureType.js";import"../core/lang.js";import"./Logger.js";import"../config.js";import"../geometry/Extent.js";import"../core/accessorSupport/decorators/property.js";import"./utils.js";import"./handleUtils.js";import"./metadata.js";import"../core/Error.js";import"../core/accessorSupport/decorators/subclass.js";import"./tracking.js";import"../geometry/Geometry.js";import"../core/JSONSupport.js";import"../core/Accessor.js";import"../core/Handles.js";import"./maybe.js";import"./ObservableBase.js";import"../core/scheduling.js";import"../core/promiseUtils.js";import"./reader.js";import"../geometry/SpatialReference.js";import"./unitUtils.js";import"./jsonMap.js";import"./assets.js";import"../request.js";import"../kernel.js";import"../core/urlUtils.js";import"./writer.js";import"../geometry/Point.js";import"../core/accessorSupport/decorators/cast.js";import"../geometry/support/webMercatorUtils.js";import"../geometry/Multipoint.js";import"./zmUtils.js";import"../geometry/Polygon.js";import"./coordsUtils.js";import"./Axis.js";import"./extentUtils.js";import"./boundsUtils.js";import"./aaBoundingRect.js";import"./mathUtils.js";import"../geometry/Polyline.js";import"./typeUtils.js";import"../geometry/support/jsonUtils.js";class at{constructor(t){this.m_sr=null,this.m_gcs=null,this.m_transform=null,this.m_a=0,this.m_eSquared=0,this.m_rpu=0,this.m_radTolerance=0,this.m_q90=0,this.m_gcs90=0,this.m_gcs180=0,this.m_gcs360=0,this.m_gcs60=0,this.m_ellipticToGeodesicMaxRatio=0,this.m_curveType=0,this.m_bShapePreserving=!1,this.m_distance=0,this.m_absDistance=0,this.m_convergenceOffset=0,this.m_cornerStep=0,this.m_segmentStep=0,this.m_progressTracker=t}bufferPolygon(t){const e=new i,s=new yt(this,t,e);return this.processGnomonicBufferPiecesCursor(!0,s)}bufferPolyline(t){const e=new yt(this,t,null);return this.processGnomonicBufferPiecesCursor(!0,e)}bufferMultiPoint(t){const e=new bt(this,t);return this.processGnomonicBufferPiecesCursor(!1,e)}bufferPoint(t){const e=t.getXY();e.scale(this.m_rpu);let s=new i;if(this.bufferPoint2D(e,!1,s)){const t=g(null,s,!0);s=p(s,t,!0,!0,-1,this.m_progressTracker,0,!1)}return s=(new _).foldInto360RangeGeodetic(s,this.m_gcs,2),s}processGnomonicBufferPiecesCursor(e,s){const i=s;let r=i.getGnomonic();const o=P(x()),m=new B;o.queryPrecisionDescriptor(m),m.setTolerance(0,.001),P(x(),void 0,m);let a=new y,c=(new t).executeMany(a,o,this.m_progressTracker,2);const u=Z(6,!1),l=$(n,6);this.initializeGrid(u,l);const f=[null,null,null,null,null,null],d=[null,null,null,null,null,null],C=[null,null,null,null,null,null];let S,v,D;for(;null!==(S=i.next());){if(v=i.getGnomonic(),v!==r){if(null!==r){let t=c.next();if(a=null,c=null,null!=t){const s=g(o,t,!0),n=h(s);t=r.unproject(t,n,this.m_progressTracker),this.putInGridCursors(e,t,o,!0,u,l,f,d,C)}}null!==v&&(a=new y,c=(new t).executeMany(a,o,this.m_progressTracker,2)),r=v}if(i.isRunningInGnomonic()){if(v.project(S),i.needsSimplify()){const t=g(null,S,!0);S=p(S,t,!0,!0,-1,this.m_progressTracker,0,!1)}a.tick(Pt(S)),c.tock()}else this.putInGridCursors(e,S,o,!0,u,l,f,d,C)}let I=!1;for(let t=0;t<6;t++)if(null!=C[t]){I=!0;break}if(I){let s=!1;const n=[null,null,null,null,null,null];if(e){const t=i.m_densified;if(i.m_densified=null,null!==t){const i=new tt;i.scale(1/this.m_rpu,1/this.m_rpu),t.applyTransformation(i),this.m_distance>0?this.putInGridCursors(e,t,o,!1,u,l,f,d,C):(this.processInGrid(e,t,!1,u,l,f,n),s=!0)}}const m=new y,_=(new t).executeMany(m,this.m_gcs,this.m_progressTracker,2);if(null!==c){let t=c.next();a=null,c=null;const s=g(o,t,!0),n=h(s);t=r.unproject(t,n,this.m_progressTracker),this.putInGridCursors(e,t,o,!0,u,l,f,d,C)}for(let t=0;t<6;t++)if(null!=C[t]){let e=C[t].next();C[t]=null,d[t]=null,s&&null!==n[t]&&(e=(new b).execute(n[t],e,o,this.m_progressTracker));const i=g(o,e,!0),r=h(i);e=f[t].unproject(e,r,this.m_progressTracker),e=(new w).execute(e,this.m_gcs,!0,this.m_progressTracker),m.tick(Pt(e)),_.tock()}D=_.next()}else{let t,s=!1;if(e){let e=i.m_densified;if(i.m_densified=null,null!==e){const n=new tt;n.scale(1/this.m_rpu,1/this.m_rpu),e.applyTransformation(n),v.project(e);const i=g(null,e,!0);e=p(e,i,!1,!0,-1,this.m_progressTracker,0,!1),this.m_distance>0?(a.tick(Pt(e)),c.tock()):(t=e,s=!0)}}let n=c.next();a=null,c=null,s&&(n=(new b).execute(t,n,o,this.m_progressTracker));const m=g(o,n,!0),u=h(m);D=r.unproject(n,u,this.m_progressTracker),D=(new w).execute(D,this.m_gcs,!0,this.m_progressTracker)}return D=(new _).foldInto360RangeGeodetic(D,this.m_gcs,2),D}putInGridCursors(e,s,n,i,r,o,m,a,h){const c=[null,null,null,null,null,null];this.processInGrid(e,s,i,r,o,m,c);for(let e=0;e<6;e++)null!==c[e]&&(null===a[e]&&(a[e]=new y,h[e]=(new t).executeMany(a[e],n,this.m_progressTracker,2)),a[e].tick(Pt(c[e])),h[e].tock())}processInGrid(t,e,s,n,i,r,o){const m=.01,a=this.insertGeodeticPointsAlongGrid(e,i,m);for(let t=0;t<6;t++){if(n[t])continue;const h=i[t].clone();h.inflateCoords(m,m);const u=C(e,h),l=c(null,u,!1).total();let _=S(a,h,l,Number.NaN,this.m_progressTracker);if(null!==_&&!_.isEmpty()){if(_===a&&(_=_.clone()),null===r[t]){const e=new et;t<3?e.setCoords(0,1):e.setCoords(0,-1);const s=new et;s.setAdd(i[t].getCenter(),e),r[t]=pt(this.m_gcs,s)}r[t].project(_);const e=g(null,_,!0);_=p(_,e,s,!0,-1,this.m_progressTracker,0,!1),o[t]=_}}}insertGeodeticPointsAlongGrid(t,e,s){const i=n.construct(e[3].xmin,e[3].ymin,e[2].xmax,e[2].ymax),r=v(this.m_gcs,i,t,!0,this.m_progressTracker),o=new D,m=o.addGeometry(r);return I(o,m,this.m_gcs,0,2,!0,e[0].xmax+s),I(o,m,this.m_gcs,0,2,!0,e[1].xmax+s),I(o,m,this.m_gcs,0,2,!1,e[1].ymin+s),0!==s&&(I(o,m,this.m_gcs,0,2,!0,e[0].xmax-s),I(o,m,this.m_gcs,0,2,!0,e[1].xmax-s),I(o,m,this.m_gcs,0,2,!1,e[1].ymin-s)),o.getGeometry(m)}initializeGrid(t,e){for(let e=0;e<6;e++)t[e]=!1;e[0].setCoords({xmin:-this.m_gcs180,ymin:0,xmax:-this.m_gcs60,ymax:this.m_gcs90}),e[1].setCoords({xmin:-this.m_gcs60,ymin:0,xmax:this.m_gcs60,ymax:this.m_gcs90}),e[2].setCoords({xmin:this.m_gcs60,ymin:0,xmax:this.m_gcs180,ymax:this.m_gcs90}),e[3].setCoords({xmin:-this.m_gcs180,ymin:-this.m_gcs90,xmax:-this.m_gcs60,ymax:0}),e[4].setCoords({xmin:-this.m_gcs60,ymin:-this.m_gcs90,xmax:this.m_gcs60,ymax:0}),e[5].setCoords({xmin:this.m_gcs60,ymin:-this.m_gcs90,xmax:this.m_gcs180,ymax:0})}checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(t,e,s,n,i,r){const o=t[0],a=t.at(-1),h=o.y<a.y?o.y:a.y,c=o.y>a.y?o.y:a.y,u=m.q(this.m_a,this.m_eSquared,h),l=m.q(this.m_a,this.m_eSquared,c);if(this.m_q90-(u+e+this.m_absDistance)>.001&&this.m_q90+(l-e-this.m_absDistance)>.001)return!1;const _=s-it,f=n+it,d=_-Math.PI,g=_+Math.PI,p=f+Math.PI,P=[Number.NaN],x=[Number.NaN],y=[Number.NaN],b=[Number.NaN];let w=!1;if(lt(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,o,_,d,a,f,P,x),lt(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,a,p,f,o,d,y,b),(f<P[0]&&P[0]<p||f<x[0]&&x[0]<p)&&(w=!0),w||(d<y[0]&&y[0]<_||d<b[0]&&b[0]<_)&&(w=!0),!w&&i)return!1;const C=[];for(let e=t.length-1;e>=0;e--)C.push(t[e]);r.setEmpty(),r.addPathPoint2D(null,0,!0);let S=0;S=ct(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,this.m_curveType,t,_,f,i,S,r),S=ut(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,a,f,p,this.m_cornerStep,i,S,r,P[0],x[0]),S=ct(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,this.m_curveType,C,p,g,i,S,r),S=ut(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,o,d,_,this.m_cornerStep,i,S,r,y[0],b[0]);let v=!1;return i||(v=this.checkAndPrepForPole(r)),w||v}bufferPoint2D(t,e,s){s.setEmpty(),s.addPathPoint2D(null,0,!0),ut(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,t,-this.m_cornerStep,2*Math.PI,this.m_cornerStep,e,0,s);let n=!1;return e||(n=this.checkAndPrepForPole(s)),n}checkAndPrepForPole(t){const e=this.checkAndPrepForPoleTouch(t),s=this.checkAndPrepForPoleWrap(t);return e||s}checkAndPrepForPoleTouch(t){const e=new n;return t.queryEnvelope(e),!(!G(e.ymax,this.m_gcs90)&&!G(e.ymin,-this.m_gcs90)||(this.prepPoleTouch(t),0))}checkAndPrepForPoleWrap(t){const e=t.getXY(0),s=t.getXY(t.getPointCount()-1);return Math.abs(e.x-s.x)>this.m_gcs180?(this.prepSinglePoleWrap(t),!0):this.checkAndPrepForDoublePoleWrap(t)}checkAndPrepForDoublePoleWrap(t){return t.calculateArea2D()<0&&(this.prepDoublePoleWrap(t),!0)}prepPoleTouch(t){const e=new i;e.insertPath2D(-1,null,0,0,!0);const s=t.getPathStart(0),n=t.getPathEnd(0),r=n-s;let o=-1;for(o=s;o<n;o++){const e=t.getXY(o),s=G(e.y,this.m_gcs90),n=G(e.y,-this.m_gcs90);if(!s&&!n)break}let m=o,a=!1,h=Number.NaN;do{const n=t.getXY(m),i=G(n.y,this.m_gcs90),o=G(n.y,-this.m_gcs90),c=s+(m+1-s)%r;if(i||o){let s=et.construct(h,n.y);e.insertPoint2D(0,-1,s);const i=t.getXY(c),r=G(i.y,this.m_gcs90),o=G(i.y,-this.m_gcs90);r||o||(s=et.construct(i.x,n.y),a?e.setXY(e.getPointCount()-1,s):e.insertPoint2D(0,-1,s)),a=!0}else e.insertPoint2D(0,-1,n),h=n.x,a=!1;m=c}while(m!==o);t.setEmpty(),t.add(e,!1)}prepSinglePoleWrap(t){const e=new i,s=new i,r=new tt,o=t.getXY(t.getPathStart(0)),m=t.getXY(t.getPathEnd(0)-1),a=this.m_gcs360,h=this.m_gcs180,l=new n;l.setCoords({xmin:-this.m_gcs180,ymin:-this.m_gcs90,xmax:this.m_gcs180,ymax:this.m_gcs90});const _=new n;t.queryEnvelope(_);const f=Math.ceil(_.width()/a);let d,g;o.x>m.x?(d=-a,g=this.m_gcs90):(d=a,g=-this.m_gcs90),r.setShiftCoords(d,0),e.addPath(t,0,!0),s.add(e,!1);const p=new u;for(let t=0;t<f;t++)s.applyTransformation(r),s.getPointByVal(0,p),e.lineToPoint(p),e.addSegmentsFromPath(s,0,0,s.getSegmentCount()-1,!1);const P=e.getXY(0),x=e.getXY(e.getPointCount()-1);P.y=g,x.y=g,e.lineTo(x);const y=new et;for(y.setCoordsPoint2D(x),y.x-=.5*d;Math.abs(y.x-P.x)>h;)e.lineTo(y),y.x-=.5*d;e.lineTo(P);const b=l.getCenterX(),w=new n;e.queryEnvelope(w);let v=0;const G=w.getCenter().x;G-b>h?v=-Math.ceil((G-b-h)/a):b-G>h&&(v=Math.ceil((b-G-h)/a)),0!==v&&(r.setShiftCoords(v*a,0),e.applyTransformation(r));const M=new D,T=M.addGeometry(e);I(M,T,this.m_gcs,0,2,!0,l.xmin),I(M,T,this.m_gcs,0,2,!0,l.xmax);const N=M.getGeometry(T),k=C(N,l);k.inflateCoords(0,1);const A=c(null,k,!0).total(),q=S(N,l,A,Number.NaN,this.m_progressTracker);t.setEmpty(),t.add(q,!1)}prepDoublePoleWrap(t){const e=this.m_gcs360,s=this.m_gcs180,i=new n;i.setCoords({xmin:-this.m_gcs180,ymin:-this.m_gcs90,xmax:this.m_gcs180,ymax:this.m_gcs90});const r=i.getCenter().x,o=new n;t.queryPathEnvelope(0,o);let m,a=0,h=o.getCenter().x;if(h-r>s?a=-Math.ceil((h-r-s)/e):r-h>s&&(a=Math.ceil((r-h-s)/e)),0!==a){const s=new tt;s.setShiftCoords(a*e,0),t.getImpl().applyTransformationToPath(s,0),t.queryPathEnvelope(0,o),h=o.getCenter().x}const u=new n;i.containsExclusiveEnvelope(o)?(m=!1,u.setCoords({env2D:i})):(m=!0,u.setCoords({env2D:i}),u.xmin-=e,u.xmax+=e);let l=t.createInstance();l.addPathPoint2D(null,0,!0);const _=new et;if(_.setCoords(u.xmin,u.ymin),l.insertPoint2D(0,-1,_),_.setCoords(u.xmin,u.ymax),l.insertPoint2D(0,-1,_),_.setCoords(.5*(u.xmin+u.xmax),u.ymax),l.insertPoint2D(0,-1,_),_.setCoords(u.xmax,u.ymax),l.insertPoint2D(0,-1,_),_.setCoords(u.xmax,u.ymin),l.insertPoint2D(0,-1,_),_.setCoords(.5*(u.xmin+u.xmax),u.ymin),l.insertPoint2D(0,-1,_),m){l.addPath(t,0,!0);const s=new tt;h<r?s.setShiftCoords(e,0):s.setShiftCoords(-e,0),t.getImpl().applyTransformationToPath(s,0),l.addPath(t,0,!0);const n=new D,o=n.addGeometry(l);I(n,o,this.m_gcs,0,2,!0,i.xmin),I(n,o,this.m_gcs,0,2,!0,i.xmax),l=n.getGeometry(o);const m=C(l,i);m.inflateCoords(0,1);const a=c(null,m,!0).total();l=S(l,i,a,Number.NaN,this.m_progressTracker)}else l.addPath(t,0,!0);t.setEmpty(),t.add(l,!1)}setMinCornerStep(){const t={stack:[],error:void 0,hasError:!1};try{let e=Math.min(Math.PI*this.m_a-this.m_absDistance,this.m_absDistance);e=Math.min(e,.125*this.m_a*Math.PI);const s=new et;s.setCoords(0,10*this.m_rpu);const n=0;let i=45*this.m_rpu;const r=rt(t,new st(new M,new M),!1),o=rt(t,new st(new M,new M),!1),m=rt(t,new st(new M,new M),!1),a=rt(t,new st(new M,new M),!1),h=new et,c=new et,u=new et,l=new et;for(T.geodesicCoordinate(this.m_a,this.m_eSquared,s.x,s.y,e,n,r.at(0),r.at(1)),h.setCoords(r.at(0).val,r.at(1).val),T.geodesicCoordinate(this.m_a,this.m_eSquared,s.x,s.y,e,i,o.at(0),o.at(1)),c.setCoords(o.at(0).val,o.at(1).val);;){const t={stack:[],error:void 0,hasError:!1};try{const r=.5*(n+i);T.geodesicCoordinate(this.m_a,this.m_eSquared,s.x,s.y,e,r,m.at(0),m.at(1)),u.setCoords(m.at(0).val,m.at(1).val);const _=rt(t,new M,!1),f=rt(t,new M,!1);T.geodeticDistance(this.m_a,this.m_eSquared,h.x,h.y,c.x,c.y,_,f,null,2),T.geodeticCoordinate(this.m_a,this.m_eSquared,h.x,h.y,.5*_.val,f.val,a.at(0),a.at(1),2),l.setCoords(a.at(0).val,a.at(1).val);const d=rt(t,new M,!1);if(T.geodeticDistance(this.m_a,this.m_eSquared,u.x,u.y,l.x,l.y,d,null,null,2),d.val<=this.m_convergenceOffset)break;i*=.9,T.geodesicCoordinate(this.m_a,this.m_eSquared,s.x,s.y,e,i,o.at(0),o.at(1)),c.setCoords(o.at(0).val,o.at(1).val)}catch(e){t.error=e,t.hasError=!0}finally{ot(t)}}const _=i-n,f=2*Math.PI/Math.ceil(2*Math.PI/_);this.m_cornerStep=f}catch(e){t.error=e,t.hasError=!0}finally{ot(t)}}setMinSegmentStep(){const t={stack:[],error:void 0,hasError:!1};try{let e=Math.min(Math.PI*this.m_a-this.m_absDistance,this.m_absDistance);e=Math.min(e,.125*this.m_a*Math.PI);const s=new et,n=new et;s.setCoords(0,10*this.m_rpu),n.setCoords(10*this.m_rpu,10*this.m_rpu);const i=rt(t,new M,!1),r=rt(t,new M,!1),o=rt(t,new M,!1);T.geodeticDistance(this.m_a,this.m_eSquared,s.x,s.y,n.x,n.y,o,i,r,this.m_curveType);const m=rt(t,new st(new M,new M),!1),a=rt(t,new st(new M,new M),!1),h=new et,c=rt(t,new M,!1),u=rt(t,new st(new M,new M),!1),l=rt(t,new st(new M,new M),!1),_=rt(t,new st(new M,new M),!1),f=rt(t,new st(new M,new M),!1),d=new et,g=new et,p=new et,P=new et,x=0;let y=1;const b=i.val,w=r.val,C=b-.5*Math.PI,S=w+.5*Math.PI,v=o.val;for(T.geodesicCoordinate(this.m_a,this.m_eSquared,s.x,s.y,e,C,u.at(0),u.at(1)),d.setCoords(u.at(0).val,u.at(1).val),T.geodesicCoordinate(this.m_a,this.m_eSquared,n.x,n.y,e,S,l.at(0),l.at(1)),g.setCoords(l.at(0).val,l.at(1).val);;){const t={stack:[],error:void 0,hasError:!1};try{const i=.5*(x+y);T.geodeticCoordinate(this.m_a,this.m_eSquared,s.x,s.y,i*v,b,m.at(0),m.at(1),this.m_curveType),h.setCoords(m.at(0).val,m.at(1).val),T.geodeticDistance(this.m_a,this.m_eSquared,s.x,s.y,h.x,h.y,null,null,c,this.m_curveType);const r=c.val+.5*Math.PI;T.geodesicCoordinate(this.m_a,this.m_eSquared,h.x,h.y,e,r,_.at(0),_.at(1)),p.setCoords(_.at(0).val,_.at(1).val);const o=rt(t,new M,!1),u=rt(t,new M,!1);T.geodeticDistance(this.m_a,this.m_eSquared,d.x,d.y,g.x,g.y,o,u,null,2),T.geodeticCoordinate(this.m_a,this.m_eSquared,d.x,d.y,.5*o.val,u.val,f.at(0),f.at(1),2),P.setCoords(f.at(0).val,f.at(1).val);const w=rt(t,new M,!1);if(T.geodeticDistance(this.m_a,this.m_eSquared,p.x,p.y,P.x,P.y,w,null,null,2),w.val<=this.m_convergenceOffset)break;{const t={stack:[],error:void 0,hasError:!1};try{y*=.9,T.geodeticCoordinate(this.m_a,this.m_eSquared,s.x,s.y,y*v,b,a.at(0),a.at(1),this.m_curveType),n.setCoords(a.at(0).val,a.at(1).val);const i=rt(t,new M,!1);T.geodeticDistance(this.m_a,this.m_eSquared,s.x,s.y,n.x,n.y,null,null,i,this.m_curveType);const r=i.val+.5*Math.PI;T.geodesicCoordinate(this.m_a,this.m_eSquared,n.x,n.y,e,r,l.at(0),l.at(1)),g.setCoords(l.at(0).val,l.at(1).val)}catch(e){t.error=e,t.hasError=!0}finally{ot(t)}}}catch(e){t.error=e,t.hasError=!0}finally{ot(t)}}let D=y*v;D>1e5&&(D=1e5),this.m_segmentStep=D}catch(e){t.error=e,t.hasError=!0}finally{ot(t)}}setConvergenceOffset(){let t;t=this.m_absDistance>5e4?100:this.m_absDistance>1e4?10:1,this.m_absDistance/t<500&&(t=this.m_absDistance/500),t<.01&&(t=.01),this.m_convergenceOffset=t}}function ht(t,e,s,g,p,P,x){if(t.isEmpty())return new i({vd:t.getDescription()});let y=t;if(H(y)){const t=10*e.getTolerance(0);y=(new r).execute(y,0,t,0,x,12e3)}const b=new at(x);b.m_sr=e,b.m_gcs=e.getGCS(),b.m_transform=o(e,b.m_gcs,null);const w=N();b.m_gcs.querySpheroidData(w);const C=new n;y.queryEnvelope(C),b.m_a=w.majorSemiAxis,b.m_eSquared=w.e2,b.m_rpu=b.m_gcs.getUnit().getUnitToBaseFactor(),b.m_gcs90=.5*Math.PI/b.m_rpu,b.m_gcs180=Math.PI/b.m_rpu,b.m_gcs360=2*Math.PI/b.m_rpu,b.m_gcs60=b.m_gcs360/6,b.m_q90=m.q90(b.m_a,b.m_eSquared),b.m_ellipticToGeodesicMaxRatio=.5*b.m_a*Math.PI/b.m_q90;const S=b.m_gcs.getTolerance(0);b.m_radTolerance=S*b.m_rpu,4===s?(b.m_curveType=2,b.m_bShapePreserving=!0):(b.m_curveType=s,b.m_bShapePreserving=!1),b.m_distance=g,b.m_absDistance=Math.abs(g),Number.isNaN(p)||p<=0?b.setConvergenceOffset():b.m_convergenceOffset=Math.max(p,.001),b.m_convergenceOffset/=P;let v,D=y.getGeometryType();if(L(D)){const t=new a({vd:y.getDescription()});t.addSegment(y,!0),v=t,D=J.enumPolyline}else if(D===J.enumEnvelope){const t=y,e=new n;t.queryEnvelope(e);const s=h(c(b.m_sr,C,!0));if(e.minDimension()<=s)if(0===e.maxDimension()){const e=new u({vd:y.getDescription()});t.getCenter(e),v=e,D=J.enumPoint}else{const e=new a({vd:y.getDescription()});e.addEnvelope(t,!1),v=e,D=J.enumPolyline}else{const e=new i({vd:y.getDescription()});e.addEnvelope(t,!1),v=e,D=J.enumPolygon}}else v=y;if(b.setMinCornerStep(),V(D)||b.setMinSegmentStep(),b.m_absDistance<=.5*b.m_convergenceOffset)return D!==J.enumPolygon?new i({vd:v.getDescription()}):b.m_bShapePreserving?v:l(v,b.m_sr,b.m_curveType,b.m_segmentStep,-1,x);if(b.m_distance<0&&D!==J.enumPolygon)return new i({vd:v.getDescription()});if(b.m_bShapePreserving&&Q(D)){const t=l(v,e,4,Number.NaN,b.m_convergenceOffset,x);v=(new _).execute(t,b.m_transform,x)}else v=(new _).execute(v,b.m_transform,x);if(v=f(v,b.m_gcs),v.isEmpty())return new i({vd:v.getDescription()});!b.m_bShapePreserving&&Q(D)&&(v=d(b.m_rpu,v)),v=function(t,e){const s=t.getGeometryType();let i;if(i=Q(s)?t.getPathCount():s===J.enumMultiPoint?t.getPointCount():1,1===i)return t;const r=[],o=[];for(let m=0;m<i;m++){r.push(m);const i=new et;if(Q(s)){const e=new n;t.queryPathEnvelope(m,e),i.assign(e.getCenter())}else i.assign(t.getXY(m));const a=e.toGeohash(i);o.push(a)}r.sort(((t,e)=>o[t]<o[e]?-1:o[t]>o[e]?1:0));const m=t.createInstance();for(let e=0;e<i;e++){const n=r[e];Q(s)?m.addPath(t,n,!0):m.addPoints(t,n,n+1)}return m}(v,b.m_gcs);let I=new i;switch(D){case J.enumPolygon:I=b.bufferPolygon(v);break;case J.enumPolyline:I=b.bufferPolyline(v);break;case J.enumMultiPoint:I=b.bufferMultiPoint(v);break;case J.enumPoint:I=b.bufferPoint(v);break;default:K("")}const G=(new _).execute(I,b.m_transform.getInverse(),x);return G.mergeVertexDescription(v.getDescription()),G}function ct(t,e,s,n,i,r,o,m,a,h,c){const u={stack:[],error:void 0,hasError:!1};try{const l=new et;l.setNAN(),a||c.getPointCount()>0&&(l.setCoordsPoint2D(c.getXY(c.getPointCount()-1)),l.scale(s));const _=rt(u,new M,!1),f=rt(u,new st(new M,new M),!1),d=new et,g=new et,p=r.at(-1),P=1/s;for(let s=0;s<r.length;s++){const u=r[s];let x;0===s?x=o:s===r.length-1?x=m:(T.geodeticDistance(t,e,p.x,p.y,u.x,u.y,null,null,_,i),x=_.val-.5*Math.PI),T.geodesicCoordinate(t,e,u.x,u.y,n,x,f.at(0),f.at(1)),a?g.setCoords(f.at(0).val,f.at(1).val):(d.setCoords(f.at(0).val,f.at(1).val),h=_t(u.x,d.x,l.x,h),g.setCoords(h+d.x,d.y),l.setCoordsPoint2D(g)),g.scale(P),c.insertPoint2D(0,-1,g)}return h}catch(t){u.error=t,u.hasError=!0}finally{ot(u)}}function ut(t,e,s,n,i,r,o,m,a,h,c,u=Number.NaN,l=Number.NaN){const _={stack:[],error:void 0,hasError:!1};try{if(o-r<m)return h;const f=rt(_,new st(new M,new M),!1),d=new et,g=new et,p=new et;g.setNAN(),a||c.getPointCount()>0&&(g.setCoordsPoint2D(c.getXY(c.getPointCount()-1)),g.scale(s));let P=Math.ceil(r/m),x=P++*m;x===r&&(x=P++*m);let y=r;const b=1/s;for(;x<o+m&&(y<u&&u<x?(x=u,P--):y<l&&l<x&&(x=l,P--),!(x>=o));)T.geodesicCoordinate(t,e,i.x,i.y,n,x,f.at(0),f.at(1)),a?p.setCoords(f.at(0).val,f.at(1).val):(d.setCoords(f.at(0).val,f.at(1).val),h=_t(i.x,d.x,g.x,h),p.setCoords(h+d.x,d.y),g.setCoordsPoint2D(p)),p.scale(b),c.insertPoint2D(0,-1,p),y=x,x=P++*m;return h}catch(t){_.error=t,_.hasError=!0}finally{ot(_)}}function lt(t,e,s,n,i,r,o,m,a,h,c){const u={stack:[],error:void 0,hasError:!1};try{const s=new et,l=new et,_=rt(u,new st(new M,new M),!1);T.geodesicCoordinate(t,e,i.x,i.y,n,r,_.at(0),_.at(1)),s.setCoords(_.at(0).val,_.at(1).val),T.geodesicCoordinate(t,e,i.x,i.y,n,o,_.at(0),_.at(1)),l.setCoords(_.at(0).val,_.at(1).val);const f=rt(u,new M,!1);for(T.geodeticDistance(t,e,m.x,m.y,s.x,s.y,null,f,null,0),h[0]=f.val,T.geodeticDistance(t,e,m.x,m.y,l.x,l.y,null,f,null,0),c[0]=f.val;h[0]<=c[0];)h[0]+=nt;for(;h[0]>c[0];)h[0]-=nt;for(;h[0]>=a;)h[0]-=nt,c[0]-=nt;for(;h[0]<a;)h[0]+=nt,c[0]+=nt}catch(t){u.error=t,u.hasError=!0}finally{ot(u)}}function _t(t,e,s,n){if(Number.isNaN(s)){for(;n+e-t>Math.PI;)n-=nt;for(;t-(n+e)>Math.PI;)n+=nt;return n}return n+e-s>Math.PI?n-=nt:s-(n+e)>Math.PI&&(n+=nt),n}function ft(t,e,s,n,i,r){const o={stack:[],error:void 0,hasError:!1};try{if(n>=r)return!1;const m=s[0],a=s.at(-1),h=rt(o,new M,!1),c=rt(o,new M,!1),u=rt(o,new M,!1);T.greatEllipticDistance(t,e,i.x,i.y,m.x,m.y,h,null,null),T.greatEllipticDistance(t,e,i.x,i.y,a.x,a.y,c,null,null),T.greatEllipticDistance(t,e,m.x,m.y,a.x,a.y,u,null,null);let l=Math.min(h.val,c.val)+u.val,_=l+n;if(_<r)return!0;const f=rt(o,new M,!1);l=Math.max(h.val,c.val);for(let n=1;n<s.length-1;n++){const r=s[n];T.greatEllipticDistance(t,e,i.x,i.y,r.x,r.y,f,null,null),f.val>l&&(l=f.val)}return _=l+n,_<r}catch(t){o.error=t,o.hasError=!0}finally{ot(o)}}function dt(t,e,s,n,i,r,o,m){let a;if(n.length%2==0){const t=n.length>>1,e=n[t],s=n[t-1];a=et.lerp(e,s,.5)}else a=n[n.length-1>>1].clone();const h=a.clone(),c=E(t,e,h,75/180*Math.PI);return!!ft(t,e,n,i,h,c)&&(null!==r&&(r.setCoordsPoint2D(a),r.scale(1/s)),null!==o&&o.setCoordsPoint2D(h),null!==m&&(m[0]=c),!0)}function gt(t,e,s,n,i,r){const o={stack:[],error:void 0,hasError:!1};try{if(n>=r)return!1;const m=rt(o,new M,!1);return T.greatEllipticDistance(t,e,i.x,i.y,s.x,s.y,m,null,null),m.val+n<r}catch(t){o.error=t,o.hasError=!0}finally{ot(o)}}function pt(t,e){return new k(t,e)}function Pt(t){return A(t,0)||q(t,0),t}class xt{constructor(t){this.m_bRunningInGnomonic=!1,this.m_bNeedsSimplify=!1,this.m_gnomonic=null,this.m_gnomonicCenterRad=new et,this.m_minGnomonicRadius=Number.NaN,this.m_progressTracker=t}isRunningInGnomonic(){return this.m_bRunningInGnomonic}needsSimplify(){return this.m_bNeedsSimplify}getGnomonic(){return this.m_gnomonic}}class yt extends xt{constructor(t,e,s){super(t.m_progressTracker),this.m_segIter=null,this.m_bNextSegmentCannotJoin=!1,this.m_currentDensifiedDelta=[0],this.m_currentBufferedDelta=0,this.m_lastAzimuth=0,this.m_startAzimuth=[0],this.m_endAzimuth=[0],this.m_numWinds=0,this.m_debugCounter=0,this.m_bufferHelper=new i,this.m_densifiedPoints=[],this.m_bufferer=t,this.m_multiPath=e,this.m_densified=s,this.m_bNeedsSimplify=!0;const r=new n;this.m_multiPath.queryEnvelope(r);const o=r.getCenter(),m=o.clone();m.scale(this.m_bufferer.m_rpu),this.m_gnomonic=pt(this.m_bufferer.m_gcs,o),this.m_gnomonicCenterRad=m.clone(),this.m_minGnomonicRadius=E(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,m,75/180*Math.PI)}next(){let t;if(this.m_bNextSegmentCannotJoin)return this.m_bNextSegmentCannotJoin=!1,this.m_segIter.nextSegment(),t=this.m_bufferHelper.clone(),t;if(null===this.m_segIter){if(this.m_segIter=this.m_multiPath.getImpl().querySegmentIterator(),!this.m_segIter.nextPath())return null;null!==this.m_densified&&this.m_densified.addPathPoint2D(null,0,!0)}if(!this.m_segIter.hasNextSegment()){if(!this.m_segIter.nextPath())return null;null!=this.m_densified&&this.m_densified.addPathPoint2D(null,0,!0)}let e=null;this.m_currentBufferedDelta=0,this.m_currentDensifiedDelta=[0],this.m_numWinds=0,this.m_lastAzimuth=Number.NaN,this.m_bNextSegmentCannotJoin=!1,this.m_densifiedPoints.length=0;let s=0;const n=new et,r=new et;for(;this.m_segIter.hasNextSegment()&&this.m_numWinds<16;){const t=this.m_segIter.nextSegment();if(n.setCoordsPoint2D(t.getStartXY()),r.setCoordsPoint2D(t.getEndXY()),n.scale(this.m_bufferer.m_rpu),r.scale(this.m_bufferer.m_rpu),j(n,r))n.x=r.x;else if(R(n,r))r.x=n.x;else{let t=-1,e=-1;const s=this.m_segIter.getPathIndex(),i=this.m_multiPath.getPathStart(s),o=this.m_multiPath.getPathEnd(s);if(t=this.m_segIter.getStartPointIndex()-1,e=this.m_segIter.getEndPointIndex()+1,t<i&&(t=this.m_multiPath.isClosedPath(s)?o-1:-1),e>o-1&&(e=this.m_multiPath.isClosedPath(s)?i:-1),-1!==t){const e=this.m_multiPath.getXY(t);e.scale(this.m_bufferer.m_rpu),R(e,n)&&(n.x=e.x)}if(-1!==e){const t=this.m_multiPath.getXY(e);t.scale(this.m_bufferer.m_rpu),j(r,t)&&(r.x=t.x)}}this.m_densifiedPoints.length=0;const o=z(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_curveType,n,r,this.m_bufferer.m_segmentStep,Number.NaN,this.m_bufferer.m_radTolerance,this.m_startAzimuth,this.m_endAzimuth,this.m_densifiedPoints,this.m_currentDensifiedDelta);if(0===s)this.m_bRunningInGnomonic=this.isSegmentBufferInCurrentGnomonic(this.m_densifiedPoints),this.m_bRunningInGnomonic||(this.m_bRunningInGnomonic=this.tryUpdateGnomonic(this.m_densifiedPoints));else if(this.m_bRunningInGnomonic){if(!this.isSegmentBufferInCurrentGnomonic(this.m_densifiedPoints)){this.m_segIter.previousSegment(),this.m_segIter.previousSegment(),this.m_segIter.nextSegment();break}}else if(dt(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_densifiedPoints,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,null,null,null)){this.m_segIter.previousSegment(),this.m_segIter.previousSegment(),this.m_segIter.nextSegment();break}if(0===o||X(n,r)?(this.m_bufferHelper.setEmpty(),this.m_bufferer.bufferPoint2D(n,this.m_bRunningInGnomonic,this.m_bufferHelper),this.m_bNextSegmentCannotJoin=!0):(this.m_bufferHelper.setEmpty(),this.m_bNextSegmentCannotJoin=this.checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(o,this.m_bufferHelper)),this.m_bNextSegmentCannotJoin){this.m_segIter.previousSegment(),this.m_segIter.hasPreviousSegment()?(this.m_segIter.previousSegment(),this.m_segIter.nextSegment()):this.m_segIter.resetToFirstSegment(),null!=this.m_densified&&this.m_densified.insertPointsFromPoints(this.m_densified.getPathCount()-1,-1,this.m_densifiedPoints,0,this.m_densifiedPoints.length-1,!0);break}null!=this.m_densified&&this.m_densified.insertPointsFromPoints(this.m_densified.getPathCount()-1,-1,this.m_densifiedPoints,0,this.m_densifiedPoints.length-1,!0),null===e&&(e=new i,e.addPathPoint2D(null,0,!0)),this.addJoinAndBufferLeftSide(e),s++}if(this.m_currentDensifiedDelta=[0],s>0){const t=this.m_segIter.getStartPointIndex(),i=this.m_segIter.getPathIndex();for(;s>0;){if(this.m_segIter.previousSegment(),n.setCoordsPoint2D(this.m_multiPath.getXY(this.m_segIter.getStartPointIndex())),r.setCoordsPoint2D(this.m_multiPath.getXY(this.m_segIter.getEndPointIndex())),n.scale(this.m_bufferer.m_rpu),r.scale(this.m_bufferer.m_rpu),this.m_bRunningInGnomonic)if(j(n,r))n.x=r.x;else if(R(n,r))r.x=n.x;else{let t=-1,e=-1;const s=this.m_segIter.getPathIndex(),i=this.m_multiPath.getPathStart(s),o=this.m_multiPath.getPathEnd(s);if(t=this.m_segIter.getStartPointIndex()-1,e=this.m_segIter.getEndPointIndex()+1,t<i&&(t=this.m_multiPath.isClosedPath(s)?o-1:-1),e>o-1&&(e=this.m_multiPath.isClosedPath(s)?i:-1),-1!==t){const e=this.m_multiPath.getXY(t);e.scale(this.m_bufferer.m_rpu),R(e,n)&&(n.x=e.x)}if(-1!==e){const t=this.m_multiPath.getXY(e);t.scale(this.m_bufferer.m_rpu),j(r,t)&&(r.x=t.x)}}this.m_densifiedPoints.length=0,z(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_curveType,r,n,this.m_bufferer.m_segmentStep,Number.NaN,this.m_bufferer.m_radTolerance,this.m_startAzimuth,this.m_endAzimuth,this.m_densifiedPoints,this.m_currentDensifiedDelta),this.addJoinAndBufferLeftSide(e),s--}return n.setCoordsPoint2D(this.m_multiPath.getXY(this.m_segIter.getStartPointIndex())),n.scale(this.m_bufferer.m_rpu),this.m_currentBufferedDelta=ut(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_bufferer.m_absDistance,n,this.m_lastAzimuth+.5*Math.PI,this.m_lastAzimuth+1.5*Math.PI,this.m_bufferer.m_cornerStep,this.m_bRunningInGnomonic,this.m_currentBufferedDelta,e),this.m_segIter.resetToVertex(t,i),this.m_segIter.nextSegment(),e}return this.m_bNextSegmentCannotJoin=!1,this.m_segIter.nextSegment(),t=this.m_bufferHelper.clone(),t}isSegmentBufferInCurrentGnomonic(t){return null!==this.m_gnomonic&&ft(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,t,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,this.m_gnomonicCenterRad,this.m_minGnomonicRadius)}tryUpdateGnomonic(t){const e=new et,s=new et,n=[0];return dt(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,t,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,e,s,n)?(this.m_gnomonicCenterRad.setCoordsPoint2D(s),this.m_minGnomonicRadius=n[0],this.m_gnomonic=pt(this.m_bufferer.m_gcs,e),!0):(this.m_gnomonic=null,!1)}checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(t,e){return this.m_bufferer.checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(this.m_densifiedPoints,t,this.m_startAzimuth[0],this.m_endAzimuth[0],this.m_bRunningInGnomonic,e)}addJoinAndBufferLeftSide(t){const e=this.m_densifiedPoints[0];let s=Number.NaN,n=this.m_startAzimuth[0]-it;const i=this.m_endAzimuth[0]+it;let r=!1;if(!Number.isNaN(this.m_lastAzimuth)){this.m_lastAzimuth>=this.m_startAzimuth[0]?(s=this.m_lastAzimuth+it,n=s+Math.PI-(this.m_lastAzimuth-this.m_startAzimuth[0])):(s=this.m_lastAzimuth+it,n=s+Math.PI-(nt-(this.m_startAzimuth[0]-this.m_lastAzimuth))),r=!(this.m_lastAzimuth>=this.m_startAzimuth[0]&&this.m_lastAzimuth-this.m_startAzimuth[0]<=Math.PI||this.m_lastAzimuth<this.m_startAzimuth[0]&&this.m_startAzimuth[0]-this.m_lastAzimuth>=Math.PI);let i=!1;if(Math.abs(n-s)<=.5*this.m_bufferer.m_cornerStep&&(r||(i=!0)),i){if(t.removePointFromPath(0,t.getPointCount()-1),!this.m_bRunningInGnomonic){const e=new et;e.setCoordsPoint2D(t.getXY(t.getPointCount()-1)),e.scale(this.m_bufferer.m_rpu),e.x-this.m_currentBufferedDelta<-Math.PI?this.m_currentBufferedDelta-=nt:e.x-this.m_currentBufferedDelta>Math.PI&&(this.m_currentBufferedDelta+=nt)}n=.5*(n+s)}else if(r){const s=new et;s.setCoordsPoint2D(e),s.scale(1/this.m_bufferer.m_rpu),t.insertPoint2D(0,-1,s)}else ut(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_bufferer.m_absDistance,this.m_densifiedPoints[0],s,n,this.m_bufferer.m_cornerStep,this.m_bRunningInGnomonic,this.m_currentBufferedDelta,t)}this.m_startAzimuth[0]!==this.m_lastAzimuth&&this.m_numWinds++,ct(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_bufferer.m_absDistance,this.m_bufferer.m_curveType,this.m_densifiedPoints,n,i,this.m_bRunningInGnomonic,this.m_currentBufferedDelta,t),this.m_lastAzimuth=this.m_endAzimuth[0]}}class bt extends xt{constructor(t,e){super(t.m_progressTracker),this.m_pointIndex=-1,this.m_bufferer=t,this.m_multiPoint=e,this.m_bNeedsSimplify=!1;const s=new n;this.m_multiPoint.queryEnvelope(s);const i=s.getCenter(),r=i.clone();r.scale(this.m_bufferer.m_rpu),this.m_gnomonic=pt(this.m_bufferer.m_gcs,i),this.m_gnomonicCenterRad=r.clone(),this.m_minGnomonicRadius=E(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,r,75/180*Math.PI)}next(){if(this.m_bNeedsSimplify=!1,++this.m_pointIndex===this.m_multiPoint.getPointCount())return null;const t=this.m_multiPoint.getXY(this.m_pointIndex);t.scale(this.m_bufferer.m_rpu),this.m_bRunningInGnomonic=this.isPointBufferInCurrentGnomonic(t),this.m_bRunningInGnomonic||(this.m_bRunningInGnomonic=this.tryUpdateGnomonic(t));const e=new i,s=this.m_bufferer.bufferPoint2D(t,this.m_bRunningInGnomonic,e);return this.m_bNeedsSimplify=s,e}isPointBufferInCurrentGnomonic(t){return null!==this.m_gnomonic&&gt(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,t,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,this.m_gnomonicCenterRad,this.m_minGnomonicRadius)}tryUpdateGnomonic(t){const e=new et,s=new et,n=[0];return function(t,e,s,n,i,r,o,m){const a=E(t,e,n,75/180*Math.PI);return!!gt(t,e,n,i,n,a)&&(null!==r&&(r.setCoordsPoint2D(n),r.scale(1/s)),null!==o&&o.setCoordsPoint2D(n),null!==m&&(m[0]=a),!0)}(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,t,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,e,s,n)?(this.m_gnomonicCenterRad.setCoordsPoint2D(s),this.m_minGnomonicRadius=n[0],this.m_gnomonic=pt(this.m_bufferer.m_gcs,e),!0):(this.m_gnomonic=null,!1)}}class wt{getOperatorType(){return 10110}supportsCurves(){return!0}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}executeMany(e,s,n,i,r,o,m,a){if(m){const m=new Ct(e,s,n,i,r,!1,o,a);return(new t).executeMany(m,s,a)}return new Ct(e,s,n,i,r,!1,o,a)}execute(t,s,n,i,r,o,m){const a=new e([t]),h=[i],c=this.executeMany(a,s,n,h,r,!1,o,m).next();return c||Y("geodesic buffer null output"),c}}class Ct extends s{constructor(t,e,s,i,r,o,m,a){super(),this.m_currentUnionEnvelope2D=new n,this.m_index=-1,this.m_dindex=-1,this.m_progressTracker=a,o&&U(""),e||O(""),0===e.getCoordinateSystemType()&&O(""),this.m_inputGeoms=t,this.m_spatialReference=e,this.m_curveType=s,this.m_distances=i,this.m_convergenceOffset=r,this.m_bOutlineOnly=o,this.m_bUnion=m}next(){let t;for(;t=this.m_inputGeoms.next();)return F(t),this.m_index=this.m_inputGeoms.getGeometryID(),this.m_dindex+1<this.m_distances.length&&this.m_dindex++,this.geodesicBuffer(t,this.m_distances[this.m_dindex]);return null}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}geodesicBuffer(t,e){return function(t,e,s,n,i,r){n<Number.MAX_VALUE&&n>-Number.MAX_VALUE||O("Geodesic_bufferer.buffer - bad distance"),F(t);const o=mt(t),m=o.getGeometryType();if(W(m)){const t=o.getPointCount(),a=8e6;if(Math.abs(n)>a&&(t>50||m!==J.enumMultiPoint&&4===s&&t>2)){let t=o;const m=n>0?1:-1,h=7e6;let c=n,u=1;do{u++,c=(Math.abs(c)-h)*m}while(Math.abs(c)>a);c=n;for(let n=0;n<u-1;n++)t=ht(t,e,s,h*m,i,u,r),c=(Math.abs(c)-h)*m;return t=ht(t,e,s,c,i,u,r),t}}return ht(o,e,s,n,i,1,r)}(t,this.m_spatialReference,this.m_curveType,e,this.m_convergenceOffset,this.m_progressTracker)}}export{wt as OperatorGeodesicBuffer};
