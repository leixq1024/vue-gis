/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{_ as e}from"../../chunks/tslib.es6.js";import t from"../../Color.js";import n from"../../core/Evented.js";import{h as s}from"../../chunks/handleUtils.js";import{m as o}from"../../chunks/memoize.js";import{watch as i,syncAndInitial as r,sync as l}from"../../core/reactiveUtils.js";import{g as a}from"../../chunks/uuid.js";import{property as u}from"../../core/accessorSupport/decorators/property.js";import{i as c,B as p}from"../../core/lang.js";import"../../chunks/Logger.js";import{subclass as m}from"../../core/accessorSupport/decorators/subclass.js";import h from"../../geometry/Point.js";import{n as f,g as d,A as v,l as g}from"../../chunks/unitUtils.js";import{f as y}from"../../chunks/vec4f64.js";import{R as j}from"../../chunks/Material.js";import{g as k,l as w}from"../../chunks/mathUtils.js";import{throwIfAborted as x,throwIfNotAbortError as S,after as E,isAbortError as P}from"../../core/promiseUtils.js";import b from"../../geometry/Multipoint.js";import{k as R}from"../../chunks/coordsUtils.js";import{Q as _}from"../../chunks/QueueProcessor.js";import{T as M}from"../../chunks/Scheduler.js";import{u as Z,h as C}from"../../chunks/vec2.js";import{l as U}from"../../chunks/vec3.js";import D from"../../geometry/Polyline.js";import{initializeProjection as O,project as N}from"../../geometry/projection.js";import A from"../../geometry/SpatialReference.js";import{geodesicLengths as T,isSupported as z,inverseGeodeticSolver as G,directGeodeticSolver as L}from"../../geometry/support/geodesicUtils.js";import{u as I}from"../../chunks/elevationInfoUtils.js";import{b as V}from"../../chunks/traversalUtils.js";import"../../chunks/colorUtils.js";import"../../chunks/ensureType.js";import"../../config.js";import"../../core/Accessor.js";import"../../core/Handles.js";import"../../chunks/maybe.js";import"../../chunks/metadata.js";import"../../chunks/utils.js";import"../../chunks/ObservableBase.js";import"../../chunks/tracking.js";import"../../core/scheduling.js";import"../../core/Error.js";import"../../chunks/asyncUtils.js";import"../../core/Collection.js";import"../../chunks/shared.js";import"../../chunks/SimpleObservable.js";import"../../core/accessorSupport/decorators/cast.js";import"../../chunks/reader.js";import"../../chunks/writer.js";import"../../geometry/Geometry.js";import"../../core/JSONSupport.js";import"../../chunks/jsonMap.js";import"../../chunks/assets.js";import"../../request.js";import"../../kernel.js";import"../../core/urlUtils.js";import"../../geometry/support/webMercatorUtils.js";import"../../chunks/vec3f64.js";import"../../chunks/interfaces3.js";import"../../chunks/VertexAttribute.js";import"../../chunks/boundedPlane.js";import"../../chunks/ray.js";import"../../chunks/mat3.js";import"../../chunks/mat3f64.js";import"../../chunks/plane.js";import"../../chunks/mat4f64.js";import"../../chunks/quatf64.js";import"../../chunks/vec2f64.js";import"../../chunks/mathUtils2.js";import"../../chunks/mat4.js";import"../../chunks/common.js";import"../../chunks/aaBoundingRect.js";import"../../geometry/Extent.js";import"../../chunks/Axis.js";import"../../chunks/lineSegment.js";import"../../chunks/sphere.js";import"../../chunks/vec4.js";import"../../chunks/ViewingMode.js";import"../../chunks/zmUtils.js";import"../../chunks/Queue.js";import"../../chunks/ReactiveMap.js";import"../../core/signal.js";import"../../chunks/debugFlags.js";import"../../chunks/extentUtils.js";import"../../chunks/boundsUtils.js";import"../../geometry/Polygon.js";import"../../chunks/projectBuffer.js";import"../../chunks/geodesicConstants.js";import"../../geometry/support/GeographicTransformation.js";import"../../geometry/support/GeographicTransformationStep.js";import"../../chunks/zscale.js";import"../../geometry.js";import"../../chunks/typeUtils.js";import"../../geometry/support/jsonUtils.js";import"../../chunks/unitConversionUtils.js";import"../../chunks/lengthUtils.js";var q,H;!function(e){e.Disabled="disabled",e.Ready="ready",e.Creating="creating",e.Created="created",e.Selecting="selecting",e.Selected="selected"}(q||(q={})),function(e){e.NoValidInput="no-valid-input",e.NoVisibleProfiles="no-visible-profiles",e.InvalidGeometry="invalid-geometry",e.TooComplex="too-complex",e.InvalidElevationInfo="invalid-elevation-info",e.UnknownError="unknown-error",e.RefinedButNoChartData="refined-but-no-chart-data",e.None="none"}(H||(H={}));let F={noDataValue:-5e5,defaultQueryOptions:()=>({noDataValue:F.noDataValue,demResolution:"auto",maximumAutoTileRequests:150,ignoreInvisibleLayers:!0}),updateThrottleMillis:100,delayAfterPreviewMillis:500,defaultDemResolution:f(10,"centimeters","meters"),densificationMaxSamples:3e3,largeChartSamples:1e4,maxTotalSamples:1e5,maxChartRatio:300,minSlopeSampleDistance:10,formatPrecision:1,portraitModePixelBreakpoint:400,profileLinesStyle3D:{width:3,falloff:0,innerWidth:0,innerColor:y(0,0,0,0),renderOccluded:j.Opaque},profileLines3DUpdateThrottleMillis:100,hoveredPointsStyle:{size:14,borderStyle:"solid",borderWidth:3,borderColor:"#ffffff",boxShadow:"0px 0px 0px 5px rgba(255,255,255,0.2)"}};function Q(){return F}const W=" â€• ",B={progress:1,hasZ:!1,samples:[],statistics:null,spatialReference:null},Y="ProfileGenerationError";var J;!function(e){e.TooComplex="too-complex",e.InvalidGeometry="invalid-geometry",e.InvalidElevationInfo="invalid-elevation-info",e.ElevationQueryError="elevation-query-error"}(J||(J={}));class K extends Error{constructor(e){super("profile could not be generated",{cause:e}),this.type=Y}}function X(e){return e.type===Y}function $(e,t){const n=e/t.densificationMaxSamples;return Math.max(t.samplingDistance,n)}function ee(e,t,n){if(null==t)return te(e);const s=e.spatialReference,o=t.mode,i=I(t,s);let r=null;switch(n.type){case"2d":r=function({hasZ:e},t,n){return"absolute-height"===t?e?([e,t,s])=>[e,t,s+n]:([e,t])=>[e,t,n]:null}(e,o,i);break;case"3d":r=function({spatialReference:e,hasZ:t},n,s,{elevationProvider:o}){const i=(t,n,s,i)=>o?.getElevation(t,n,s,e,i)??0;switch(n){case"on-the-ground":return([e,t])=>[e,t,i(e,t,0,"ground")];case"absolute-height":return t?([e,t,n])=>[e,t,n+s]:([e,t])=>[e,t,s];case"relative-to-ground":return t?([e,t,n])=>[e,t,n+i(e,t,n,"ground")+s]:([e,t])=>[e,t,i(e,t,0,"ground")+s];case"relative-to-scene":return t?([e,t,n])=>[e,t,n+i(e,t,n,"scene")+s]:([e,t])=>[e,t,i(e,t,0,"scene")+s];default:return null}}(e,o,i,n)}return null==r?te(e):new D({hasZ:!0,hasM:!1,spatialReference:s,paths:ne(e.paths,r)})}function te(e){return e.hasZ?new D({hasZ:!1,hasM:!1,spatialReference:e.spatialReference,paths:ne(e.paths,(([e,t])=>[e,t]))}):e}function ne(e,t){const n=e.length,s=new Array(n);for(let o=0;o<n;++o){const n=e[o],i=n.length,r=new Array(n.length);s[o]=r;for(let e=0;e<i;++e)r[e]=t(n[e])}return s}function se(e){return oe(e)&&e.paths.length>0&&e.paths.every((e=>e.length>=2))}function oe(e){return null!=e&&"polyline"===e.type}function ie(e,t,n,s,o){const{spatialReference:i,hasZ:r}=e,l={from:null,to:null,distance:0,azimuth:0,reverseAzimuth:0,spatialReference:i,metersPerSR:d(i)},a=[],u=[];let c=0;for(let i=0;i<e.paths.length;++i){const r=e.paths[i],p=new Array,m=new Array;let h=0;for(let e=1;e<r.length;++e){const i=r[e-1],a=r[e],u=s(l,i,a);let f;for(f=h;f<u.distance&&!k(f,u.distance);f+=t)p.push(o(u,f)),m.push((c+f)*n);h=f-u.distance,c+=u.distance,p.push(a),m.push(c*n)}a[i]=p,u[i]=m}return{densifiedPath:new D({spatialReference:i,hasZ:r,paths:a}),distances:u}}function re(e,t,n){return e.distance=0,G(e,t,n,e.spatialReference),e.from=t,e.to=n,e}function le(e,t,n){return e.from=t,e.to=n,e.distance=Z(n,t)*e.metersPerSR,e}function ae({from:e,azimuth:t,spatialReference:n},s){return L([0,0],e,t,s,n)}function ue({from:e,to:t,azimuth:n,distance:s,spatialReference:o},i){const r=i/s,l=[0,0,w(e[2],t[2],r)];return L(l,e,n,i,o),l}function ce({from:e,to:t,distance:n},s){return C([0,0],e,t,s/n)}function pe({from:e,to:t,distance:n},s){return U([0,0,0],e,t,s/n)}function me(e){return e.paths.reduce(((e,t)=>e+t.length),0)}function he(e,t,n){return me(e)+Math.floor(t/n)+Math.max(0,e.paths.reduce((e=>1+e),0)-1)}function fe(e){const t=e.filter(c),n=t.length;if(0===n)return null;const s=t[0];if(1===n)return s;let o=s.maxDistance,i=s.minElevation,r=s.maxElevation,l=s.maxPositiveSlope,a=s.maxNegativeSlope;for(let e=1;e<t.length;++e){const n=t[e];o=ge(o,n.maxDistance),i=ve(i,n.minElevation),r=ge(r,n.maxElevation),l=ge(l,n.maxPositiveSlope),a=ge(a,n.maxNegativeSlope)}return{maxDistance:o,minElevation:i,maxElevation:r,avgElevation:null,elevationGain:null,elevationLoss:null,maxPositiveSlope:l,maxNegativeSlope:a,avgPositiveSlope:null,avgNegativeSlope:null}}function de(e){let t=null,n=null,s=null;for(const o of e){if(null==o)continue;const{statistics:e,spatialReference:i}=o;if(null==e)continue;const r=d(i);t=ge(t,ye(e.maxDistance,r));const l=v(i);s=ve(s,ye(e.minElevation,l)),n=ge(n,ye(e.maxElevation,l))}return{minDistance:0,maxDistance:t??0,minElevation:s??0,maxElevation:n??0}}function ve(e,t){return null==t?e:null!=e?Math.min(e,t):t}function ge(e,t){return null==t?e:null!=e?Math.max(e,t):t}function ye(e,t){return null!=e&&null!=t?e*t:null}class je{constructor(){this._start=0,this._totalElevation=0,this._sampleCount=0}get avgElevation(){return this._totalElevation/this._sampleCount}get isHole(){return 0===this._sampleCount}get start(){return this._start}copy(e){this._start=e._start,this._sampleCount=e._sampleCount,this._totalElevation=e._totalElevation}reset(){this._start=0,this._sampleCount=0,this._totalElevation=0}restart(e,t){this._start=e,this._sampleCount=1,this._totalElevation=t}insert(e){++this._sampleCount,this._totalElevation+=e}}async function*ke(e,t){const{view:n,geometry:s,elevationInfo:o,providers:i,options:r}=e,l=n.spatialReference;if(!l||null==s||!se(s))throw new K(J.InvalidGeometry);const a=i.length;if(0===a)return null;const u=Math.round(r.maxTotalSamples/a);if(me(s)>u)throw new K(J.TooComplex);const c=await async function(e,t,n,s,o,i,r){let l,a,u;const c=e.spatialReference,p=c.isGeographic||c.isWebMercator;let m=0;if(!p){const{planarLength:t}=await import("../../geometry/geometryEngineAsync.js");x(r),m=await t(e,"meters"),x(r)}const h=1/d(s),f=o.geodesicDistanceThreshold??1/0;if(p||m>=f){await O([{source:c,dest:s},{source:c,dest:A.WGS84}],r);const p=z((v=e).spatialReference)?v:N(v,A.WGS84);l=T([p],"meters")[0];const m=$(l,o);if(he(e,l,m)>i)throw new K(J.TooComplex);const f=ee(p,t,n);({densifiedPath:a,distances:u}=function(e,t,n){const{hasZ:s}=e;return ie(e,t,n,re,s?ue:ae)}(f,m,h)),a=N(a,s)}else{await O([{source:c,dest:s}],r),l=m;const p=$(l,o);if(he(e,l,p)>i)throw new K(J.TooComplex);const f=ee(e,t,n);({densifiedPath:a,distances:u}=function(e,t,n){const{hasZ:s}=e;return ie(e,t,n,le,s?pe:ce)}(f,p,h)),x(r),a=N(a,s)}var v;return{densifiedPath:a,pathLength:l*h,distances:u}}(s,o,n,l,r,u,t);let p=0;const m=new Array(a),h=new Array(a);for(let n=0;n<a;n++){const s=Pe(c);m[n]=s,p+=s.samples.length;const o={...e,provider:i[n],result:s,densificationResult:c};h[n]=we(o,t)[Symbol.iterator]()}if(p>r.maxTotalSamples)throw new K(J.TooComplex);const f=await Promise.all(h.map((e=>{const t=e.next();return!0===t.done?Promise.resolve(null):t.value})));x(t);for(let e=0;e<a;e++)m[e]=f[e];yield m,await E(e.delayAfterPreview??Q().delayAfterPreviewMillis,null,t.signal);const v=[];try{let e;do{e=!1;for(let t=0;t<a;t++){const n=h[t].next();!1===n.done&&(v.push({resultPromise:n.value,index:t}),e=!0)}}while(e)}finally{h.forEach((e=>e.return?.()))}for(const{resultPromise:e,index:n}of v)m[n]=await e,x(t),yield m;for(const e of m)null!=e&&(e.progress=1);yield m}function*we(e,t){const{densificationResult:n}=e,s={...e,abortOptions:t,densificationResult:n},o=V(0,s.result.samples.length),i=o.slice(0,s.provider.numSamplesForPreview);yield xe(s,i,!0);const r=p(o,s.provider.numSamplesPerChunk);for(const e of r)yield xe(s,e,!1)}async function xe({densificationResult:e,result:t,provider:n,queue:s,abortOptions:o,cache:i},r,l){const{densifiedPath:a,pathLength:u}=e,c=t.spatialReference,{samples:p}=t,m=[];for(let e=0;e<r.length;e++){const t=p[r[e]];m[e]=t.coordinate}try{return await s.push({geometry:new b({spatialReference:c,points:m,hasZ:a.hasZ}),provider:n,indices:r,preview:l,result:t,queryOptions:{...Q().defaultQueryOptions(),minDemResolution:l?Math.round(u/n.numSamplesForPreview):Math.round(u/p.length),cache:i}},o),{...t}}catch(e){return P(e)?null:B}}function Se(e){return new _({priority:M.ELEVATION_PROFILE,concurrency:1,scheduler:e,process:async e=>{x(e.queryOptions);try{await async function({geometry:e,provider:t,indices:n,preview:s,result:o,queryOptions:i}){if(0===n.length)return;const r=(await async function(e,t,n){try{return await e.queryElevation(t,n)}catch(e){throw new K(J.ElevationQueryError)}}(t,e,i)).geometry,{hasZ:l,points:a}=r,u=i.noDataValue,{samples:c}=o;for(let e=0;e<n.length;e++){const t=c[n[e]];if(t.isHole)continue;const s=l?a[e][2]:null;null===s||s===u?t.sampledZ=null:(o.hasZ=!0,t.sampledZ=s),t.sampled=!0}(function(e){const t=e.length-1;let n=0;for(let s=1;s<=t;s++)(e[s].sampled||s===t)&&(Ee(e,n,s),n=s)})(c),o.progress=s?0:o.progress+n.length/c.length,o.statistics=function(e,t){const n=e.length;if(0===n)return null;const s=e[0],o=s.sampledZ;let i=o,r=o,l=0,a=0,u=null,c=null,p=null!=o?o:0,m=0,h=0,g=null!=o?1:0,y=0,j=0;const k=d(t),w=v(t),x=Q().minSlopeSampleDistance/k,S=2*x,E=new je,P=new je,b=()=>{_(),E.copy(P),P.reset()},R=(e,t)=>{b(),e>0&&e-E.start<=S&&(e=E.start+x),P.restart(e,t)},_=()=>{if(E.isHole||P.isHole)return;const e=P.avgElevation-E.avgElevation,t=P.start-E.start,n=e*w,s=t*k,o=f(Math.atan2(n,s),"radians","degrees");o>0?(m+=o,u=ge(u,o),y++):o<0&&(h-=o,c=ge(c,-o),j++)};null!=s.sampledZ&&R(s.distance,s.sampledZ);for(let t=1;t<n;++t){const n=e[t-1],s=e[t],o=s.sampledZ;if(null==o){P.isHole||b();continue}g++,p+=o,i=ve(i,o),r=ge(r,o),P.isHole||s.distance-P.start>=x?R(s.distance,o):P.insert(o);const u=n.sampledZ;if(null!=u){const e=o-u;e>0?l+=e:e<0&&(a-=e)}}return b(),0===g?null:{maxDistance:e[n-1].distance,minElevation:i,maxElevation:r,avgElevation:0===g?null:p/g,elevationGain:l,elevationLoss:a,maxPositiveSlope:u,maxNegativeSlope:c,avgPositiveSlope:0===y?null:m/y,avgNegativeSlope:0===j?null:h/j}}(o.samples,o.spatialReference)}(e)}catch(e){S(e)}}})}function Ee(e,t,n){if(n-t==1)return;const s=e[t],o=s.sampledZ,i=e[n],r=i.sampledZ;if(null==o||null==r){for(let s=t+1;s<n;s++)e[s].sampledZ=null;return}const l=s.distance,a=i.distance-l;for(let s=t+1;s<n;s++){const t=e[s],n=(t.distance-l)/a;t.sampledZ=w(o,r,n)}}function Pe({densifiedPath:e,distances:t}){const n=e.spatialReference,s=g(n),o=e.paths,i=o.length,r=[];let l=null,a=0;for(let e=0;e<i;e++){const n=o[e],i=n.length,u=t[e];for(let e=0;e<i;e++){const t=n[e],o=u[e];s&&(t[0]=R(t[0],s.valid[0],s.valid[1])),l&&0===e&&be(r,l,t,a,o),r.push(Re(t,o)),l=t,a=o}}return{progress:0,samples:r,hasZ:!1,statistics:null,spatialReference:n}}function be(e,t,n,s,o){e.push(_e(t,s)),e.push(_e(n,o))}function Re(e,t){return{coordinate:e,distance:t,sampledZ:null,sampled:!1,isHole:!1}}function _e(e,t){return{coordinate:e,distance:t,sampledZ:null,sampled:!0,isHole:!0}}function Me(e,t,n){if(!e||0===e.length)return;const s=e.length-1,o=e[0];if(t<=n(o))return o;const i=e[s];if(t>=n(i))return i;let r=0,l=0,a=s;for(;r<a;){l=r+Math.floor((a-r)/2);const o=e[l],i=n(o);if(i===t)return o;if(t<i){if(l>0){const s=e[l-1],r=n(s);if(t>r)return t-r>=i-t?o:s}a=l}else{if(l<s){const s=e[l+1],r=n(s);if(t<r)return t-i>=r-t?s:o}r=l+1}}return e[l]}function Ze(e,t,n){return null==e?null:f(e*t,"meters",n)}function Ce(e,t,n){return null==e?null:f(e*t,"meters",n)}let Ue=class extends n.EventedAccessor{constructor(e){super(e),this.type=null,this.id=a(),this.title=null,this.color=new t("#000000"),this.visible=!0,this._getSamplesMemoized=o(((e,t)=>function(e,t){if(null==e||null==t)return null;const{samples:n,spatialReference:s}=e,{distance:o,elevation:i}=t,r=d(s),l=v(s),a=n.length,u=new Array(a);for(let e=0;e<a;++e){const t=n[e],s=t.sampledZ,a=t.coordinate;u[e]={x:a[0],y:a[1],z:s,distance:Ze(t.distance,r,o),elevation:Ce(s,l,i)}}return u}(e,t))),this._getStatisticsMemoized=o(((e,t)=>function(e,t){if(null==e||null==t||null==e.statistics||null==e.spatialReference)return null;const{distance:n,elevation:s}=t,{statistics:o,spatialReference:i}=e,r=d(i),l=v(i);return{maxDistance:Ze(o.maxDistance,r,n),minElevation:Ce(o.minElevation,l,s),maxElevation:Ce(o.maxElevation,l,s),avgElevation:Ce(o.avgElevation,l,s),elevationGain:Ce(o.elevationGain,l,s),elevationLoss:Ce(o.elevationLoss,l,s),maxPositiveSlope:o.maxPositiveSlope,maxNegativeSlope:o.maxNegativeSlope,avgPositiveSlope:o.avgPositiveSlope,avgNegativeSlope:o.avgNegativeSlope}}(e,t))),this.viewVisualizationEnabled=!0,this.result=null,this.effectiveUnits=null,this.numSamplesForPreview=30,this.numSamplesPerChunk=200,this.chartFillEnabled=!0,this.chartStrokeWidth=1.5,this.chartStrokeOffsetY=0,this._viewModel=null}get progress(){return null!=this.result&&this.visible?this.result.progress:0}get samples(){return this._getSamplesMemoized(this.result,this.effectiveUnits)}get statistics(){return this._getStatisticsMemoized(this.result,this.effectiveUnits)}get hoveredPoint(){const e=this._viewModel?.hoveredChartPosition;return null!=e?this._getPoint(e):null}get available(){return!0}get hasZ(){const e=this.result;return null!=e&&e.hasZ}get minDemResolution(){return Q().defaultDemResolution}queryElevation(){throw new Error("not implemented")}attach(e){return this._viewModel=e,s([i((()=>e.effectiveUnits),(e=>{this.effectiveUnits=e}),r),i((()=>[e.input]),(()=>this._onChange()),l)])}toggleVisibility(e){this.visible=void 0===e?!this.visible:e}_onChange(){this.emit("change")}_getPoint(e){const{samples:t,result:n}=this;if(null==t||null==n)return null;const s=t.length;if(0===s)return null;const o=Me(t,e*t[s-1].distance,(e=>e.distance));if(null==o)return null;const{x:i,y:r,z:l}=o;return null==l?null:new h({x:i,y:r,z:l,spatialReference:n.spatialReference})}};e([u({nonNullable:!0})],Ue.prototype,"id",void 0),e([u({nonNullable:!0})],Ue.prototype,"title",void 0),e([u({type:t,nonNullable:!0})],Ue.prototype,"color",void 0),e([u({nonNullable:!0})],Ue.prototype,"visible",void 0),e([u({readOnly:!0})],Ue.prototype,"progress",null),e([u({readOnly:!0})],Ue.prototype,"samples",null),e([u({readOnly:!0})],Ue.prototype,"statistics",null),e([u()],Ue.prototype,"hoveredPoint",null),e([u()],Ue.prototype,"viewVisualizationEnabled",void 0),e([u()],Ue.prototype,"available",null),e([u()],Ue.prototype,"result",void 0),e([u()],Ue.prototype,"effectiveUnits",void 0),e([u()],Ue.prototype,"numSamplesForPreview",void 0),e([u()],Ue.prototype,"numSamplesPerChunk",void 0),e([u()],Ue.prototype,"chartFillEnabled",void 0),e([u()],Ue.prototype,"chartStrokeWidth",void 0),e([u()],Ue.prototype,"chartStrokeOffsetY",void 0),e([u({readOnly:!0})],Ue.prototype,"hasZ",null),e([u({readOnly:!0})],Ue.prototype,"minDemResolution",null),e([u()],Ue.prototype,"_viewModel",void 0),Ue=e([m("esri.widgets.ElevationProfile.ElevationProfileLine")],Ue);const De=Ue;export{q as E,J as P,se as a,Me as b,ke as c,Se as d,De as default,de as e,H as f,Q as g,X as h,oe as i,fe as m,W as n};
