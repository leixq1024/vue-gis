/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{_ as t}from"../chunks/tslib.es6.js";import{clone as e,e as n}from"../core/lang.js";import{property as r}from"../core/accessorSupport/decorators/property.js";import"../chunks/Logger.js";import{subclass as s}from"../core/accessorSupport/decorators/subclass.js";import{w as i}from"../chunks/writer.js";import o,{i as l,p as a}from"./Extent.js";import u from"./Geometry.js";import h from"./Point.js";import c from"./SpatialReference.js";import{h as p,b as m,i as f}from"../chunks/coordsUtils.js";import{b as g}from"../chunks/extentUtils.js";import{project as y}from"./support/webMercatorUtils.js";import{u as x}from"../chunks/zmUtils.js";import"../chunks/ensureType.js";import"../chunks/utils.js";import"../chunks/handleUtils.js";import"../chunks/metadata.js";import"../core/Error.js";import"../config.js";import"../chunks/tracking.js";import"../chunks/unitUtils.js";import"../chunks/jsonMap.js";import"../chunks/assets.js";import"../request.js";import"../kernel.js";import"../core/urlUtils.js";import"../core/JSONSupport.js";import"../core/Accessor.js";import"../core/Handles.js";import"../chunks/maybe.js";import"../chunks/ObservableBase.js";import"../core/scheduling.js";import"../core/promiseUtils.js";import"../chunks/reader.js";import"../core/accessorSupport/decorators/cast.js";import"../chunks/Axis.js";import"../chunks/boundsUtils.js";import"../chunks/aaBoundingRect.js";import"../chunks/mathUtils.js";function I(t){const e=[];for(t.reset();t.nextPath();){const n=[];for(;t.nextPoint();)n.push([t.x,t.y]);e.push(n)}return t.reset(),e}function N(t){const e=[];for(;t.nextPoint();)e.push([t.x,t.y]);return t.seekPathStart(),e}function j(t){return t?t.hasZ?[t.xmax-t.xmin/2,t.ymax-t.ymin/2,t.zmax-t.zmin/2]:[t.xmax-t.xmin/2,t.ymax-t.ymin/2]:null}function P(t){return t?d(t.rings,t.hasZ??!1):null}function d(t,e){if(!t?.length)return null;const n=[],r=[],s=e?[1/0,-1/0,1/0,-1/0,1/0,-1/0]:[1/0,-1/0,1/0,-1/0];for(let n=0,i=t.length;n<i;n++){const i=k(t[n],e,s);i&&r.push(i)}if(r.sort(((t,n)=>{let r=t[2]-n[2];return 0===r&&e&&(r=t[4]-n[4]),r})),r.length&&(n[0]=r[0][0],n[1]=r[0][1],e&&(n[2]=r[0][3]),(n[0]<s[0]||n[0]>s[1]||n[1]<s[2]||n[1]>s[3]||e&&(n[2]<s[4]||n[2]>s[5]))&&(n.length=0)),!n.length){const r=t[0]&&t[0].length?function(t,e){const n=e?[0,0,0]:[0,0],r=e?[0,0,0]:[0,0];let s=0,i=0,o=0,l=0;for(let a=0,u=t.length;a<u-1;a++){const u=t[a],h=t[a+1];if(u&&h){n[0]=u[0],n[1]=u[1],r[0]=h[0],r[1]=h[1],e&&u.length>2&&h.length>2&&(n[2]=u[2],r[2]=h[2]);const t=m(n,r);if(t){s+=t;const n=p(u,h);i+=t*n[0],o+=t*n[1],e&&n.length>2&&(l+=t*n[2])}}}return s>0?e?[i/s,o/s,l/s]:[i/s,o/s]:t.length?t[0]:null}(t[0],e):null;if(!r)return null;n[0]=r[0],n[1]=r[1],e&&r.length>2&&(n[2]=r[2])}return n}function k(t,e,n){let r=0,s=0,i=0,o=0,l=0;const a=t.length?t[0][0]:0,u=t.length?t[0][1]:0,h=t.length&&e?t[0][2]:0;for(let c=0;c<t.length;c++){const p=t[c],m=t[(c+1)%t.length],[f,g,y]=p,x=f-a,I=g-u,[N,j,P]=m,d=N-a,k=j-u,R=x*k-d*I;if(o+=R,r+=(x+d)*R,s+=(I+k)*R,e&&p.length>2&&m.length>2){const t=y-h,e=P-h,n=x*e-d*t;i+=(t+e)*n,l+=n}f<n[0]&&(n[0]=f),f>n[1]&&(n[1]=f),g<n[2]&&(n[2]=g),g>n[3]&&(n[3]=g),e&&(y<n[4]&&(n[4]=y),y>n[5]&&(n[5]=y))}if(o>0&&(o*=-1),l>0&&(l*=-1),!o)return null;o*=.5,l*=.5;const c=[r/(6*o)+a,s/(6*o)+u,o];return e&&(n[4]===n[5]||0===l?(c[3]=(n[4]+n[5])/2,c[4]=0):(c[3]=i/(6*l)+h,c[4]=l)),c}function R(t,e){let n=0,r=0,s=0;t.nextPoint();const i=t.pathSize?t.x:0,o=t.pathSize?t.y:0;for(let l=0;l<t.pathSize;l++){t.seekInPath(l);const a=[t.x,t.y];t.seekInPath((l+1)%t.pathSize);const u=[t.x,t.y],[h,c]=a,p=h-i,m=c-o,[f,g]=u,y=f-i,x=g-o,I=p*x-y*m;s+=I,n+=(p+y)*I,r+=(m+x)*I,h<e[0]&&(e[0]=h),h>e[1]&&(e[1]=h),c<e[2]&&(e[2]=c),c>e[3]&&(e[3]=c)}return s>0&&(s*=-1),s?(s*=.5,[n/(6*s)+i,r/(6*s)+o,s]):null}function S(t){let e=0;for(t.reset();t.nextPath();)e+=t.getCurrentRingArea();if(e<1e-6){const e=function(t){const{hasZ:e,totalSize:n}=t;if(0===n)return null;const r=[],s=[],i=e?[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY]:[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY];for(t.reset();t.nextPath();){const e=k(N(t),t.hasZ,i);e&&s.push(e)}if(s.sort(((t,n)=>{let r=t[2]-n[2];return 0===r&&e&&(r=t[4]-n[4]),r})),s.length&&(r[0]=s[0][0],r[1]=s[0][1],e&&(r[2]=s[0][3]),(r[0]<i[0]||r[0]>i[1]||r[1]<i[2]||r[1]>i[3]||e&&(r[2]<i[4]||r[2]>i[5]))&&(r.length=0)),!r.length){t.reset(),t.nextPath();const n=t.pathSize?function(t){const{hasZ:e}=t,n=e?[0,0,0]:[0,0],r=e?[0,0,0]:[0,0];let s=0,i=0,o=0,l=0;if(t.nextPoint()){let a=t.x,u=t.y,h=t.z;for(;t.nextPoint();){const c=t.x,f=t.y,g=t.z;n[0]=a,n[1]=u,r[0]=c,r[1]=f,e&&(n[2]=h,r[2]=g);const y=m(n,r);if(y){s+=y;const t=p(n,r);i+=y*t[0],o+=y*t[1],e&&t.length>2&&(l+=y*t[2])}a=c,u=f,h=g}}return s>0?e?[i/s,o/s,l/s]:[i/s,o/s]:t.pathSize?(t.seekPathStart(),t.nextPoint(),[t.x,t.y]):null}(t):null;if(!n)return null;r[0]=n[0],r[1]=n[1],e&&n.length>2&&(r[2]=n[2])}return r}(t);return e?[e[0],e[1]]:null}const n=[0,0];if(t.reset(),!t.nextPath()||!t.nextPoint())return null;const r=[t.x,t.y];for(t.reset();t.nextPath();)T(n,r,t);return n[0]*=1/e,n[1]*=1/e,n[0]+=r[0],n[1]+=r[1],n}const b=1/3;function T(t,e,n){if(!t||!n||n.pathSize<3)return null;n.nextPoint();const r=n.x,s=n.y;n.nextPoint();let i,o=n.x-r,l=n.y-s,a=0,u=0;for(;n.nextPoint();)a=n.x-r,u=n.y-s,i=.5*b*(a*l-u*o),t[0]+=i*(o+a),t[1]+=i*(l+u),o=a,l=u;const h=n.getCurrentRingArea(),c=[r,s];return c[0]-=e[0],c[1]-=e[1],c[0]*=h,c[1]*=h,t[0]+=c[0],t[1]+=c[1],t}var w;function z(t){return!Array.isArray(t[0])}let A=w=class extends u{static fromExtent(t){const e=t.clone().normalize(),{spatialReference:n}=t;let r=!1,s=!1;for(const t of e)t.hasZ&&(r=!0),t.hasM&&(s=!0);const i={rings:e.map((t=>{const e=[[t.xmin,t.ymin],[t.xmin,t.ymax],[t.xmax,t.ymax],[t.xmax,t.ymin],[t.xmin,t.ymin]];if(r&&t.hasZ){const n=t.zmin+.5*(t.zmax-t.zmin);for(let t=0;t<e.length;t++)e[t].push(n)}if(s&&t.hasM){const n=t.mmin+.5*(t.mmax-t.mmin);for(let t=0;t<e.length;t++)e[t].push(n)}return e})),spatialReference:n};return r&&(i.hasZ=!0),s&&(i.hasM=!0),new w(i)}constructor(t){super(function(t){if(!t)return;let{rings:e,hasM:n,hasZ:r,spatialReference:s}=t;var i;switch(e??=[],i=e,"number"==typeof i[0]?.[0]&&(e=[e]),e[0]?.[0]?.length){case 4:r??=!0,n??=!0;break;case 3:r??=!0!==n,n??=!r;break;default:r??=!1,n??=!1}return s??=c.WGS84,{...t,hasM:n,hasZ:r,rings:e,spatialReference:s}}(t)),this.rings=[],this.type="polygon"}get cache(){return this.commitProperty("rings"),this.commitProperty("hasZ"),this.commitProperty("hasM"),this.commitProperty("spatialReference"),{}}get centroid(){const t=P(this);if(!t||isNaN(t[0])||isNaN(t[1])||this.hasZ&&isNaN(t[2]))return null;const e=new h;return e.x=t[0],e.y=t[1],e.spatialReference=this.spatialReference,this.hasZ&&(e.z=t[2]),e}get extent(){const{spatialReference:t}=this,e=g(this);if(!e)return null;const n=new o(e);return n.spatialReference=t,n}get isSelfIntersecting(){return l(this.rings)}writeRings(t,n){n.rings=e(this.rings)}addRing(t){if(!t)return;const e=this.rings,n=e.length;if(z(t)){const r=[];for(let e=0,n=t.length;e<n;e++)r[e]=t[e].toArray();e[n]=r}else e[n]=t.slice();return this.notifyChange("rings"),this}clone(){const t=new w;return t.spatialReference=this.spatialReference,t.rings=e(this.rings),t.hasZ=this.hasZ,t.hasM=this.hasM,t}equals(t){if(this===t)return!0;if(null==t)return!1;const e=this.spatialReference,r=t.spatialReference;if(null!=e!=(null!=r))return!1;if(null!=e&&null!=r&&!e.equals(r))return!1;if(this.rings.length!==t.rings.length)return!1;const s=([t,e,n,r],[s,i,o,l])=>t===s&&e===i&&(null==n&&null==o||n===o)&&(null==r&&null==l||r===l);for(let e=0;e<this.rings.length;e++){const r=this.rings[e],i=t.rings[e];if(!n(r,i,s))return!1}return!0}contains(t){if(!t)return!1;const e=y(t,this.spatialReference);return a(this,null!=e?e:t)}isClockwise(t){const e=z(t)?t.map((t=>this.hasZ?this.hasM?[t.x,t.y,t.z,t.m]:[t.x,t.y,t.z]:[t.x,t.y])):t;return f(e)}getPoint(t,e){if(!this._validateInputs(t,e))return null;const n=this.rings[t][e],r=this.hasZ,s=this.hasM;return r&&!s?new h(n[0],n[1],n[2],void 0,this.spatialReference):s&&!r?new h(n[0],n[1],void 0,n[2],this.spatialReference):r&&s?new h(n[0],n[1],n[2],n[3],this.spatialReference):new h(n[0],n[1],this.spatialReference)}insertPoint(t,e,n){return this._validateInputs(t,e,!0)?(x(this,n),Array.isArray(n)||(n=n.toArray()),this.rings[t].splice(e,0,n),this.notifyChange("rings"),this):this}removePoint(t,e){if(!this._validateInputs(t,e))return null;const n=new h(this.rings[t].splice(e,1)[0],this.spatialReference);return this.notifyChange("rings"),n}removeRing(t){if(!this._validateInputs(t,null))return null;const e=this.rings.splice(t,1)[0],n=this.spatialReference,r=e.map((t=>new h(t,n)));return this.notifyChange("rings"),r}setPoint(t,e,n){return this._validateInputs(t,e)?(x(this,n),Array.isArray(n)||(n=n.toArray()),this.rings[t][e]=n,this.notifyChange("rings"),this):this}_validateInputs(t,e,n=!1){if(null==t||t<0||t>=this.rings.length)return!1;if(null!=e){const r=this.rings[t];if(n&&(e<0||e>r.length))return!1;if(!n&&(e<0||e>=r.length))return!1}return!0}toJSON(t){return this.write({},t)}};t([r({readOnly:!0})],A.prototype,"cache",null),t([r({readOnly:!0})],A.prototype,"centroid",null),t([r({readOnly:!0})],A.prototype,"extent",null),t([r({readOnly:!0})],A.prototype,"isSelfIntersecting",null),t([r({type:[[[Number]]],json:{write:{isRequired:!0}}})],A.prototype,"rings",void 0),t([i("rings")],A.prototype,"writeRings",null),A=w=t([s("esri.geometry.Polygon")],A);const E=A;A.prototype.toJSON.isDefaultToJSON=!0;export{N as a,R as b,I as c,E as default,j as e,P as p,d as r,S as w};
