/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import"../../geometry.js";import t from"../../core/Error.js";import{c as e,n as s,f as n,b as i}from"../../chunks/unitUtils.js";import{a as r}from"../../chunks/ensureType.js";import{t as o,s as a,w as c}from"../../chunks/geodesicConstants.js";import p from"../SpatialReference.js";import h from"../Polyline.js";import u from"../Polygon.js";import l from"../Point.js";import"../Extent.js";import"../../chunks/tslib.es6.js";import"../../chunks/Logger.js";import"../../config.js";import"../../core/lang.js";import"../../core/accessorSupport/decorators/property.js";import"../../chunks/utils.js";import"../../chunks/handleUtils.js";import"../../chunks/metadata.js";import"../../core/accessorSupport/decorators/subclass.js";import"../../chunks/tracking.js";import"../Geometry.js";import"../../core/JSONSupport.js";import"../../core/Accessor.js";import"../../core/Handles.js";import"../../chunks/maybe.js";import"../../chunks/ObservableBase.js";import"../../core/scheduling.js";import"../../core/promiseUtils.js";import"../../chunks/reader.js";import"../../chunks/jsonMap.js";import"../../chunks/assets.js";import"../../request.js";import"../../kernel.js";import"../../core/urlUtils.js";import"../../chunks/writer.js";import"./webMercatorUtils.js";import"../Multipoint.js";import"../../chunks/zmUtils.js";import"../../core/accessorSupport/decorators/cast.js";import"../../chunks/typeUtils.js";import"./jsonUtils.js";import"../../chunks/coordsUtils.js";import"../../chunks/Axis.js";import"../../chunks/extentUtils.js";import"../../chunks/boundsUtils.js";import"../../chunks/aaBoundingRect.js";import"../../chunks/mathUtils.js";function m(t){if(!t)return null;const e=t.wkid;if(e)return a[e];const s=t.wkt2??t.wkt;return s?function(t){const e=c.exec(t);if(!e||2!==e.length)return null;const s=e[1].split(",");if(!s||s.length<3)return null;const n=parseFloat(s[1]),i=parseFloat(s[2]);return isNaN(n)||isNaN(i)?null:{a:n,f:0===i?0:1/i}}(s):null}function f(t){const e=m(t);if(function(t){return null!=t&&"b"in t&&"eSq"in t&&"radius"in t}(e))return e;const s=e.a*(1-e.f);return Object.assign(e,{b:s,eSq:1-(s/e.a)**2,radius:(2*e.a+s)/3,densificationRatio:1e4/((2*e.a+s)/3)})}function d(t){return null!=t&&t<0?t+360:t}function g(t,e,s){const{a:n,eSq:i}=f(s),r=Math.sqrt(i),a=Math.sin(e[1]*o),c=n*e[0]*o;let p;return p=i>0?n*((1-i)*(a/(1-i*(a*a))-1/(2*r)*Math.log((1-r*a)/(1+r*a))))*.5:n*a,t[0]=c,t[1]=p,t}function M(t){return e(t)&&!!m(t)}function j(e,n="square-meters"){if(e.some((t=>!M(t.spatialReference))))throw new t("geodesic-areas:invalid-spatial-reference","the input geometries spatial reference is not supported");const i=[];for(let t=0;t<e.length;t++){const s=e[t],n=s.spatialReference,{radius:r,densificationRatio:o}=f(n),a=r*o;i.push(y(s,a))}const r=[],o=[0,0],a=[0,0];for(let t=0;t<i.length;t++){const{rings:e,spatialReference:c}=i[t];let p=0;for(let t=0;t<e.length;t++){const s=e[t];g(o,s[0],c),g(a,s[s.length-1],c);let n=a[0]*o[1]-o[0]*a[1];for(let t=0;t<s.length-1;t++)g(o,s[t+1],c),g(a,s[t],c),n+=a[0]*o[1]-o[0]*a[1];p+=n}p=s(p,"square-meters",n),r.push(p/-2)}return r}function w(e,n="meters"){if(!e)throw new t("geodesic-lengths:invalid-geometries","the input geometries type is not supported");if(e.some((t=>!M(t.spatialReference))))throw new t("geodesic-lengths:invalid-spatial-reference","the input geometries spatial reference is not supported");const i=[];for(let t=0;t<e.length;t++){const r=e[t],{spatialReference:o}=r,a="polyline"===r.type?r.paths:r.rings;let c=0;for(let t=0;t<a.length;t++){const e=a[t];let s=0;for(let t=1;t<e.length;t++){const n=e[t-1][0],i=e[t][0],r=e[t-1][1],a=e[t][1];if(r!==a||n!==i){const t=new k;R(t,[n,r],[i,a],o),s+=t.distance}}c+=s}c=s(c,"meters",n),i.push(c)}return i}function y(e,s){if("polyline"!==e.type&&"polygon"!==e.type)throw new t("geodesic-densify:invalid-geometry","the input geometry is neither polyline nor polygon");const{spatialReference:n}=e;if(!M(n))throw new t("geodesic-densify:invalid-spatial-reference","the input geometry spatial reference is not supported");const i="polyline"===e.type?e.paths:e.rings,o=[],a=[0,0],c=new k;for(const t of i){const e=[];o.push(e),e.push([t[0][0],t[0][1]]);let i,r,p=t[0][0],h=t[0][1];for(let o=0;o<t.length-1;o++){if(i=t[o+1][0],r=t[o+1][1],p===i&&h===r)continue;const u=[p,h];R(c,[p,h],[i,r],n);const{azimuth:l,distance:m}=c,f=m/s;if(f>1){for(let t=1;t<=f-1;t++)v(a,u,l,t*s,n),e.push(a.slice());v(a,u,l,(m+Math.floor(f-1)*s)/2,n),e.push(a.slice())}v(a,u,l,m,n),e.push(a.slice()),p=a[0],h=a[1]}}const l=r(p,n);return"polyline"===e.type?new h({paths:o,spatialReference:l}):new u({rings:o,spatialReference:l})}class k{constructor(t=0,e=void 0,s=void 0){this.distance=t,this.azimuth=e,this.reverseAzimuth=s}}function v(t,e,s,n,i){const r=e[0],a=e[1],c=r*o,p=a*o,h=(s??0)*o,{a:u,b:l,f:m}=f(i),d=Math.sin(h),g=Math.cos(h),M=(1-m)*Math.tan(p),j=1/Math.sqrt(1+M*M),w=M*j,y=Math.atan2(M,g),k=j*d,v=k*k,R=1-v,b=R*(u*u-l*l)/(l*l),z=1+b/16384*(4096+b*(b*(320-175*b)-768)),U=b/1024*(256+b*(b*(74-47*b)-128));let x,q,S,A,N=n/(l*z),P=2*Math.PI;for(;Math.abs(N-P)>1e-12;)S=Math.cos(2*y+N),x=Math.sin(N),q=Math.cos(N),A=U*x*(S+U/4*(q*(2*S*S-1)-U/6*S*(4*x*x-3)*(4*S*S-3))),P=N,N=n/(l*z)+A;const O=w*x-j*q*g,B=Math.atan2(w*q+j*x*g,(1-m)*Math.sqrt(v+O*O)),E=Math.atan2(x*d,j*q-w*x*g),F=m/16*R*(4+m*(4-3*R)),G=B/o,C=(c+(E-(1-F)*m*k*(N+F*x*(S+F*q*(2*S*S-1)))))/o;return t[0]=C,t[1]=G,t}function R(t,e,s,n){const i=e[0]*o,r=e[1]*o,a=s[0]*o,c=s[1]*o,{a:p,b:h,f:u,radius:l}=f(n),m=a-i,d=Math.atan((1-u)*Math.tan(r)),g=Math.atan((1-u)*Math.tan(c)),M=Math.sin(d),j=Math.cos(d),w=Math.sin(g),y=Math.cos(g);let k,v,R,b,z,U,x,q,S,A,N=1e3,P=m;do{if(x=Math.sin(P),q=Math.cos(P),R=Math.sqrt(y*x*(y*x)+(j*w-M*y*q)*(j*w-M*y*q)),0===R)return t.distance=0,t.azimuth=void 0,t.reverseAzimuth=void 0,t;z=M*w+j*y*q,U=Math.atan2(R,z),S=j*y*x/R,v=1-S*S,b=z-2*M*w/v,isNaN(b)&&(b=0),A=u/16*v*(4+u*(4-3*v)),k=P,P=m+(1-A)*u*S*(U+A*R*(b+A*z*(2*b*b-1)))}while(Math.abs(P-k)>1e-12&&--N>0);if(0===N){const e=l,s=Math.acos(Math.sin(r)*Math.sin(c)+Math.cos(r)*Math.cos(c)*Math.cos(a-i))*e,n=a-i,p=Math.sin(n)*Math.cos(c),h=Math.cos(r)*Math.sin(c)-Math.sin(r)*Math.cos(c)*Math.cos(n),u=Math.atan2(p,h);return t.azimuth=u/o,t.distance=s,t.reverseAzimuth=void 0,t}const O=v*(p*p-h*h)/(h*h),B=O/1024*(256+O*(O*(74-47*O)-128)),E=h*(1+O/16384*(4096+O*(O*(320-175*O)-768)))*(U-B*R*(b+B/4*(z*(2*b*b-1)-B/6*b*(4*R*R-3)*(4*b*b-3)))),F=Math.atan2(y*Math.sin(P),j*w-M*y*Math.cos(P)),G=Math.atan2(j*Math.sin(P),j*w*Math.cos(P)-M*y);return t.azimuth=F/o,t.distance=E,t.reverseAzimuth=G/o,t}function b(e,i,r="meters"){if(!e||!i)throw new t("geodesic-distance:missing-parameters","one or both input parameters are missing");if(!e.spatialReference||!i.spatialReference)throw new t("geodesic-distance:invalid-parameters","one or both input points do not have a spatial reference");if(!n(e.spatialReference,i.spatialReference))throw new t("geodesic-distance:invalid-parameters","spatial references of input parameters do not match");const{spatialReference:o}=e;if(!M(o))throw new t("geodesic-distance:not-supported","input geometry spatial reference is not supported");if(e.x===i.x&&e.y===i.y)return new k(0,0,0);const a=new k;return R(a,[e.x,e.y],[i.x,i.y],o),a.distance=s(a.distance,"meters",r),a.azimuth=d(a.azimuth),a.reverseAzimuth=d(a.reverseAzimuth),a}function z(e,s,n){if(!e||null==s||null==n)throw new t("point-from-distance:missing-parameters","one or more input parameters are missing or undefined");if(n<0||n>360)throw new t("point-from-distance:-of-bounds","azimuth is restricted to angles between, and including, 0° to 360° degrees");if(!e.spatialReference)throw new t("point-from-distance:missing-spatial-reference","the input point must have a spatial reference");const{spatialReference:i}=e;if(!M(i))throw new t("geodesic-distance:not-supported","input geometry spatial reference is not supported");const r=[0,0];return v(r,[e.x,e.y],n,s,i),new l({x:r[0],y:r[1],spatialReference:i})}function U(t){return M(t)?t:i(t)?p.WGS84:null}export{k as InverseGeodeticSolverResult,v as directGeodeticSolver,j as geodesicAreas,U as geodesicCompatibleSpatialReference,y as geodesicDensify,b as geodesicDistance,w as geodesicLengths,R as inverseGeodeticSolver,M as isSupported,z as pointFromDistance};
