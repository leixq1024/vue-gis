/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{i as t}from"../../core/lang.js";import{X as s}from"../../chunks/unitUtils.js";import{G as i,y as e,b as o,a as n,bk as r,S as h,g as m,t as a,c,f}from"../../chunks/converterAPI.js";import{a as _,t as u,G as d,c as l,d as P,r as p,P as y,q as x,Q as b,R as g}from"../../chunks/Transformation2D.js";import"../../chunks/jsonMap.js";import"../../config.js";import"../../chunks/Logger.js";import"../../chunks/assets.js";import"../../request.js";import"../../kernel.js";import"../../core/urlUtils.js";import"../../core/Error.js";import"../../core/JSONSupport.js";import"../../chunks/tslib.es6.js";import"../../core/Accessor.js";import"../../core/Handles.js";import"../../chunks/maybe.js";import"../../core/accessorSupport/decorators/subclass.js";import"../../chunks/metadata.js";import"../../chunks/utils.js";import"../../chunks/handleUtils.js";import"../../chunks/tracking.js";import"../../chunks/ensureType.js";import"../../core/accessorSupport/decorators/property.js";import"../../chunks/ObservableBase.js";import"../../core/scheduling.js";import"../../core/promiseUtils.js";import"../../geometry.js";import"../Extent.js";import"../Geometry.js";import"../../chunks/reader.js";import"../SpatialReference.js";import"../../chunks/writer.js";import"../Point.js";import"../../core/accessorSupport/decorators/cast.js";import"../support/webMercatorUtils.js";import"../Multipoint.js";import"../../chunks/zmUtils.js";import"../Polygon.js";import"../../chunks/coordsUtils.js";import"../../chunks/Axis.js";import"../../chunks/extentUtils.js";import"../../chunks/boundsUtils.js";import"../../chunks/aaBoundingRect.js";import"../../chunks/mathUtils.js";import"../Polyline.js";import"../../chunks/typeUtils.js";import"../support/jsonUtils.js";const j=1.4142135623730951,M=.017453292519943295,C=256,k=1024;class A{static construct(t,s,i){const e=new A;return e.x=t.x,e.y=t.y,e.m_next=-1,e.m_prev=-1,e.z=s,e.m=i,e.type=0,e}clone(){const t=new A;return t.x=this.x,t.y=this.y,t.m_next=this.m_next,t.m_prev=this.m_prev,t.z=this.z,t.m=this.m,t.type=this.type,t}asPoint2D(){return new y(this.x,this.y)}}class E{constructor(t){this.m_distance=-1,this.m_tolerance=-1,this.m_miterLimit=10,this.m_joins=0,this.m_progressCounter=0,this.m_bUseZ=!1,this.m_bUseM=!1,this.m_srcPts=[],this.m_srcPtCount=0,this.m_offsetPts=[],this.m_offsetPtCount=0,this.m_a1=0,this.m_a2=0,this.m_progressTracker=t}constructOffset(){const t=this.m_inputGeometry.getGeometryType();if(t===d.enumLine)return this.offsetLine();if(t===d.enumEnvelope)return this.offsetEnvelope();if(l(t)){const t=new o;return t.addSegment(this.m_inputGeometry,!0),this.m_inputGeometry=t,this.constructOffset()}if(t===d.enumPolyline){const t=new o;return this.offsetMultiPath(t),t}if(t===d.enumPolygon){const t=new n;return this.offsetMultiPath(t),t}P("")}offsetLine(){const t=this.m_inputGeometry,s=t.getStartXY(),i=t.getEndXY(),e=new y;e.setSub(i,s),e.normalize(),e.leftPerpendicularThis(),e.scale(this.m_distance),s.addThis(e),i.addThis(e);const o=t.clone();return o.setStartXY(s),o.setEndXY(i),o}offsetEnvelope(){const t=this.m_inputGeometry;if(this.m_distance>0&&2!==this.m_joins){const s=new n;return s.addEnvelope(t,!1),this.m_inputGeometry=s,this.constructOffset()}const s=t.clone();return s.inflateCoords(this.m_distance,this.m_distance),s}progress(){}static buildPoint(t,s,i,e){e.x=t.x+s*Math.cos(i),e.y=t.y+s*Math.sin(i),e.type=t.type,e.z=t.z,e.m=t.m,e.m_next=-1,e.m_prev=-1}addPoint(t){this.m_offsetPts.push(t.clone()),this.m_offsetPtCount++}addPointEx(t,s){if(0===this.m_offsetPtCount)return void this.addPoint(t);const i=this.m_srcPtCount,e=this.m_srcPts[0===s?i-1:s-1],o=this.m_srcPts[s],n=E.dotSign(e,o,this.m_offsetPts[this.m_offsetPtCount-1],t);if(n>0)this.addPoint(t);else if(n<0)if(E.dotSign(e,o,o,this.m_offsetPts[this.m_offsetPtCount-1])>0){const o=new A;let n;n=0===s?i-2:1===s?i-1:s-2;const r=this.m_srcPts[n],h=Math.atan2(e.y-r.y,e.x-r.x);if(E.buildPoint(e,this.m_distance,h-p,o),this.m_offsetPts[this.m_offsetPtCount-1]=o,1===this.m_joins||2===this.m_joins){o.x=.5*(o.x+e.x),o.y=.5*(o.y+e.y),this.addPoint(o),E.buildPoint(e,this.m_distance,this.m_a1+p,o);const t=o.clone();t.x=.5*(t.x+e.x),t.y=.5*(t.y+e.y),t.type|=C,this.addPoint(t),this.addPoint(o)}else E.buildPoint(e,this.m_distance,this.m_a1+p,o),o.type|=C,this.addPoint(o);this.addPointEx(t,s)}else{const t=new A;if(E.buildPoint(o,this.m_distance,this.m_a1+p,t),this.addPoint(t),1===this.m_joins||2===this.m_joins){t.x=.5*(t.x+o.x),t.y=.5*(t.y+o.y),this.addPoint(t),E.buildPoint(o,this.m_distance,this.m_a2-p,t);const s=t.clone();s.x=.5*(s.x+o.x),s.y=.5*(s.y+o.y),s.type|=C,this.addPoint(s),this.addPoint(t)}else E.buildPoint(o,this.m_distance,this.m_a2-p,t),t.type|=C,this.addPoint(t)}}buildOffset(){const t=new A,s=this.m_srcPtCount;this.m_offsetPtCount=0;const i=.5*this.m_tolerance;let e=0,o=0;for(let n=0;n<s;n++){const r=this.m_srcPts[n],h=0===n?this.m_srcPts[s-1]:this.m_srcPts[n-1],m=n===s-1?this.m_srcPts[0]:this.m_srcPts[n+1];let a,c,f=0;{const t=h.x-r.x,s=h.y-r.y,i=m.x-r.x,_=m.y-r.y;a=Math.atan2(s,t),c=Math.atan2(_,i),this.m_a1=a,this.m_a2=c,0===n&&(e=a,o=c),f=y.orientationRobust(r.asPoint2D(),h.asPoint2D(),m.asPoint2D())}const _=c;if(c<a&&(c+=x),f*this.m_distance>0)if(1===this.m_joins||2===this.m_joins){E.buildPoint(r,this.m_distance,a+p,t),this.addPoint(t);const s=.001;t.x=r.x+(t.x-r.x)*s,t.y=r.y+(t.y-r.y)*s,this.addPoint(t),E.buildPoint(r,this.m_distance,c-p,t);const i=t.clone();i.x=r.x+(i.x-r.x)*s,i.y=r.y+(i.y-r.y)*s,i.type|=C,this.addPoint(i),this.addPoint(t)}else{const s=.5*(c-a),i=0===s?this.m_distance:this.m_distance/Math.abs(Math.sin(s));E.buildPoint(r,i,.5*(a+c),t),this.addPointEx(t,n)}else if(512&r.type){const s=1-i/Math.abs(this.m_distance);let e=1,o=this.m_distance<0?-Math.PI:Math.PI;if(s>-1&&s<1){let t=2*Math.acos(s);t<M&&(t=M),e=Math.trunc(Math.PI/t+1.5),e>1&&(o/=e)}e<=1&&(e=2,o/=2);let h=a+p;E.buildPoint(r,this.m_distance,h,t),0===n&&(t.type|=k),this.addPointEx(t,n);const m=this.m_distance/Math.cos(o/2);for(h+=o/2,E.buildPoint(r,m,h,t),t.type|=k,this.addPoint(t);--e>0;)h+=o,E.buildPoint(r,m,h,t),t.type|=k,this.addPoint(t);E.buildPoint(r,this.m_distance,c-p,t),t.type|=k,this.addPoint(t)}else if(1!==this.m_joins)if(0!==this.m_joins)if(2!==this.m_joins){let s;if(c=_,this.m_distance>0?(c>a&&(c-=x),s=a-c<p):(c<a&&(c+=x),s=c-a<p),s){const s=this.m_distance*j;let i;i=s<0?a+.25*Math.PI:a+3*Math.PI*.25,E.buildPoint(r,s,i,t),this.addPointEx(t,n),i=s<0?c-.25*Math.PI:c-3*Math.PI*.25,E.buildPoint(r,s,i,t),this.addPoint(t)}else{const s=.5*(c-a),i=this.m_distance/Math.abs(Math.sin(s));c<a&&(c+=x),E.buildPoint(r,i,(a+c)/2,t),this.addPointEx(t,n)}}else{const s=h.x-r.x,i=h.y-r.y,e=m.x-r.x,o=m.y-r.y,f=(s*e+i*o)/Math.sqrt(s*s+i*i)/Math.sqrt(e*e+o*o);if(f>1-1e-8){E.buildPoint(r,j*this.m_distance,c-.25*Math.PI,t),this.addPointEx(t,n),E.buildPoint(r,j*this.m_distance,c+.25*Math.PI,t),this.addPoint(t);continue}const _=Math.abs(this.m_distance/Math.sin(.5*Math.acos(f))),u=Math.abs(this.m_miterLimit*this.m_distance);if(_>u){const s=.5*(c-a),i=this.m_distance/Math.abs(Math.sin(s));E.buildPoint(r,i,.5*(a+c),t);const e=y.construct(t.x,t.y),o=y.construct(r.x,r.y),h=new y;h.setSub(e,o);const m=new y;m.scaleAddOther(u/h.length(),h,o);const f=Math.sqrt(_*_-this.m_distance*this.m_distance),d=(_-u)*Math.abs(this.m_distance)/f;this.m_distance>0?h.leftPerpendicularThis():h.rightPerpendicularThis(),h.scale(d/h.length());const l=new y;l.setAdd(m,h);const P=new y;P.setSub(m,h),t.x=l.x,t.y=l.y,this.addPointEx(t,n),t.x=P.x,t.y=P.y,this.addPoint(t);continue}const d=.5*(c-a),l=this.m_distance/Math.abs(Math.sin(d));E.buildPoint(r,l,.5*(a+c),t),this.addPointEx(t,n)}else{const s=1-i/Math.abs(this.m_distance);let e=1,o=c-p-(a+p);if(s>-1&&s<1){let t=2*Math.acos(s);t<M&&(t=M),e=Math.trunc(Math.abs(o)/t+1.5),e>1&&(o/=e)}const h=this.m_distance/Math.cos(.5*o);let m=a+p+.5*o;for(E.buildPoint(r,h,m,t),this.addPointEx(t,n);--e>0;)m+=o,E.buildPoint(r,h,m,t),this.addPoint(t)}else E.buildPoint(r,this.m_distance,a+p,t),this.addPointEx(t,n),E.buildPoint(r,this.m_distance,c-p,t),this.addPoint(t)}return this.m_a1=e,this.m_a2=o,this.addPointEx(this.m_offsetPts[0],0),this.m_offsetPts[0]=this.m_offsetPts[this.m_offsetPtCount-1].clone(),this.removeBadSegsFast()}removeBadSegsFast(){let t=!1;for(let t=0;t<this.m_offsetPtCount;t++){const s=this.m_offsetPts[t];s.m_next=t+1,s.m_prev=t-1}this.m_offsetPts[0].m_prev=this.m_offsetPtCount-2,this.m_offsetPts[this.m_offsetPtCount-2].m_next=0;let s=0;for(let i=0;i<this.m_offsetPtCount;i++)if(this.m_offsetPts[s].type&C){const i=this.deleteClosedSeg(s);if(-1===i){t=!0;break}s=i}else s=this.m_offsetPts[s].m_next;return!t&&(this.compressOffsetArray(s),!0)}deleteClosedSeg(t){const s=this.m_offsetPtCount-1;let i,e,o=t;for(let n=1;n<=s-2;n++){o=this.m_offsetPts[o].m_next,i=o,e=t;for(let t=1;t<=n;t++){if(e=this.m_offsetPts[e].m_prev,!(this.m_offsetPts[e].type&C||this.m_offsetPts[i].type&C)){const t=this.handleClosedIntersection(e,i);if(-1!==t)return t}i=this.m_offsetPts[i].m_prev}}return-1}handleClosedIntersection(t,s){const i=this.m_offsetPts[this.m_offsetPts[t].m_prev],e=this.m_offsetPts[t],o=this.m_offsetPts[this.m_offsetPts[s].m_prev],n=this.m_offsetPts[s];if(!this.sectGraphicRect(i,e,o,n))return-1;const r={pt:new A,bAtExistingPt:!1};if(((e.x-i.x)*(n.y-o.y)-(e.y-i.y)*(n.x-o.x))*this.m_distance<0&&this.findIntersection(i,e,o,n,r)&&!r.bAtExistingPt){const h=1e-8,m=Math.sqrt((e.x-i.x)*(e.x-i.x)+(e.y-i.y)*(e.y-i.y)),a=(e.x-i.x)/m,c=(e.y-i.y)/m,f=Math.sqrt((n.x-o.x)*(n.x-o.x)+(n.y-o.y)*(n.y-o.y)),_=(n.x-o.x)/f,u=(n.y-o.y)/f;let d=!1;const l=r.pt.clone();l.x+=(a+_)*h,l.y+=(c+u)*h;let P=o,p=r.pt,y=this.m_offsetPts[t].m_prev;for(;p.y>l.y!=P.y>l.y&&l.x<(P.x-p.x)*(l.y-p.y)/(P.y-p.y)+p.x&&(d=!d),P=p,y=this.m_offsetPts[y].m_next,y!==s;)p=this.m_offsetPts[y];if(d)return-1;const x=this.m_offsetPts[t].m_prev;return r.pt.type=e.type,r.pt.m_next=s,r.pt.m_prev=x,this.m_offsetPts[t]=r.pt,this.m_offsetPts[s].m_prev=t,s}return-1}sectGraphicRect(t,s,i,e){return Math.max(t.x,s.x)>=Math.min(i.x,e.x)&&Math.max(i.x,e.x)>=Math.min(t.x,s.x)&&Math.max(t.y,s.y)>=Math.min(i.y,e.y)&&Math.max(i.y,e.y)>=Math.min(t.y,s.y)}findIntersection(t,s,i,e,o){let n,r,h,m;return o.bAtExistingPt=!1,n=(s.y-t.y)*(e.x-i.x)-(s.x-t.x)*(e.y-i.y),r=(i.y-t.y)*(s.x-t.x)-(i.x-t.x)*(s.y-t.y),h=0===n?2:r/n,h>=0&&h<=1&&(m=h,n=(e.y-i.y)*(s.x-t.x)-(e.x-i.x)*(s.y-t.y),r=(t.y-i.y)*(e.x-i.x)-(t.x-i.x)*(e.y-i.y),h=0===n?2:r/n,h>=0&&h<=1)&&(o.pt.x=t.x+h*(s.x-t.x),o.pt.y=t.y+h*(s.y-t.y),this.m_bUseZ&&(o.pt.z=i.z+m*(e.z-i.z)),this.m_bUseM&&(o.pt.m=i.m+m*(e.m-i.m)),0!==m&&1!==m||0!==h&&1!==h||(o.bAtExistingPt=!0),!((0===m||1===m)&&h>0&&h<1||(0===h||1===h)&&m>0&&m<1))}compressOffsetArray(t){for(;this.m_offsetPts[t].m_prev<t;)t=this.m_offsetPts[t].m_prev;let s=0,i=t;do{const t=this.m_offsetPts[i].clone();this.m_offsetPts[s]=t,i=t.m_next,s++}while(i!==t);this.m_offsetPts[s]=this.m_offsetPts[0].clone(),this.m_offsetPtCount=s+1}addPart(t,s){if(!(s<2))for(let i=0;i<s;i++){const s=this.m_offsetPts[t+i];if(i?this.m_bUseZ?this.m_resultPath.lineTo3DCoords(s.x,s.y,s.z):this.m_resultPath.lineToCoords(s.x,s.y):this.m_bUseZ?this.m_resultPath.startPath3DCoords(s.x,s.y,s.z):this.m_resultPath.startPathCoords(s.x,s.y),this.m_bUseM){const t=this.m_resultPath.getPointCount()-1;this.m_resultPath.setAttribute(2,t,0,s.m)}}}offsetMultiPath(t){const s=r(this.m_inputGeometry,0,this.m_tolerance,0,this.m_progressTracker,12e3),i=s.querySegmentIterator();i.resetToFirstPath();let e=-1;for(;i.nextPath();)e++,this.offsetPath(s,e,t)}offsetPath(t,s,i){let e=t.getPathStart(s),o=t.getPathEnd(s);if(this.m_resultPath=i,t.isClosedPath(s)){const s=t.getXY(e);for(;o>e&&t.getXY(o-1).equals(s);)o--;if(o-e>=2){this.m_srcPtCount=o-e,this.m_srcPts.length=this.m_srcPtCount;for(let s=e;s<o;s++)this.progress(),this.m_srcPts[s-e]=A.construct(t.getXY(s),this.m_bUseZ?t.getAttributeAsDbl(1,s,0):0,this.m_bUseM?t.getAttributeAsDbl(2,s,0):0);this.buildOffset()&&this.addPart(0,this.m_offsetPtCount-1)}}else{const s=t.getXY(e);for(;e<o-1&&t.getXY(e+1).equals(s);)e++;const i=t.getXY(o-1);for(;e<o-1&&t.getXY(o-2).equals(i);)o--;if(o-e>=2){this.m_srcPtCount=2*(o-e)-2,this.m_srcPts.length=this.m_srcPtCount;let i=A.construct(s,this.m_bUseZ?t.getAttributeAsDbl(1,e,0):0,this.m_bUseM?t.getAttributeAsDbl(2,e,0):0);i.type|=1536,this.m_srcPts[0]=i;let n=1,r=this.m_srcPtCount-1;for(let s=e+1;s<o-1;s++,n++,r--)this.progress(),i=A.construct(t.getXY(s),this.m_bUseZ?t.getAttributeAsDbl(1,s,0):0,this.m_bUseM?t.getAttributeAsDbl(2,s,0):0),this.m_srcPts[n]=i.clone(),i.type|=k,this.m_srcPts[r]=i.clone();if(i=A.construct(t.getXY(o-1),this.m_bUseZ?t.getAttributeAsDbl(1,o-1,0):0,this.m_bUseM?t.getAttributeAsDbl(2,o-1,0):0),i.type|=512,this.m_srcPts[n]=i.clone(),this.buildOffset())if(this.m_offsetPts.length>=2){let t=-1,s=-1,i=!!(this.m_offsetPts[this.m_offsetPtCount-1].type&k);i||(t=0);for(let e=1;e<this.m_offsetPtCount;e++){this.progress();const o=!!(this.m_offsetPts[e].type&k);o?i||(s=e-1,s-t+1>1&&this.addPart(t,s-t+1)):i&&(t=e-1),i=o}i||(s=this.m_offsetPtCount-1,s-t+1>1&&this.addPart(t,s-t+1))}else{const t=0,s=this.m_offsetPtCount-1;s-t>=1&&this.addPart(t,s-t+1)}}}this.m_srcPts.length=0,this.m_srcPtCount=0,this.m_offsetPts.length=0,this.m_offsetPtCount=0}static dotSign(t,s,i,e){const o=s.x-t.x,n=s.y-t.y,r=e.x-i.x,h=e.y-i.y,m=b(o,n,r,h);return g(m)}}class U extends i{constructor(t,s,i,e,o,n,r){super(),this.m_progressTracker=r,this.m_index=-1,this.m_inputGeoms=t,this.m_spatialReference=s,this.m_distance=i,this.m_joins=e,this.m_miterLimit=o,this.m_flattenError=n}tock(){return!0}getRank(){return 1}next(){if(!this.m_inputGeoms)return null;let t;for(;t=this.m_inputGeoms.next();)return this.m_index=this.m_inputGeoms.getGeometryID(),this.offset(t);return null}getGeometryID(){return this.m_index}offset(t){let s;return _(t),s=this.m_flattenError<=0?e(this.m_spatialReference,t,!0).total():this.m_flattenError,function(t,s,i,e,o,n){if(null===t&&u(""),t.getDimension()<1&&u(""),o>0||u(""),_(t),0===s||t.isEmpty())return t;const r=new E(n);return r.m_bUseZ=t.hasAttribute(1),r.m_bUseM=t.hasAttribute(2),r.m_inputGeometry=t,r.m_distance=s,r.m_tolerance=o,r.m_joins=i,r.m_miterLimit=e,r.m_progressCounter=0,r.constructOffset()}(t,this.m_distance,this.m_joins,this.m_miterLimit,s,this.m_progressTracker)}}const v=new class{getOperatorType(){return 10108}accelerateGeometry(t,s,i){return!1}canAccelerateGeometry(t){return!1}supportsCurves(){return!0}executeMany(t,s,i,e,o,n,r){return new U(t,s,i,e,o,n,r)}execute(t,s,i,e,o,n,r){return new U(null,s,i,e,o,n,r).offset(t)}},w={round:0,bevel:1,miter:2,square:3};function G(t,i,e={}){const{miterLimit:o=10,flattenError:n=0,joins:r="round",unit:h}=e,_=m(t);return h&&(i=s(i,h,_)),a(function(t,s,i,e,o,n){return v.execute(t,s,i,e,o,n,null)}(f(t),c(_),i,w[r],o,n),_)}function S(i,e,o={}){const{miterLimit:n=10,flattenError:r=0,joins:_="round",unit:u}=o,d=i.map(f),l=m(i);return u&&(e=s(e,u,l)),function(t,s,i,e,o,n){const r=v.executeMany(new h(t),s,i,e,o,n,null);return Array.from(r)}(d,c(l),e,w[_],n,r).map((t=>a(t,l))).filter(t)}function D(){return v.supportsCurves()}export{G as execute,S as executeMany,D as supportsCurves};
