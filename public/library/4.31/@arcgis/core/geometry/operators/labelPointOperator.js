/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{G as e,P as t,p as n,h as s,a as r,bd as o,m as i,L as a,S as c,u,g as l,f as m}from"../../chunks/converterAPI.js";import{g as p,a as h,t as N,G as g,P as y,N as d,O as j,p as P}from"../../chunks/Transformation2D.js";import{a as x}from"../../chunks/Centroid-DZi-eb9F.js";import{O as b}from"../../chunks/OperatorProximity.js";import"../../chunks/tslib.es6.js";import"../../geometry.js";import"../../chunks/ensureType.js";import"../../core/lang.js";import"../../chunks/Logger.js";import"../../config.js";import"../Extent.js";import"../../core/accessorSupport/decorators/property.js";import"../../chunks/utils.js";import"../../chunks/handleUtils.js";import"../../chunks/metadata.js";import"../../core/Error.js";import"../../core/accessorSupport/decorators/subclass.js";import"../../chunks/tracking.js";import"../Geometry.js";import"../../core/JSONSupport.js";import"../../core/Accessor.js";import"../../core/Handles.js";import"../../chunks/maybe.js";import"../../chunks/ObservableBase.js";import"../../core/scheduling.js";import"../../core/promiseUtils.js";import"../../chunks/reader.js";import"../SpatialReference.js";import"../../chunks/unitUtils.js";import"../../chunks/jsonMap.js";import"../../chunks/assets.js";import"../../request.js";import"../../kernel.js";import"../../core/urlUtils.js";import"../../chunks/writer.js";import"../Point.js";import"../../core/accessorSupport/decorators/cast.js";import"../support/webMercatorUtils.js";import"../Multipoint.js";import"../../chunks/zmUtils.js";import"../Polygon.js";import"../../chunks/coordsUtils.js";import"../../chunks/Axis.js";import"../../chunks/extentUtils.js";import"../../chunks/boundsUtils.js";import"../../chunks/aaBoundingRect.js";import"../../chunks/mathUtils.js";import"../Polyline.js";import"../../chunks/typeUtils.js";import"../support/jsonUtils.js";import"../../chunks/SideCalculator2D-CsYV5zVZ.js";class f extends e{progress_(){}tock(){return p(0),!1}getRank(){return p(0),0}constructor(e,t){super(),this.m_index=-1,this.m_progressCounter=0,this.m_progressTracker=t,this.m_inputGeoms=e}next(){const e=this.m_inputGeoms.next();return e?(h(e),this.m_index=this.m_inputGeoms.getGeometryID(),this.labelPoint(e)):null}getGeometryID(){return this.m_index}labelPoint(e){if(null===e&&N("null pointer is not allowed"),e.getGeometryType()===g.enumPoint)return e;if(e.isEmpty())return new t({vd:e.getDescription()});switch(e.getGeometryType()){case g.enumPolygon:return this.labelPointPolygon(e);case g.enumPolyline:return this.labelPointPolyline(e);case g.enumMultiPoint:return this.labelPointMultiPoint(e);case g.enumEnvelope:return this.labelPointEnvelope(e);default:N("geometry is not supported")}}labelPointPolygon(e){const a=new n;e.queryEnvelope(a);const c=s(null,a,!0).total();let u=null,l=e;if(e.hasNonLinearSegments()){const t=new r({copy:e}),n=o(t,.25*c,c);p(n!==e),u=n,l=u}let m=0,h=0;for(let e=0,t=l.getPathCount();e<t;++e){const t=Math.abs(l.calculateRingArea2D(e));t>h&&(h=t,m=e)}const N=new y;if(Math.abs(h)<=2*c*c?N.setNAN():N.assign(x(l,m)),Number.isNaN(N.x)){const e=new n;return l.queryPathEnvelope(m,e),new t({pt:e.getCenter()})}if(l.getPointCount()<4)return new t({x:N.x,y:N.y});const g=y.getNAN(),P=[g.clone(),g.clone(),g.clone(),g.clone()],f=[Number.NaN,Number.NaN,Number.NaN,Number.NaN],w=[Number.NaN,Number.NaN,Number.NaN,Number.NaN];let k=!1,C=(new b).getNearestCoordinate(l,N,!0,!1);if(0===C.m_distance&&(k=!0,P[0]=N,C=(new b).getNearestCoordinate(l,N,!1,!1),C.m_distance>.25*a.minDimension()*1.66666666))return new t({x:N.x,y:N.y});f[0]=C.m_distance,w[0]=0;const _=new y;let D=!1,A=.25,E=-1;const S=new n;l.queryPathEnvelope(m,S);do{let e=Number.NaN;if(P[1]=this.calculateParacentroid_(l,d(S.xmin,S.xmax,A),c),P[1].isNAN()||(C=(new b).getNearestCoordinate(l,P[1],!1,!1),e=C.m_distance),e>c&&1===i(l,P[1],c))D=!0,f[1]=e,w[1]=y.sqrDistance(P[1],N);else if(e>E&&(E=e,_.setCoordsPoint2D(P[1])),A-=.01,A<.1){if(!(E>=0))break;D=!0,f[1]=E,P[1]=_,w[1]=y.sqrDistance(P[1],N)}}while(!D);D=!1,A=.5,E=-1;let M=.01,U=1;do{let e=Number.NaN;if(P[2]=this.calculateParacentroid_(l,d(S.xmin,S.xmax,A),c),P[2].isNAN()||(C=(new b).getNearestCoordinate(l,P[2],!1,!1),e=C.m_distance),e>c&&1===i(l,P[2],c))D=!0,f[2]=e,w[2]=y.sqrDistance(P[2],N);else if(e>E&&(E=e,_.setCoordsPoint2D(P[2])),A=.5+M*U,M+=.01,U*=-1,A<.3||A>.7){if(!(E>=0))break;D=!0,f[2]=E,P[2]=_,w[2]=y.sqrDistance(P[2],N)}}while(!D);D=!1,A=.75,E=-1;do{let e=Number.NaN;if(P[3]=this.calculateParacentroid_(l,d(S.xmin,S.xmax,A),c),P[3].isNAN()||(C=(new b).getNearestCoordinate(l,P[3],!1,!1),e=C.m_distance),e>c&&1===i(l,P[3],c))D=!0,f[3]=e,w[3]=y.sqrDistance(P[3],N);else if(e>E&&(E=e,_.setCoordsPoint2D(P[3])),A+=.01,A>.9){if(!(E>=0))break;D=!0,f[3]=E,P[3]=_,w[3]=y.sqrDistance(P[3],N)}}while(!D);const q=[0,1,2,3],v=k?0:1;for(let e=v;e<4;e++)for(let e=v;e<3;e++){const t=w[e],n=w[e+1];if(j(t,n)>0){const s=q[e];q[e]=q[e+1],q[e+1]=s,w[e]=n,w[e+1]=t}}let G=v,L=0,X=0;for(let e=v;e<4;e++){switch(e){case 0:X=2*f[q[e]];break;case 1:X=1.66666666*f[q[e]];break;case 2:X=1.33333333*f[q[e]];break;case 3:X=f[q[e]]}X>L&&(L=X,G=q[e])}return p(!P[G].isNAN()),new t({x:P[G].x,y:P[G].y})}labelPointPolyline(e){const n=new y;if(e.getPointCount()>2*e.getPathCount()){let t=-1,s=-Number.MAX_VALUE;for(let n=0,r=e.getPathCount();n<r;n++)if(e.getPathSize(n)>2){const r=e.calculatePathLength2D(n);r>s&&(s=r,t=n)}const r=e.getPathStart(t),o=e.getPathEnd(t),i=Math.trunc((r+o)/2);n.assign(e.getXY(i))}else{let t=-Number.MAX_VALUE;const s=e.querySegmentIterator();for(;s.nextPath();)if(s.hasNextSegment()){const e=s.nextSegment(),r=e.calculateLength2D();r>t&&(t=r,n.assign(e.getCoord2D(e.lengthToT(.5*r))))}}return new t({x:n.x,y:n.y})}labelPointMultiPoint(e){const s=new n;e.queryEnvelope(s);const r=s.getCenter(),o=(new b).getNearestCoordinate(e,r,!1,!1).m_coordinate;return new t({x:o.x,y:o.y})}labelPointEnvelope(e){const n=e.getCenterXY();return new t({x:n.x,y:n.y})}calculateParacentroid_(e,t,s){const r=new n;e.queryEnvelope(r);const o=new y(t,0);let i=Number.MAX_VALUE,c=Number.MAX_VALUE,u=!1,l=!1;const m=new a;m.setStartXYCoords(o.x,r.ymin-1),m.setEndXYCoords(o.x,r.ymax+1);const h=new n,N=new y,g=new y,d=P(y,2),j=e.querySegmentIterator();for(;j.nextPath();)for(;j.hasNextSegment();){const e=j.nextSegment();if(e.queryEnvelope(h),p(e.isMonotoneQuickAndDirty()),N.setCoordsPoint2D(m.getStartXY()),g.setCoordsPoint2D(m.getEndXY()),0===h.clipLine(N,g))continue;if(1!==m.intersect(e,d,null,null,s))continue;const t=d[0].y;i>c?t<i&&(i=t,u=!0):t<c&&(c=t,l=!0)}return u&&l?o.y=(i+c)/2:o.setNAN(),o}}const w=new class{getOperatorType(){return 10203}accelerateGeometry(e,t,n){return!1}canAccelerateGeometry(e){return!1}supportsCurves(){return!0}executeMany(e,t){return new f(e,t)}execute(e,t){return new f(null,t).labelPoint(e)}};function k(e){return u((t=m(e),w.execute(t,null)),l(e));var t}function C(e){const t=e.map(m),n=l(e);return function(e){const t=w.executeMany(new c(e),null);return Array.from(t)}(t).map((e=>u(e,n)))}function _(){return w.supportsCurves()}export{k as execute,C as executeMany,_ as supportsCurves};
