/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{g as t,a as e,G as s,t as r,z as n,c as o,e as i,E as u,s as c}from"../../chunks/Transformation2D.js";import{G as m,b5 as a,bf as l,P as p,aZ as h,r as g,b as d,bg as y,S as j,f as _,g as b,t as f}from"../../chunks/converterAPI.js";import"../../chunks/tslib.es6.js";import"../../geometry.js";import"../../chunks/ensureType.js";import"../../core/lang.js";import"../../chunks/Logger.js";import"../../config.js";import"../Extent.js";import"../../core/accessorSupport/decorators/property.js";import"../../chunks/utils.js";import"../../chunks/handleUtils.js";import"../../chunks/metadata.js";import"../../core/Error.js";import"../../core/accessorSupport/decorators/subclass.js";import"../../chunks/tracking.js";import"../Geometry.js";import"../../core/JSONSupport.js";import"../../core/Accessor.js";import"../../core/Handles.js";import"../../chunks/maybe.js";import"../../chunks/ObservableBase.js";import"../../core/scheduling.js";import"../../core/promiseUtils.js";import"../../chunks/reader.js";import"../SpatialReference.js";import"../../chunks/unitUtils.js";import"../../chunks/jsonMap.js";import"../../chunks/assets.js";import"../../request.js";import"../../kernel.js";import"../../core/urlUtils.js";import"../../chunks/writer.js";import"../Point.js";import"../../core/accessorSupport/decorators/cast.js";import"../support/webMercatorUtils.js";import"../Multipoint.js";import"../../chunks/zmUtils.js";import"../Polygon.js";import"../../chunks/coordsUtils.js";import"../../chunks/Axis.js";import"../../chunks/extentUtils.js";import"../../chunks/boundsUtils.js";import"../../chunks/aaBoundingRect.js";import"../../chunks/mathUtils.js";import"../Polyline.js";import"../../chunks/typeUtils.js";import"../support/jsonUtils.js";class w{constructor(t,e,s,n){this.m_interval=s,this.m_progressTracker=n,this.m_attribute=t,this.m_ord=e,(l.getComponentCount(this.m_attribute)<=e||e<0)&&r("LocateBetween: ordinate"),2===l.getInterpolation(this.m_attribute)&&r("LocateBetween: angular interpolation")}processGeometry(t){const e=t.getGeometryType();if(e===s.enumGeometryCollection)return this.processGeometryCollection(t);if(n(e)&&r("LocateBetween does not support Polygons and Envelopes."),t.isEmpty()||!t.hasAttribute(this.m_attribute))return new p({vd:t.getDescription()});if(o(e))return this.processSegment(t);switch(e){case s.enumPoint:return this.processPoint(t);case s.enumMultiPoint:return this.processMultiPoint(t);case s.enumPolyline:return this.processPolyline(t);default:i("LocateBetween")}}processPoint(t){const e=t.getAttributeAsDbl(this.m_attribute,this.m_ord);return this.m_interval.containsCoordinate(e)?new h({point:t}):new p({vd:t.getDescription()})}processMultiPoint(t){let e=null,s=-1;const r=t.getAttributeStreamRef(this.m_attribute),n=l.getComponentCount(this.m_attribute);for(let o=0,i=0,u=t.getPointCount();o<u;++o,i+=n){const n=r.readAsDbl(i);this.m_interval.containsCoordinate(n)?-1===s&&(s=o):s>=0&&(e||(e=new h({vd:t.getDescription()})),e.addPoints(t,s,o),s=-1)}return s>=0&&(e||(e=new h({vd:t.getDescription()})),e.addPoints(t,s,-1)),e||new p({vd:t.getDescription()})}processPolyline(t){const e=t.queryInterval(this.m_attribute,this.m_ord);if(this.m_interval.contains(e))return t;if(!this.m_interval.isIntersecting(e))return new p({vd:t.getDescription()});let r=null,n=null;const o=t.querySegmentIterator(),i=new g,u=new p,c=new p,m=new p;let a=!0,l=!1;for(;o.nextPath();)for(a=!0,l=!1;o.hasNextSegment();){const t=o.nextSegment(),e=[null],p=this.processSegmentHelper(t,i,e,u);if(p!==s.enumUnknown)if(p===s.enumPoint){if(!a&&(n.getPointByVal(n.getPointCount()-1,c),c.equals(u)))continue;if(a=!0,l&&(t.queryStart(c),u.equals(c)))continue;t.queryEnd(c),l=u.equals(c),r?r.add(u):r=new h({point:u})}else p===s.enumLine&&(l=!1,n||(n=new d),a&&(null===r||r.isEmpty()||(r.getPointByVal(r.getPointCount()-1,c),e[0].queryStart(u),c.equals(u)&&r.removePoint(r.getPointCount()-1))),n.addSegment(e[0],a),t.queryEnd(c),e[0].queryEnd(m),a=!c.equals(m));else a=!0,l=!1}if(null!==r&&r.isEmpty()&&(r=null),null!==r&&null!==n){const t=new y;return t.addGeometry(n),t.addGeometry(r),t}return null!==r?r:null!==n?n:new p({vd:t.getDescription()})}processSegment(e){return t(0),{}}processGeometryCollection(t){if(t.isEmpty()||!t.hasAttribute(this.m_attribute))return new p({vd:t.getDescription()});const e=a(t),s=new y;for(let t=e.next();null!==t;t=e.next()){const e=this.processGeometry(t);e.isEmpty()||s.addGeometry(e)}return s.isEmpty()?new p({vd:t.getDescription()}):s}processSegmentHelper(t,e,r,n){const o=t.getAttributeAsDbl(0,this.m_attribute,this.m_ord),i=t.getAttributeAsDbl(1,this.m_attribute,this.m_ord),m=Number.isNaN(o)?i:o,a=Number.isNaN(i)?o:i,l=new u;l.setCoords(m,a);const p=l.clone();if(p.intersect(this.m_interval),p.isEmpty())return s.enumUnknown;if(l.equals(p))return r[0]=t,s.enumLine;const h=a-m,g=t.calculateLength2D();if(0===p.width()){const e=(p.vmin-m)/h,r=1===e?1:t.lengthToT(e*g);return t.queryCoord(r,n),s.enumPoint}let d=(p.vmin-m)/h,y=(p.vmax-m)/h;return d>y&&(y=c(d,d=y)),d=1===d?1:t.lengthToT(d*g),y=1===y?1:t.lengthToT(y*g),t.queryCut(d,y,e),r[0]=e.get(),s.enumLine}}class k extends m{constructor(t,e,s){super(),this.m_collectionCursor=null,this.m_interval=e,this.m_progressTracker=s,this.m_inputGeoms=t,this.m_index=-1}tock(){return t(0),!1}getRank(){return t(0),0}next(){if(this.m_collectionCursor){const t=this.m_collectionCursor.next();if(t)return t;this.m_collectionCursor=null}const t=this.m_inputGeoms.next();if(null===t)return null;e(t),this.m_index=this.m_inputGeoms.getGeometryID();const r=(n=t,o=this.m_interval,i=this.m_progressTracker,new w(2,0,o,i).processGeometry(n));var n,o,i;return r.getGeometryType()===s.enumGeometryCollection?(this.m_collectionCursor=a(r),this.m_collectionCursor.next()):r}getGeometryID(){return this.m_index}}const v=new class{getOperatorType(){return 10801}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}supportsCurves(){return!0}executeMany(t,e,s){return new k(t,e,s)}};function P(t,e,s){const r=t.map(_),n=b(t);return function(t,e){const s=v.executeMany(new j(t),e,null);return Array.from(s)}(r,new u(e,s)).map((t=>f(t,n)))}function C(){return v.supportsCurves()}export{P as executeMany,C as supportsCurves};
