/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{V as t,n as e,g as s}from"../../chunks/unitUtils.js";import{G as r,bq as n,S as i,p as o,br as a,bs as u,bt as l,b as m,at as h,bu as c,E as p,a as _,P as g,y as f,bv as y,n as d,g as x,c as T,b2 as A,b0 as E}from"../../chunks/converterAPI.js";import{g as v,K as N,t as S,u as k,T as w,E as b,p as j,P as C,s as P,N as X}from"../../chunks/Transformation2D.js";import{O as H}from"../../chunks/OperatorMultiPartToSinglePart.js";import{O as Y}from"../../chunks/OperatorCut.js";import"../../core/lang.js";import"../../chunks/jsonMap.js";import"../../config.js";import"../../chunks/Logger.js";import"../../chunks/assets.js";import"../../request.js";import"../../kernel.js";import"../../core/urlUtils.js";import"../../core/Error.js";import"../../core/JSONSupport.js";import"../../chunks/tslib.es6.js";import"../../core/Accessor.js";import"../../core/Handles.js";import"../../chunks/maybe.js";import"../../core/accessorSupport/decorators/subclass.js";import"../../chunks/metadata.js";import"../../chunks/utils.js";import"../../chunks/handleUtils.js";import"../../chunks/tracking.js";import"../../chunks/ensureType.js";import"../../core/accessorSupport/decorators/property.js";import"../../chunks/ObservableBase.js";import"../../core/scheduling.js";import"../../core/promiseUtils.js";import"../../geometry.js";import"../Extent.js";import"../Geometry.js";import"../../chunks/reader.js";import"../SpatialReference.js";import"../../chunks/writer.js";import"../Point.js";import"../../core/accessorSupport/decorators/cast.js";import"../support/webMercatorUtils.js";import"../Multipoint.js";import"../../chunks/zmUtils.js";import"../Polygon.js";import"../../chunks/coordsUtils.js";import"../../chunks/Axis.js";import"../../chunks/extentUtils.js";import"../../chunks/boundsUtils.js";import"../../chunks/aaBoundingRect.js";import"../../chunks/mathUtils.js";import"../Polyline.js";import"../../chunks/typeUtils.js";import"../support/jsonUtils.js";function I(t,e,s,r,n){return new K(n).findSlicesByArea(t,e,s,r)}function q(t,e,s,r,n){return new K(n).sliceIntoStrips(t,e,s,r)}function O(t,e,s,r){return new K(r).recursiveSliceEqualArea(t,e,s)}function R(t){this.currentX=this.calcX(t)}function M(t){if(null===this.curve){const e=(t-this.y0)/(this.y1-this.y0);return X(this.x0,this.x1,e)}return this.curve.intersectionOfYMonotonicWithAxisX(t,this.x0)}function B(){return{x0:Number.NaN,y0:Number.NaN,x1:Number.NaN,y1:Number.NaN,currentX:Number.NaN,nextAET:null,prevAET:null,startNodeNext:null,nextInChain:null,curve:null,advance:R,calcX:M}}function D(t,e){const s=B();return s.x0=t.getStartX(),s.y0=t.getStartY(),s.x1=t.getEndX(),s.y1=t.getEndY(),e&&(s.y0=P(s.x0,s.x0=s.y0),s.y1=P(s.x1,s.x1=s.y1)),s.y1<s.y0&&(s.y1=P(s.y0,s.y0=s.y1),s.x1=P(s.x0,s.x0=s.x1)),s.currentX=Number.NaN,s.nextAET=null,s.prevAET=null,s.startNodeNext=null,s.nextInChain=null,s.curve=null,s}function V(t){const e=B();return e.x0=t.getStartX(),e.y0=t.getStartY(),e.x1=t.getEndX(),e.y1=t.getEndY(),e.curve=t,e.y1<e.y0&&(e.y1=P(e.y0,e.y0=e.y1),e.x1=P(e.x0,e.x0=e.x1)),e.currentX=Number.NaN,e.nextAET=null,e.prevAET=null,e.startNodeNext=null,e.nextInChain=null,e}function U(t){if(this.x===t.x&&this.y===t.y){const e=null!==this.endEdge,s=null!==t.startEdge;return e&&s?-1:1}return this.y!==t.y?this.y-t.y:this.x-t.x}function z(){return{x:Number.NaN,y:Number.NaN,startEdge:null,endEdge:null,compare:U}}function L(t,e){return{y:t,startingEdges:e}}class G{constructor(t,e,s,r,n,i){this.m_parent=t,this.m_y0=e,this.m_y1=s,this.m_t0=r,this.m_area=i}getMaxDerivative(){return 1}getValue(t,e){return 1===t?0:this.getArea(e)-this.m_area}getError(t){return v(0),0}getArea(t){const e=.5*(this.m_parent.m_sumBase-this.m_parent.m_sumA),s=this.m_y1-this.m_y0;let r=(this.m_parent.m_sumBase-e*(t+this.m_t0))*s*(t-this.m_t0),n=!1;for(let e=this.m_parent.m_AETHead;null!==e;e=e.nextAET)if(n=!n,n&&(null!==e.curve||null!==e.nextAET.curve)){const n=this.m_y0+s*this.m_t0,i=this.m_y0+s*t;e.curve&&(r+=W(e.curve,this.m_y0+s*this.m_t0,this.m_y0+s*t)),e.nextAET.curve&&(r-=W(e.nextAET.curve,this.m_y0+s*this.m_t0,this.m_y0+s*t)),r+=(i-n)*(e.nextAET.calcX(n)-e.calcX(n)+(e.nextAET.calcX(i)-e.calcX(i)))*.5}return r}}function F(t,e,s){return{polygon:t,from:e,to:s}}function W(t,e,s){const r=[0,0],n=t.intersectionWithAxis2D(!0,e,null,r);v(1===n);const i=r[0],o=t.intersectionWithAxis2D(!0,s,null,r);v(1===o);const a=r[0],u=j(C,4);y(t,u,!0);const l=u[3],m=u[2],h=u[1],c=t.getCoordX(i)-t.getStartX(),p=t.getCoordY(i)-t.getStartY(),_=t=>{const e=t*t;return e*t*(10*(m.x*h.y-m.y*h.x)-15*t*(l.y*h.x-l.x*h.y)+6*e*(m.y*l.x-l.y*m.x))/60},g=t=>(-t*(h.y+t*(m.y+l.y*t))*c+t*(h.x+t*(m.x+l.x*t))*p)/2;return _(a)-_(i)-(g(a)-g(i))}class J extends r{constructor(t){super(),this.m_geoms=[],this.m_index=-1,this.m_id=-1,this.m_geoms=t}tock(){return!0}getRank(){return 1}next(){return this.m_index++,this.m_index>=this.m_geoms.length?null:(this.m_id=this.m_geoms[this.m_index].second,this.m_geoms[this.m_index].first)}getGeometryID(){return this.m_id}}class K{constructor(t){this.m_edges=[],this.m_curves=[],this.m_sortedNodes=[],this.m_sortHelper=[],this.m_cuts=[],this.m_cutAreas=[],this.m_totalAreaOfTraps=new N(0),this.m_areaTracking=0,this.m_splitArea=0,this.m_sumBase=0,this.m_sumA=0,this.m_numberOfCuts=0,this.m_currentScan=0,this.m_progressCounter=0,this.m_AETHead=null,this.m_bHorizontalSweep=!1,this.m_bPolygonHasCurves=!1,this.m_progressTracker=t}findSlicesByArea(t,e,s,r){r<0&&S("remainingArea");let i=t,o=null;i.hasNonLinearSegments()&&(this.m_bPolygonHasCurves=!0,o=n(t,1e-16,!0),function(t){t.getImpl().ensureXYMonotoneSegments()}(o),i=o);const a=Math.abs(i.calculateArea2D());return 0===a||0===s||r>=a||1===s&&0===r?[]:(this.m_splitArea=(a-r)/s,this.m_numberOfCuts=s-1,r>0&&this.m_numberOfCuts++,this.m_edges.length=0,this.m_sortedNodes.length=0,this.m_cuts.length=0,this.m_areaTracking=0,this.m_totalAreaOfTraps.reset(),this.m_curves.length=0,this.buildEdges(i),this.buildScanNodes(),this.trapezoidation(),this.m_cuts)}sliceIntoStrips(t,e,s,r){if(0===r)return new i([t]);const n=new o;t.queryLooseEnvelope(n);const a=n.width()+n.height();return new J(this.splitPolygon(t,e,n.xmin-a-1+1,n.xmax+a+1,s,r))}recursiveSliceEqualArea(t,e,s){if(s<=1||t.isEmpty())return new i([t]);{const r=[],n=[];n.push(k(t.clone(),s));let i=0,a=0;for(;n.length>0;){v(a++<2*s);const t=n.at(-1);if(n.pop(),1===t.second){r.push(k(t.first,i++));continue}const u=new o;t.first.queryEnvelope(u);const l=u.width()+u.height(),m=new w;m.setIdentity(),u.width()>u.height()&&(m.setRotateCcw90(),t.first.applyTransformation(m),m.transformEnvInPlace(u));const h=t.first.calculateArea2D(),c=h/t.second,p=h-Math.trunc(t.second/2)*c,_=new K(this.m_progressTracker).findSlicesByArea(t.first,e,1,p),g=new K(this.m_progressTracker).splitPolygon(t.first,e,u.xmin-l-1+1,u.xmax+l+1,_,1),f=g.length;if(v(f>0&&f<=2),!m.isIdentity()){const t=new w;t.setRotateCw90(),g[0].first.applyTransformation(t),2===f&&g[1].first.applyTransformation(t)}2===f?(n.push(k(g[1].first,t.second-Math.trunc(t.second/2))),n.push(k(g[0].first,Math.trunc(t.second/2)))):n.push(k(g[0].first,t.second))}return new J(r)}}recursiveSliceEqualAreaImpl(t,e,s,r){return v(0),{}}processTraps(t,e,s){s?this.processTrapsCurves(t,e):this.processTrapsLinear(t,e)}processTrapsLinear(t,e){let s=0,r=1;const n=.5*(this.m_sumBase-this.m_sumA),i=e-t,o=(this.m_sumBase-n*(r+s))*i*(r-s);if(o+this.m_areaTracking<this.m_splitArea)return this.m_totalAreaOfTraps.pe(o),void(this.m_areaTracking+=o);const u=new N(o),l=new b(0,1);let m=!1;for(;s<1;){const e=this.m_splitArea-this.m_areaTracking,h=[Number.NaN,Number.NaN];if(!(a(-n*i,this.m_sumBase*i,(n*s-this.m_sumBase)*i*s-e,l,!1,h)>0)){m?this.m_areaTracking=u.getResult():this.m_areaTracking+=o;break}{m=!0,r=h[0],this.m_areaTracking=0,s=r,u.me(e);const n=r*i+t;if(this.m_cuts.push(n),this.m_cutAreas.push(this.m_totalAreaOfTraps.getResult()+o-u.getResult()),this.m_cuts.length===this.m_numberOfCuts)return void this.m_totalAreaOfTraps.pe(o-u.getResult())}}this.m_totalAreaOfTraps.pe(o)}processTrapsCurves(t,e){let s=0,r=1;const n=new G(this,t,e,0,1,0).getArea(1);if(n+this.m_areaTracking<this.m_splitArea)return this.m_totalAreaOfTraps.pe(n),void(this.m_areaTracking+=n);const i=e-t,o=new N(n);let a=!1;for(;s<1;){const l=this.m_splitArea-this.m_areaTracking,m=new G(this,t,e,s,1,l),h=[0],c=new b(s,1);if(!(u(m,c,1,h)>0)){a?this.m_areaTracking=o.getResult():this.m_areaTracking+=n;break}{a=!0,r=h[0],this.m_areaTracking=0,s=r,o.me(l);const e=r*i+t;if(this.m_cuts.push(e),this.m_cutAreas.push(this.m_totalAreaOfTraps.getResult()+n-o.getResult()),this.m_cuts.length===this.m_numberOfCuts)return void this.m_totalAreaOfTraps.pe(n-o.getResult())}}this.m_totalAreaOfTraps.pe(n)}advanceAET(){const t=this.m_sortedNodes[this.m_currentScan-1].y,e=this.m_sortedNodes[this.m_currentScan];let s=!1,r=!1;const n=new N(0);for(let t=this.m_AETHead;null!==t;t=t.nextAET){const i=t.prevAET;s=!s,null!==t.nextAET&&s&&(this.m_bPolygonHasCurves&&(t.curve||t.nextAET.curve)||n.pe(t.nextAET.currentX-t.currentX)),t.advance(e.y),null!==i&&t.currentX<i.currentX&&(r=!0)}this.m_sumBase=n.getResult(),r&&this.sortAET();const i=new N(0);s=!1;let o=!1;for(let t=this.m_AETHead;null!==t;t=t.nextAET)o=o||null!==t.curve,s=!s,null!==t.prevAET&&(s||this.m_bPolygonHasCurves&&(t.curve||t.prevAET.curve)||i.pe(t.currentX-t.prevAET.currentX));this.m_sumA=i.getResult(),this.processTraps(t,e.y,o);for(let t=this.m_AETHead;null!=t;){const s=t.prevAET,r=t.nextAET;if(e.y===t.y1)if(t.prevAET=null,t.nextAET=null,null!==t.nextInChain){const e=t.currentX;t=t.nextInChain,t.currentX=e,t.prevAET=s,s?s.nextAET=t:this.m_AETHead=t,t.nextAET=r,r&&(r.prevAET=t)}else s?s.nextAET=r:this.m_AETHead=r,r&&(r.prevAET=s);t=r}}mergeNewEdgesToAET(){for(let t=this.m_sortedNodes[this.m_currentScan].startingEdges;null!==t;t=t.startNodeNext)Number.isNaN(t.currentX)&&(this.m_sortHelper.push(t),t.currentX=t.x0);if(!this.m_sortHelper.length)return;this.sortHelper();let t=this.m_AETHead,e=0,s=t;for(;null!==t&&e<this.m_sortHelper.length;)t.currentX>this.m_sortHelper[e].currentX?(this.m_sortHelper[e].prevAET=t.prevAET,t.prevAET?t.prevAET.nextAET=this.m_sortHelper[e]:this.m_AETHead=this.m_sortHelper[e],this.m_sortHelper[e].nextAET=t,t.prevAET=this.m_sortHelper[e],e++):(s=t,t=t.nextAET);for(;e<this.m_sortHelper.length;)this.m_sortHelper[e].prevAET=s,null!==s?s.nextAET=this.m_sortHelper[e]:this.m_AETHead=this.m_sortHelper[e],this.m_sortHelper[e].nextAET=null,s=this.m_sortHelper[e],e++;this.m_sortHelper.length=0}sortAET(){for(let t=this.m_AETHead;null!==t;t=t.nextAET)this.m_sortHelper.push(t);this.sortHelper(),this.m_AETHead=null;let t=null;for(const e of this.m_sortHelper)e.prevAET=t,t?t.nextAET=e:this.m_AETHead=e,e.nextAET=null,t=e;this.m_sortHelper.length=0}sortHelper(){this.m_sortHelper.sort(((t,e)=>t.currentX-e.currentX))}trapezoidation(){for(this.m_currentScan=0,this.mergeNewEdgesToAET(),this.m_currentScan++;this.m_currentScan<this.m_sortedNodes.length&&(this.progress(),this.advanceAET(),this.m_cuts.length!==this.m_numberOfCuts);)this.mergeNewEdgesToAET(),this.m_currentScan++}buildEdges(t){const e=t.querySegmentIterator();for(e.stripAttributes();e.nextPath();)for(;e.hasNextSegment();){const t=e.nextSegment();if(t.isCurve()){const e=t;if(l(e),this.m_bHorizontalSweep){const t=j(C,4);e.queryControlPoints(t);for(const e of t)e.y=P(e.x,e.x=e.y);e.constructPoints(t)}const s=e.getStartY(),r=e.getEndY();if(r===s)continue;r<s&&e.reverse(),this.m_curves.push(e.clone()),this.m_edges.push(V(this.m_curves.at(-1)))}else{const e=this.m_bHorizontalSweep?t.getStartX():t.getStartY();if((this.m_bHorizontalSweep?t.getEndX():t.getEndY())===e)continue;this.m_edges.push(D(t,this.m_bHorizontalSweep))}}this.m_edges.sort(((t,e)=>t.y0===e.y0?t.x0-e.x0:t.y0-e.y0))}buildScanNodes(){const t=[];for(const e of this.m_edges){const s=z();s.x=e.x0,s.y=e.y0,s.startEdge=e,s.endEdge=null,t.push(s);const r=z();r.x=e.x1,r.y=e.y1,r.startEdge=null,r.endEdge=e,t.push(r)}t.sort(((t,e)=>t.compare(e)));let e=0,s=t[e].y;this.m_sortedNodes.push(L(s,t[e].startEdge));let r=e;for(e++;e!==t.length;++e){t[e].y!==s&&(this.m_sortedNodes.push(L(t[e].y,null)),s=t[e].y);const n=t[e].startEdge;if(n){const t=this.m_sortedNodes.at(-1);n.startNodeNext=t.startingEdges,t.startingEdges=n}if(t[r].x!==t[e].x||t[r].y!==t[e].y){if(e-r==2){let e=r;e++,null!==t[r].endEdge&&null!==t[e].startEdge&&(t[r].endEdge.nextInChain=t[e].startEdge)}r=e}}}progress(){}splitPolygonLinear(t,e,s,r,n,a){const u=[];u.push([t,0,a]);const l=[],h=new m;for(h.startPathCoords(s,0),h.lineToCoords(r,0);u.length>0;){const m=u.at(-1);u.pop();const c=m[0],p=m[1],_=m[2],g=(new H).executeMany(new i([c]),e,this.m_progressTracker);for(let i=g.next();null!==i;i=g.next()){const m=i,c=new o;m.queryLooseEnvelope(c);let g=p,f=_;for(let t=p,e=_-1;t<_;++t,--e)c.ymin>=n[t]&&(g=t+1),c.ymax<=n[e]&&(f=e);if(g!==_)if(f!==p)if(g!==f)if(this.isYMonotone(m))this.splitYMonotone(l,m,e,n,g,f);else{const i=Math.trunc((g+f)/2);h.setXYCoords(0,s,n[i]),h.setXYCoords(1,r,n[i]);const p=(new Y).execute(!1,m,h,null,this.m_progressTracker),_=p.next(),y=p.next(),d=p.next();if(null!==_){if(_.isEmpty()||(i===f-1?(l.push(k(_,i)),v(Q(l.at(-1).first,e,t,l.at(-1).second,n,a))):u.push([_,i+1,f])),y.isEmpty()||(i===g?(l.push(k(y,i-1)),v(Q(l.at(-1).first,e,t,l.at(-1).second,n,a))):u.push([y,g,i])),null!==d&&!d.isEmpty()){const t=new o;d.queryLooseEnvelope(t),t.ymin>=n[i]?u.push([d,i+1,f]):t.ymax<=n[i]?u.push([d,g,i]):u.push([d,g,f])}}else i+1===f?(n[i]-c.ymin<c.ymax-n[i]?l.push(k(m,i)):l.push(k(m,i+1)),v(Q(l.at(-1).first,e,t,l.at(-1).second,n,a))):u.push([m,i+1,f])}else l.push(k(i,g-1));else l.push(k(i,p-1));else l.push(k(i,_-1))}}return l}splitPolygon(t,e,s,r,n,i){const a=new o;t.queryLooseEnvelope(a),a.inflateCoords(0,Math.max(a.width(),a.height()));const u=[],l=[];for(l.push(F(t,0,i));l.length;){const i={...l.at(-1)};if(l.pop(),i.polygon.hasNonLinearSegments()){const t=Math.trunc((i.to+i.from)/2),m=n[t],c=new o(s,a.ymin,r,m),p=(new h).execute(i.polygon,c,e,this.m_progressTracker);p.isEmpty()||(t-i.from==0?u.push(k(p,t-1)):l.push(F(p,i.from,t)));const _=new o(s,m,r,a.ymax),g=(new h).execute(i.polygon,_,e,this.m_progressTracker);g.isEmpty()||(i.to-t==1?u.push(k(g,t)):l.push(F(g,t+1,i.to)))}else{const o=this.splitPolygonLinear(t,e,s,r,n.slice(i.from),i.to-i.from);u.push(...o)}}u.sort(((t,e)=>t.second-e.second));const m=[];return c(u,((t,e)=>t.second===e.second),((t,e)=>{const s=new _;for(let r=t;r!==e;++r)s.add(u[r].first,!1);m.push(k(s,u[t].second))})),m}isYMonotone(t){if(1!==t.getPathCount())return!1;const e=t.getXY(0);let s=0,r=0;const n=new C;for(let i=1,o=t.getPointCount();i<=o;i++){t.queryXY(i===o?0:i,n);const a=n.y>e.y?1:n.y<e.y?-1:0;if(e.setCoordsPoint2D(n),s!==a&&0!==a){if(0!==s&&(r++,r>2))return!1;s=a}}return!0}splitYMonotone(t,e,s,r,n,i){const o=new p;o.addGeometry(e);const a=o.getFirstPath(o.getFirstGeometry()),u=o.getFirstVertex(a),l=new C,m=new C;let h=u,c=u;{const t=o.getXY(u);l.setCoordsPoint2D(t),m.setCoordsPoint2D(t)}let _=o.getNextVertex(u);const g=new C;for(let t=0,e=o.getPathSize(a);t<e;t++,_=o.getNextVertex(_))o.queryXY(_,g),g.compare(l)<0?(h=_,l.setCoordsPoint2D(g)):g.compare(m)>0&&(c=_,m.setCoordsPoint2D(g));let f=h,y=h,x=f,T=y,A=!1,E=!1,N=n,S=l.y,w=l.y,b=!1;for(;N<i;)if(r[N]<=l.y)N++;else{if(r[N]>=m.y)break;if(!A){const t=o.getNextVertex(f),e=o.getY(t);if(e<S)break;const s=r[N];S<=s&&e>=s?A=!0:(S=e,f=t)}if(!E){const t=o.getPrevVertex(y),e=o.getY(t);if(e<w)break;const s=r[N];w<=s&&e>=s?E=!0:(w=e,y=t)}if(A&&E){b=!0;let e=o.getXY(f);const s=o.getNextVertex(f);let n=o.getXY(s),i=d;if(n.y===e.y)i=n.x<e.x?f:s;else{const t=(r[N]-e.y)/(n.y-e.y);if(0===t)i=f;else if(1===t)i=s;else{const e=o.splitSegmentAxisAware(f,[t],1,null,-1);v(1===e),i=o.getNextVertex(f),o.getY(i)!==r[N]&&o.setXYCoords(i,o.getX(i),r[N])}}const a=o.getPrevVertex(y);e=o.getXY(a),n=o.getXY(y);let u=d;if(n.y===e.y)u=n.x<e.x?y:a;else{const t=(r[N]-e.y)/(n.y-e.y);if(0===t)u=a;else if(1===t)u=y;else{const e=o.splitSegmentAxisAware(a,[t],1,null,-1);v(1===e),u=o.getNextVertex(a),o.getY(u)!==r[N]&&o.setXYCoords(u,o.getX(u),r[N])}}t.push(k(this.extractTrapezoid(o,x,i,T,u),N-1)),x=i,T=u,f=i,y=u,S=w=r[N],A=!1,E=!1,N++}}b?t.push(k(this.extractTrapezoid(o,x,c,T,c),N-1)):t.push(k(e,N))}extractTrapezoid(t,e,s,r,n){const i=new _({vd:t.getVertexDescription()}),o=new g;let a=!0;for(let r=e;;r=t.getNextVertex(r)){const e=t.getSegment(r);if(e?i.addSegment(e,a):(t.queryPoint(r,o),a?i.startPathPoint(o):i.lineToPoint(o)),a=!1,r===s)break}s!==n&&(t.queryPoint(n,o),i.lineToPoint(o)),a=!0;for(let s=n;;s=t.getNextVertex(s)){const n=t.getSegment(s);if(n?i.addSegment(n,a):a||s===e||(t.queryPoint(s,o),i.lineToPoint(o)),a=!1,s===r)break}return i}}function Q(t,e,s,r,n,i){const a=new o;t.queryEnvelope(a);const u=4*f(e,s,!0).total();return!(r>=0&&!(a.ymin+u>=n[r])||r+1<i&&a.ymax>n[r+1]+u)}class Z extends r{constructor(t,e,s,r,n,i,o){super(),this.m_resultCursor=null,this.m_method=t,this.m_polygon=e,this.m_sr=s,this.m_ySplits=r?.slice()??null,this.m_transform=n,this.m_bReversePaths=n?.isReflective()??!1,this.m_inverseTransform=n?n.clone().invertThis():null,this.m_partCount=i,this.m_tracker=o}tock(){return!0}getRank(){return 1}next(){this.m_resultCursor||(this.m_method?this.recursiveSliceEqualArea():this.sliceIntoStrips());const t=this.m_resultCursor.next();return t?(this.m_inverseTransform&&!this.m_inverseTransform.isIdentity()&&(t.applyTransformation(this.m_inverseTransform),this.m_bReversePaths&&t.reverseAllPaths()),t):t}getGeometryID(){return v(0),-1}sliceIntoStrips(){if(!this.m_transform||this.m_transform.isIdentity())this.m_resultCursor=q(this.m_polygon,this.m_sr,this.m_ySplits,this.m_ySplits.length,this.m_tracker);else{const t=this.m_polygon.clone();t.applyTransformation(this.m_transform),this.m_bReversePaths&&t.reverseAllPaths(),this.m_resultCursor=q(t,this.m_sr,this.m_ySplits,this.m_ySplits.length,this.m_tracker)}}recursiveSliceEqualArea(){if(!this.m_transform||this.m_transform.isIdentity())this.m_resultCursor=O(this.m_polygon,this.m_sr,this.m_partCount,this.m_tracker);else{const t=this.m_polygon.clone();t.applyTransformation(this.m_transform),this.m_bReversePaths&&t.reverseAllPaths(),this.m_resultCursor=O(t,this.m_sr,this.m_partCount,this.m_tracker)}}}const $=new class{getOperatorType(){return 10011}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}supportsCurves(){return!0}sliceIntoStrips(t,e,s,r,n,i){return new Z(0,t,e,s,n,0,i)}findSlicesByArea(t,e,s,r,n,i){if(!n||n.isIdentity())return I(t,e,s,r,i);{const o=t.clone();return o.applyTransformation(n),I(o,e,s,r,i)}}recursiveSliceEqualArea(t,e,s,r,n){return new Z(1,t,e,null,r,s,n)}};function tt(r,n,i,o={}){const{transform:a,unit:u}=o,l=x(r);if(i&&u){if(l.isGeographic)throw new Error("Unable to convert from an angular area unit to a linear area unit.");const r=t(l);r!==u&&(r?i=e(i,u,r):(i=e(i,u,"square-meters"),i=Math.sqrt(i),i/=s(l),i**=2))}return function(t,e,s,r,n){return $.findSlicesByArea(t,e,s,r,n,null)}(A(r),T(l),n,i,a?.transform??null)}function et(t,e,s={}){const{transform:r}=s,n=x(t);return function(t,e,s,r){const n=$.recursiveSliceEqualArea(t,e,s,r,null);return Array.from(n)}(A(t),T(n),e,r?.transform??null).map((t=>E(t,n)))}function st(t,e,s={}){const{transform:r}=s,n=x(t);return function(t,e,s,r){const n=$.sliceIntoStrips(t,e,s,0,r,null);return Array.from(n)}(A(t),T(n),e,r?.transform??null).map((t=>E(t,n)))}function rt(){return $.supportsCurves()}export{tt as findSlicesByArea,et as recursiveSliceEqualArea,st as sliceIntoStrips,rt as supportsCurves};
