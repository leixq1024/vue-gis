/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{t,C as e,G as s,d as r}from"../../chunks/Transformation2D.js";import{p as n,h as o,r as i,P as a,aK as m,aL as c,aM as p,g as u,aJ as g,c as l,aN as h}from"../../chunks/converterAPI.js";import"../../chunks/tslib.es6.js";import"../../geometry.js";import"../../chunks/ensureType.js";import"../../core/lang.js";import"../../chunks/Logger.js";import"../../config.js";import"../Extent.js";import"../../core/accessorSupport/decorators/property.js";import"../../chunks/utils.js";import"../../chunks/handleUtils.js";import"../../chunks/metadata.js";import"../../core/Error.js";import"../../core/accessorSupport/decorators/subclass.js";import"../../chunks/tracking.js";import"../Geometry.js";import"../../core/JSONSupport.js";import"../../core/Accessor.js";import"../../core/Handles.js";import"../../chunks/maybe.js";import"../../chunks/ObservableBase.js";import"../../core/scheduling.js";import"../../core/promiseUtils.js";import"../../chunks/reader.js";import"../SpatialReference.js";import"../../chunks/unitUtils.js";import"../../chunks/jsonMap.js";import"../../chunks/assets.js";import"../../request.js";import"../../kernel.js";import"../../core/urlUtils.js";import"../../chunks/writer.js";import"../Point.js";import"../../core/accessorSupport/decorators/cast.js";import"../support/webMercatorUtils.js";import"../Multipoint.js";import"../../chunks/zmUtils.js";import"../Polygon.js";import"../../chunks/coordsUtils.js";import"../../chunks/Axis.js";import"../../chunks/extentUtils.js";import"../../chunks/boundsUtils.js";import"../../chunks/aaBoundingRect.js";import"../../chunks/mathUtils.js";import"../Polyline.js";import"../../chunks/typeUtils.js";import"../support/jsonUtils.js";function d(t,e){return{m_path:t,m_pointIndex:e}}const j=new class{getOperatorType(){return 10007}supportsCurves(){return!1}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}execute(u,g,l,h,j){return function(u,g,l,h){if(u.isEmpty()||g.isEmpty())return null;if(8&h&&16&h)return null;2&h&&4&h&&t("");const j=new n,f=new n;return u.queryEnvelope(j),g.queryEnvelope(f),j.mergeEnvelope2D(f),function(t,n,o,u){e(t),e(n);let g,l=!1;const h=t.querySegmentIterator(),j=n.querySegmentIterator();let f=0;const y=new i,P=new a({vd:t.getDescription()}),S=new a({vd:t.getDescription()}),x=[],k=[];for(function(t,e,s){const r=[],n=[],o=t.querySegmentIterator();for(;o.nextPath();){o.resetToFirstSegment();const t=o.nextSegment().getStartXY(),e=o.getPathIndex(),s=o.getStartPointIndex();r.push(t),n.push(d(e,s)),o.resetToLastSegment();const i=o.previousSegment().getEndXY(),a=o.getPathIndex(),m=o.getEndPointIndex();r.push(i),n.push(d(a,m))}const i=new c(0);for(let t=0;t<r.length;t++)i.add(t);const a={userSort(t,e,s){s.sort(t,e,((t,e)=>r[t].compare(r[e])))},getValue:t=>r[t].y};(new p).sort(i,0,i.size(),a);for(let t=0;t<i.size()-1;t++){const e=r[i.read(t)];if(e.equals(r[i.read(t+1)])){do{const e=n[i.read(t)];s.push(e),t++}while(t<i.size()&&e.equals(r[i.read(t)]));t--}}e.length=s.length;for(let t=0;t<s.length;t++)e[t]=t;e.sort(((t,e)=>{const r=s[t],n=s[e];return r.m_path<n.m_path?-1:r.m_path>n.m_path?1:r.m_pointIndex<n.m_pointIndex?-1:1}))}(t,x,k);h.nextPath();){let e=!0,n=0;for(;2!==n;){if(0===n)h.nextSegment().getGeometryType()!==s.enumLine&&r(""),n++;else{if(h.resetToLastSegment(),h.previousSegment().getGeometryType()!==s.enumLine&&r(""),l&&e){const s=h.getPathIndex();g.addSegmentsFromPath(t,s,0,t.getSegmentCountPath(s),!0),e=!1}n++}let i=!1;if(f<k.length){const t=k[x[f]],e=h.getPathIndex();if(t.m_path===e){const e=1===n?h.getStartPointIndex():h.getEndPointIndex();t.m_pointIndex===e&&(i=!0,f++)}}if(1===n){if(8&u)continue}else if(16&u)continue;if(!i){1===n?h.previousSegment():h.nextSegment();const i=1===n?h.nextSegment():h.previousSegment(),a=i,c=a.calculateLength2D();j.resetToFirstPath();let p=!1,d=Number.NaN;for(;j.nextPath();){for(;j.hasNextSegment();){const t=j.nextSegment();t.getGeometryType()!==s.enumLine&&r("");const e=t,{bIntersect:i,t1:u,t2:g}=m(a,e);if(i){const t=e.calculateLength2D();if(g*t>=-o&&(1-g)*t>=-o)if(1===n){if(u*c<=-o)(Number.isNaN(d)||u>d)&&(d=u);else if(u*c<=o){d=Number.NaN,p=!0;break}}else if((1-u)*c<=-o)(Number.isNaN(d)||u<d)&&(d=u);else if((1-u)*c<=o){d=Number.NaN,p=!0;break}}}if(p)break}if(!Number.isNaN(d)){if(!l){g=t.createInstance();for(let e=0;e<h.getPathIndex();e++)g.addPath(t,e,!0)}if(1===n){i.queryCoord(d,P);const s=h.getPathIndex();if(2&u?t.getPointByVal(t.getPathStart(s),S):4&u&&S.setEmpty(),1&u||(y.create(i.getGeometryType()),i.copyTo(y.get()),y.get().setEnd(P),y.get().reverse(),g.addSegment(y.get(),!0),e=!1),g.addSegmentsFromPath(t,s,0,t.getSegmentCountPath(s),e),1&u){const t=g.getPathStart(s);g.setPointByVal(t,P)}if(2&u||4&u){const t=g.getPathStart(s),e=P.getXY();S.setXY(e),g.setPointByVal(t,S)}l=!0,e=!1}else{const s=h.getPathIndex();if(e&&(g.addSegmentsFromPath(t,s,0,t.getSegmentCountPath(s),!0),e=!1),2&u?t.getPointByVal(t.getPathEnd(s)-1,S):4&u&&S.setEmpty(),i.queryCoord(d,P),1&u){const t=g.getPathEnd(s);g.setPointByVal(t-1,P)}else y.create(i.getGeometryType()),i.copyTo(y.get()),y.get().setEnd(P),g.addSegment(y.get(),!1);if(2&u||4&u){const t=g.getPathEnd(s),e=P.getXY();S.setXY(e),g.setPointByVal(t-1,S)}l=!0}}}}}return l?g:null}(u,g,o(l,j,!0).total(),h)}(u,g,l,h)}};function f(t,e,s){let r=0;s&&(s.relocateEnds&&(r|=1),s.keepEndAttributes&&(r|=2),s.noEndAttributes&&(r|=4),s.noExtendAtFrom&&(r|=8),s.noExtendAtTo&&(r|=16));const n=u(t),o=j.execute(g(t),g(e),l(n),r,null);return o?h(o,n):null}function y(){return j.supportsCurves()}export{f as execute,y as supportsCurves};
