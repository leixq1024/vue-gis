/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{d as e,C as t,G as s,e as r}from"../../chunks/Transformation2D.js";import{p as n,h as a,b as i,r as o,P as m,a as c,w as h,g as l,f as u,aJ as p,c as g,t as d}from"../../chunks/converterAPI.js";import"../../chunks/tslib.es6.js";import"../../geometry.js";import"../../chunks/ensureType.js";import"../../core/lang.js";import"../../chunks/Logger.js";import"../../config.js";import"../Extent.js";import"../../core/accessorSupport/decorators/property.js";import"../../chunks/utils.js";import"../../chunks/handleUtils.js";import"../../chunks/metadata.js";import"../../core/Error.js";import"../../core/accessorSupport/decorators/subclass.js";import"../../chunks/tracking.js";import"../Geometry.js";import"../../core/JSONSupport.js";import"../../core/Accessor.js";import"../../core/Handles.js";import"../../chunks/maybe.js";import"../../chunks/ObservableBase.js";import"../../core/scheduling.js";import"../../core/promiseUtils.js";import"../../chunks/reader.js";import"../SpatialReference.js";import"../../chunks/unitUtils.js";import"../../chunks/jsonMap.js";import"../../chunks/assets.js";import"../../request.js";import"../../kernel.js";import"../../core/urlUtils.js";import"../../chunks/writer.js";import"../Point.js";import"../../core/accessorSupport/decorators/cast.js";import"../support/webMercatorUtils.js";import"../Multipoint.js";import"../../chunks/zmUtils.js";import"../Polygon.js";import"../../chunks/coordsUtils.js";import"../../chunks/Axis.js";import"../../chunks/extentUtils.js";import"../../chunks/boundsUtils.js";import"../../chunks/aaBoundingRect.js";import"../../chunks/mathUtils.js";import"../Polyline.js";import"../../chunks/typeUtils.js";import"../support/jsonUtils.js";class _{constructor(e){this.m_progressTracker=e,this.clearIndicesAndScalars()}setIndicesAndScalars(e,t,r){const a=new n,i=new n;if(e.queryEnvelope(a),e.queryEnvelope(i),a.inflateCoords(r,r),!a.intersect(i))return!1;const o=e.getImpl().querySegmentIterator(),m=t.getImpl().querySegmentIterator(),c=[0,0],h=[0,0];let l=-1,u=-1,p=-1,g=-1,d=-1,_=-1,x=Number.NaN,A=Number.NaN,S=Number.NaN,y=Number.NaN;for(m.nextPath();m.hasNextSegment();){const e=m.nextSegment(),t=new n;for(e.queryEnvelope(t),t.inflateCoords(r,r),o.resetToFirstPath();o.nextPath();){for(;o.hasNextSegment();){const s=o.nextSegment(),a=new n;if(s.queryEnvelope(a),t.isIntersecting(a)&&0!==e.intersect(s,null,h,c,r)&&(Number.isNaN(S)||h[0]<S)&&(l=o.getPathIndex(),p=o.getStartPointIndex(),d=m.getStartPointIndex(),x=c[0],S=h[0],0===S))break}if(0===S)break}if(!Number.isNaN(S)&&1!==S)break}if(Number.isNaN(S))return!1;this.m_pathA0=l,this.m_vertexA0=p,this.m_vertexB0=d,this.m_scalarA0=x,this.m_scalarB0=S;const P=e.getGeometryType();for(m.resetToLastSegment();m.hasPreviousSegment();){const e=m.previousSegment(),t=new n;for(e.queryEnvelope(t),t.inflateCoords(r,r),P===s.enumPolygon?o.resetToPath(l):o.resetToFirstPath();o.nextPath();){for(;o.hasNextSegment();){const s=o.nextSegment(),a=new n;if(s.queryEnvelope(a),t.isIntersecting(a)){const t=e.intersect(s,null,h,c,r);if(0!==t&&(Number.isNaN(y)||h[t-1]>y)&&(m.getStartPointIndex()!==this.m_vertexB0||h[t-1]!==this.m_scalarB0)&&(u=o.getPathIndex(),g=o.getStartPointIndex(),_=m.getStartPointIndex(),A=c[t-1],y=h[t-1],1===y))break}}if(1===y)break;if(P===s.enumPolygon)break}if(!Number.isNaN(y))break}return!Number.isNaN(y)&&(this.m_pathA1=u,this.m_vertexA1=g,this.m_vertexB1=_,this.m_scalarA1=A,this.m_scalarB1=y,!0)}getTrimmedPolyline(e,t){const s=new o,r=t.createInstance();let n=!0;const a=t.getImpl().querySegmentIterator();if(a.resetToVertex(this.m_vertexB0,0),this.m_vertexB0>this.m_vertexB1)return r;if(this.m_vertexB0===this.m_vertexB1)a.nextSegment().queryCut(this.m_scalarB0,this.m_scalarB1,s,!1),r.addSegment(s.get(),!0);else for(;;){const e=a.nextSegment(),t=a.getStartPointIndex();if(t===this.m_vertexB0)1!==this.m_scalarB0&&(e.queryCut(this.m_scalarB0,1,s,!1),r.addSegment(s.get(),n),n=!1);else{if(t===this.m_vertexB1){0!==this.m_scalarB1&&(e.queryCut(0,this.m_scalarB1,s),r.addSegment(s.get(),n),n=!1);break}r.addSegment(e,n)}}if(r.isEmpty())return r;if(e.getDescription().getAttributeCount()>1){const t=e.getImpl().querySegmentIterator(),s=new m,n=r.getPointCount();t.resetToVertex(this.m_vertexA0,this.m_pathA0),t.nextSegment().queryCoord(this.m_scalarA0,s),r.setPointByVal(0,s),t.resetToVertex(this.m_vertexA1,this.m_pathA1),t.nextSegment().queryCoord(this.m_scalarA1,s),r.setPointByVal(n-1,s),r.interpolateAttributesRange(0,0,0,n-1)}return r}getReshapedMultiPath(e,t,r){let n;return n=e.getGeometryType()===s.enumPolygon?this.getReshapedPolygon(e,t,r):this.getReshapedPolyline(e,t),n}getReshapedPolygon(e,t,s){const r=e.getImpl().querySegmentIterator();r.setCirculator(!0);const n=new o;new m;const a=new c({vd:e.getDescription()});if(a.addSegmentsFromPath(t,0,0,t.getSegmentCountPath(0),!0),r.resetToVertex(this.m_vertexA1,this.m_pathA0),this.m_vertexA1===this.m_vertexA0&&this.m_scalarA1<=this.m_scalarA0)r.nextSegment().queryCut(this.m_scalarA1,this.m_scalarA0,n),a.addSegment(n.get(),!1);else{{const e=r.nextSegment();1!==this.m_scalarA1&&(e.queryCut(this.m_scalarA1,1,n),a.addSegment(n.get(),!1))}for(;;){const e=r.nextSegment();if(r.getStartPointIndex()===this.m_vertexA0){0!==this.m_scalarA0&&(e.queryCut(0,this.m_scalarA0,n),a.addSegment(n.get(),!1));break}a.addSegment(e,!1)}}const i=new c({vd:e.getDescription()}),l=t.clone();if(l.reversePath(0),i.addSegmentsFromPath(l,0,0,l.getSegmentCountPath(0),!0),r.resetToVertex(this.m_vertexA0,this.m_pathA0),this.m_vertexA0===this.m_vertexA1&&this.m_scalarA0<this.m_scalarA1)r.nextSegment().queryCut(this.m_scalarA0,this.m_scalarA1,n),i.addSegment(n.get(),!1);else{{const e=r.nextSegment();1!==this.m_scalarA0&&(e.queryCut(this.m_scalarA0,1,n),i.addSegment(n.get(),!1))}for(;;){const e=r.nextSegment();if(r.getStartPointIndex()===this.m_vertexA1){0!==this.m_scalarA1&&(e.queryCut(0,this.m_scalarA1,n),i.addSegment(n.get(),!1));break}i.addSegment(e,!1)}}const u=Math.abs(a.calculateArea2D()),p=Math.abs(i.calculateArea2D());let g=e.createInstance();for(let t=0;t<e.getPathCount();t++)t===this.m_pathA0?u>=p?g.add(a,!1):g.add(i,!1):g.addPath(e,t,!0);return g=(new h).execute(g,s,!1,this.m_progressTracker),g}getReshapedPolyline(e,t){const s=e.getImpl().querySegmentIterator(),n=new i,a=new o;let m=!1,c=-1,h=Number.NaN;m=this.m_pathA0>this.m_pathA1||this.m_pathA0===this.m_pathA1&&(this.m_vertexA0>this.m_vertexA1||this.m_vertexA0===this.m_vertexA1&&this.m_scalarA0>this.m_scalarA1),m?(c=this.m_vertexA1,h=this.m_scalarA1,s.resetToPath(this.m_pathA1)):(c=this.m_vertexA0,h=this.m_scalarA0,s.resetToPath(this.m_pathA0));let l=!0;for(s.nextPath()||r("reshaper");;){const e=s.nextSegment();if(s.getStartPointIndex()===c){0!==h&&(e.queryCut(0,h,a),n.addSegment(a.get(),l),l=!1);break}n.addSegment(e,l),l=!1}if(m){const e=t.clone();e.reversePath(0),n.addSegmentsFromPath(e,0,0,e.getSegmentCount(),l)}else n.addSegmentsFromPath(t,0,0,t.getSegmentCount(),l);m?(h=this.m_scalarA0,s.resetToVertex(this.m_vertexA0,this.m_pathA0)):(h=this.m_scalarA1,s.resetToVertex(this.m_vertexA1,this.m_pathA1));{const e=s.nextSegment();1!==h&&(e.queryCut(h,1,a),n.addSegment(a.get(),!1))}for(;s.hasNextSegment();){const e=s.nextSegment();n.addSegment(e,!1)}const u=e.createInstance();let p=!1;for(let t=0;t<e.getPathCount();t++)t===this.m_pathA0||t===this.m_pathA1?p||(u.add(n,!1),p=!0):u.addPath(e,t,!0);return u}clearIndicesAndScalars(){this.m_pathA0=-1,this.m_pathA1=-1,this.m_vertexA0=-1,this.m_vertexA1=-1,this.m_vertexB0=-1,this.m_vertexB1=-1,this.m_scalarA0=Number.NaN,this.m_scalarA1=Number.NaN,this.m_scalarB0=Number.NaN,this.m_scalarB1=Number.NaN}}const x=new class{getOperatorType(){return 10006}accelerateGeometry(e,t,s){return!1}canAccelerateGeometry(e){return!1}supportsCurves(){return!1}execute(r,o,m,c){return function(r,o,m,c){if(o.getPathCount()>1&&e(""),r.isEmpty()||o.isEmpty())return null;t(r),t(o);let h=null;const l=new n;r.queryEnvelope(l);const u=new n;o.queryEnvelope(u);const p=new n;p.setCoords({env2D:l}),p.mergeEnvelope2D(u);const g=a(m,p,!1).total(),d=new _(c);let x=d.setIndicesAndScalars(r,o,g);if(x){const e=d.getTrimmedPolyline(r,o);if(e.isEmpty())return null;h=d.getReshapedMultiPath(r,e,m)}else{if(Number.isNaN(d.m_scalarB0)||r.getGeometryType()===s.enumPolyline)return null;const e=new i;if(e.add(o,!0),d.clearIndicesAndScalars(),x=d.setIndicesAndScalars(r,e,g),!x)return null;const t=d.getTrimmedPolyline(r,e);if(t.isEmpty())return null;h=d.getReshapedMultiPath(r,t,m)}return h}(r,o,m,c)}};function A(e,t){const s=l(e),r=x.execute(u(e),p(t),g(s),null);return d(r,s)}function S(){return x.supportsCurves()}export{A as execute,S as supportsCurves};
