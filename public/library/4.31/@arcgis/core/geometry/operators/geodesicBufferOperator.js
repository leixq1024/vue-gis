/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{i as s}from"../../core/lang.js";import{J as r,H as t,ad as o,n as e}from"../../chunks/unitUtils.js";import{aO as i,S as n,g as c,t as p,c as m,f as u}from"../../chunks/converterAPI.js";import"../../chunks/Transformation2D.js";import{g as a}from"../../chunks/geodeticCurveType.js";import"../../chunks/jsonMap.js";import"../../config.js";import"../../chunks/Logger.js";import"../../chunks/assets.js";import"../../request.js";import"../../kernel.js";import"../../core/urlUtils.js";import"../../core/Error.js";import"../../core/JSONSupport.js";import"../../chunks/tslib.es6.js";import"../../core/Accessor.js";import"../../core/Handles.js";import"../../chunks/maybe.js";import"../../core/accessorSupport/decorators/subclass.js";import"../../chunks/metadata.js";import"../../chunks/utils.js";import"../../chunks/handleUtils.js";import"../../chunks/tracking.js";import"../../chunks/ensureType.js";import"../../core/accessorSupport/decorators/property.js";import"../../chunks/ObservableBase.js";import"../../core/scheduling.js";import"../../core/promiseUtils.js";import"../../geometry.js";import"../Extent.js";import"../Geometry.js";import"../../chunks/reader.js";import"../SpatialReference.js";import"../../chunks/writer.js";import"../Point.js";import"../../core/accessorSupport/decorators/cast.js";import"../support/webMercatorUtils.js";import"../Multipoint.js";import"../../chunks/zmUtils.js";import"../Polygon.js";import"../../chunks/coordsUtils.js";import"../../chunks/Axis.js";import"../../chunks/extentUtils.js";import"../../chunks/boundsUtils.js";import"../../chunks/aaBoundingRect.js";import"../../chunks/mathUtils.js";import"../Polyline.js";import"../../chunks/typeUtils.js";import"../support/jsonUtils.js";let j;function l(){return!!j&&t()}function h(){return l()}function k(){return async function(){if(!l()){const[s]=await Promise.all([import("../../chunks/OperatorGeodesicBuffer.js"),r()]);j=new s.OperatorGeodesicBuffer,i(o)}}()}function f(s,r,t={}){let{curveType:o="geodesic",maxDeviation:i=NaN,unit:n}=t;n&&(r=e(r,n,"meters"),i&&(i=e(i,n,"meters")));const l=c(s);return p(function(s,r,t,o,e){return j.execute(s,r,t,o,e,!1,null)}(u(s),m(l),a[o],r,i),l)}function d(r,t,o={}){let{curveType:i="geodesic",maxDeviation:l=NaN,union:h=!1,unit:k}=o;k&&(t=t.map((s=>e(s,k,"meters"))),l&&(l=e(l,k,"meters")));const f=r.map(u),d=c(r);return function(s,r,t,o,e,i){const c=j.executeMany(new n(s),r,t,o,e,!1,i,null);return Array.from(c)}(f,m(d),a[i],t,l,h).map((s=>p(s,d))).filter(s)}function g(){return j.supportsCurves()}export{f as execute,d as executeMany,h as isLoaded,k as load,g as supportsCurves};
