/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{aF as t,b3 as e,G as r,b4 as n,P as o,b as s,p as i,a as u,b5 as m,b6 as c,S as a,g as p,t as l,f as g}from"../../chunks/converterAPI.js";import{C as y,a as j,G as h,c as f,t as x}from"../../chunks/Transformation2D.js";import"../../chunks/tslib.es6.js";import"../../geometry.js";import"../../chunks/ensureType.js";import"../../core/lang.js";import"../../chunks/Logger.js";import"../../config.js";import"../Extent.js";import"../../core/accessorSupport/decorators/property.js";import"../../chunks/utils.js";import"../../chunks/handleUtils.js";import"../../chunks/metadata.js";import"../../core/Error.js";import"../../core/accessorSupport/decorators/subclass.js";import"../../chunks/tracking.js";import"../Geometry.js";import"../../core/JSONSupport.js";import"../../core/Accessor.js";import"../../core/Handles.js";import"../../chunks/maybe.js";import"../../chunks/ObservableBase.js";import"../../core/scheduling.js";import"../../core/promiseUtils.js";import"../../chunks/reader.js";import"../SpatialReference.js";import"../../chunks/unitUtils.js";import"../../chunks/jsonMap.js";import"../../chunks/assets.js";import"../../request.js";import"../../kernel.js";import"../../core/urlUtils.js";import"../../chunks/writer.js";import"../Point.js";import"../../core/accessorSupport/decorators/cast.js";import"../support/webMercatorUtils.js";import"../Multipoint.js";import"../../chunks/zmUtils.js";import"../Polygon.js";import"../../chunks/coordsUtils.js";import"../../chunks/Axis.js";import"../../chunks/extentUtils.js";import"../../chunks/boundsUtils.js";import"../../chunks/aaBoundingRect.js";import"../../chunks/mathUtils.js";import"../Polyline.js";import"../../chunks/typeUtils.js";import"../support/jsonUtils.js";class d extends r{constructor(t,e,r){super(),e||x(""),this.m_progressTracker=r,this.m_index=-1,this.m_bMerge=t,this.m_bDone=!1,this.m_inputGeometryCursor=e}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}next(){if(this.m_bMerge){if(!this.m_bDone){const t=k(this.m_inputGeometryCursor);return this.m_bDone=!0,t}return null}if(!this.m_bDone){const t=this.m_inputGeometryCursor.next();if(null!==t)return y(t),j(t),this.m_index=this.m_inputGeometryCursor.getGeometryID(),P(t);this.m_bDone=!0}return null}}function k(t,e){const r=new n;let o;for(;o=t.next();)y(o),j(o),r.addGeometry(o);return r.getBoundingGeometry()}function P(t,e){if(t||x(""),y(t),j(t),t.isEmpty())return t.createInstance();const r=t.getGeometryType();if(f(r)){const e=t;if(e.getStartXY().equals(e.getEndXY())){const t=new o;return e.queryStart(t),t}{const r=new o,n=new s({vd:t.getDescription()});return e.queryStart(r),n.startPathPoint(r),e.queryEnd(r),n.lineToPoint(r),n}}if(r===h.enumEnvelope){const e=t,r=new i;if(e.queryEnvelope(r),r.xmin===r.xmax&&r.ymin===r.ymax){const t=new o;return e.queryCornerByVal(0,t),t}if(r.xmin===r.xmax||r.ymin===r.ymax){const r=new o,n=new s({vd:t.getDescription()});return e.queryCornerByVal(0,r),n.startPathPoint(r),e.queryCornerByVal(1,r),n.lineToPoint(r),n}{const r=new u({vd:t.getDescription()});return r.addEnvelope(e,!1),r}}if(r===h.enumGeometryCollection)return k(m(t,-1));if(C(t)){if(r===h.enumMultiPoint){const e=t,r=new o;return e.getPointByVal(0,r),r}return t}return c(t)}function C(e,r){if(y(e),j(e),e.isEmpty())return!0;const n=e.getGeometryType();if(n===h.enumPoint)return!0;if(n===h.enumEnvelope){const t=e;return t.getXMin()!==t.getXMax()&&t.getYMin()!==t.getYMax()}if(f(n)){const t=e;return!t.getStartXY().equals(t.getEndXY())}if(n===h.enumMultiPoint)return 1===e.getPointCount();if(n===h.enumPolyline){const t=e;return 1===t.getPathCount()&&2===t.getPointCount()&&!t.getXY(0).equals(t.getXY(1))}if(n===h.enumGeometryCollection){const t=e;return 1===t.getGeometryCount()&&C(t.getGeometry(0))}const o=e;return!(1!==o.getPathCount()||o.getPointCount()<3)&&t(o,0)}const G=new class{getOperatorType(){return 10102}supportsCurves(){return!1}accelerateGeometry(t,e,r){return!1}canAccelerateGeometry(t){return!1}executeMany(t,e,r){return new d(e,t,r)}execute(t,e){return P(t)}isConvex(e,r){if(y(e),j(e),e.isEmpty())return!0;const n=e.getGeometryType();if(n===h.enumPoint)return!0;if(n===h.enumEnvelope){const t=e;return t.getXMin()!==t.getXMax()&&t.getYMin()!==t.getYMax()}if(f(n)){const t=e;return!t.getStartXY().equals(t.getEndXY())}if(n===h.enumMultiPoint)return 1===e.getPointCount();if(n===h.enumPolyline){const t=e;return 1===t.getPathCount()&&2===t.getPointCount()&&!t.getXY(0).equals(t.getXY(1))}if(n===h.enumGeometryCollection){const t=e;return 1===t.getGeometryCount()&&this.isConvex(t.getGeometry(0),r)}const o=e;return!(1!==o.getPathCount()||o.getPointCount()<3)&&t(o,0)}constructOrientedMinimumBoundingBox(t,r,n,o,s){e(t,r,n,o,s)}};function b(t){const e=p(t);return l((r=g(t),G.execute(r,null)),e);var r}function M(t,e={}){const{merge:r=!1}=e,n=t.map(g),o=p(t);return function(t,e){const r=G.executeMany(new a(t),e,null);return Array.from(r)}(n,r).map((t=>l(t,o)))}function v(t){return e=g(t),G.isConvex(e,null);var e}function w(){return G.supportsCurves()}export{b as execute,M as executeMany,v as isConvex,w as supportsCurves};
