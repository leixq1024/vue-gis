// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.31/esri/copyright.txt for details.
//>>built
define("exports ../../chunks/tslib.es6 ../../geometry ../../Graphic ../../rasterRenderers ../../request ../../core/Error ../../core/lang ../../core/Logger ../../core/reactiveUtils ../../core/urlUtils ../../core/accessorSupport/decorators/property ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/reader ../../core/accessorSupport/decorators/subclass ../../core/accessorSupport/decorators/writer ../../geometry/support/spatialReferenceUtils ../support/commonProperties ../support/DimensionalDefinition ../support/ExportImageServiceParameters ../support/Field ../support/FieldsIndex ../support/imageBitmapUtils ../support/imageryRendererUtils ../support/MosaicRule ../support/MultidimensionalSubset ../support/PixelBlock ../support/rasterEnums ../support/RasterFunction ../support/RasterInfo ../support/RasterJobHandler ../support/rasterDatasets/multidimensionalUtils ../support/rasterFormats/RasterCodec ../support/rasterFunctions/vectorFieldUtils ../../renderers/support/rasterRendererHelper ../../renderers/support/RasterSymbolizer ../../rest/imageService ../../rest/imageService/fetchRasterInfo ../../rest/imageService/getCatalogItemRasterInfo ../../rest/query/executeForCount ../../rest/query/executeForIds ../../rest/query/executeQueryJSON ../../rest/support/FeatureSet ../../rest/support/ImageIdentifyParameters ../../rest/support/Query ../../views/2d/engine/flow/dataUtils ../../geometry/Extent ../../geometry/SpatialReference ../../geometry/Polygon".split(" "),
function(V,h,Ea,da,O,A,r,B,W,ea,fa,n,H,z,ha,I,X,Y,ia,ja,E,ka,Z,la,F,ma,P,C,G,na,oa,J,Q,pa,K,qa,v,M,ra,sa,ta,ua,va,wa,R,xa,S,T,aa){function ya(f){f=JSON.stringify(f);const u=f.includes('"rasterFunctionDefinition":{');return(f=(u?f.match(/"type":"(.*?FunctionArguments")/gi):f.match(/"rasterFunction":"(.*?")/gi))?.map(a=>u?a.slice(8,-18):a.slice(18,-1)))?f.join("/"):null}const za=new Set("png png8 png24 png32 jpg bmp gif jpgpng lerc tiff".split(" ")),Aa=H.ensureRange(H.ensureNumber,{min:0,max:255});
V.ArcGISImageService=f=>{function u(a){return a?.path??""}f=class extends f{constructor(){super(...arguments);this._functionRasterInfos={};this._rasterJobHandler={instance:null,refCount:0,connectionPromise:null};this._serviceSupportsMosaicRule=this._cachedRendererJson=null;this._rasterAttributeTableFieldPrefix="Raster.";this.adjustAspectRatio=null;this.bandIds=void 0;this.capabilities=null;this.compressionQuality=void 0;this.compressionTolerance=.01;this.fullExtent=this.fields=this.rasterInfo=this.exportImageServiceParameters=
this.definitionExpression=this.defaultMosaicRule=this.copyright=null;this.hasMultidimensions=!1;this.imageMaxWidth=this.imageMaxHeight=4100;this.interpolation=void 0;this.maxScale=this.minScale=0;this.noData=this.multidimensionalSubset=this.multidimensionalInfo=null;this.noDataInterpretation=void 0;this.objectIdField=null;this.geometryType="polygon";this.typeIdField=null;this.types=[];this.pixelFilter=null;this.raster=void 0;this.sourceType=null;this.viewId=void 0;this.url=this.sourceJSON=this.serviceRasterInfo=
this.pixelType=this.spatialReference=this.serviceDataType=this.rasterFunctionInfos=this.symbolizer=null;this.version=void 0}initialize(){this._set("exportImageServiceParameters",new ja.ExportImageServiceParameters({layer:this}))}readServiceSupportsMosaicRule(a,b){return this._isMosaicRuleSupported(b)}get _rasterFunctionNamesIndex(){const a=new Map;if(!this.rasterFunctionInfos||null!=this.rasterFunctionInfos&&1>this.rasterFunctionInfos.length)return a;null!=this.rasterFunctionInfos&&this.rasterFunctionInfos.forEach(b=>
{a.set(b.name.toLowerCase().replaceAll(/ /gi,"_"),b.name)});return a}readBandIds(a,b){if(Array.isArray(a)&&0<a.length&&a.every(c=>"number"===typeof c))return a}readCapabilities(a,b){return this._readCapabilities(b)}writeCompressionQuality(a,b,c){null!=a&&"lerc"!==this.format&&(b[c]=a)}writeCompressionTolerance(a,b,c){"lerc"===this.format&&null!=a&&(b[c]=a)}readDefaultMosaicRule(a,b){return this._serviceSupportsMosaicRule?F.fromJSON(b):null}get fieldsIndex(){return this.fields?new ka(this.fields):
null}set format(a){a&&za.has(a.toLowerCase())&&this._set("format",a.toLowerCase())}readFormat(a,b){return"esriImageServiceDataTypeVector-UV"===b.serviceDataType||"esriImageServiceDataTypeVector-MagDir"===b.serviceDataType?"lerc":null!=this.pixelFilter?"lerc":"jpgpng"}readMinScale(a,b){return null!=b.minLOD&&null!=b.maxLOD?a:0}readMaxScale(a,b){return null!=b.minLOD&&null!=b.maxLOD?a:0}set mosaicRule(a){a?.mosaicMethod&&(a=F.fromJSON({...a.toJSON(),mosaicMethod:a.mosaicMethod,mosaicOperation:a.mosaicOperation}));
this._set("mosaicRule",a)}readMosaicRule(a,b){return(a=a||b.mosaicRule)?F.fromJSON(a):this._isMosaicRuleSupported(b)?F.fromJSON(b):null}writeMosaicRule(a,b,c){a=this.mosaicRule;const d=this.definitionExpression;a?d&&d!==a.where&&(a=a.clone(),a.where=d):d&&(a=new F({where:d}));this._isValidCustomizedMosaicRule(a)&&(b[c]=a.toJSON())}writeNoData(a,b,c){null!=a&&"number"===typeof a&&(b[c]=Aa(a))}readObjectIdField(a,b){a||=b.fields.find(c=>"esriFieldTypeOID"===c.type||"oid"===c.type)?.name;return a}get parsedUrl(){return fa.urlToObject(this.url)}readSourceType(a,
b){return this._isMosaicDataset(b)?"mosaic-dataset":"raster-dataset"}get renderer(){const {activePresetRendererName:a,presetRenderers:b}=this;return a?b?.find(({name:c})=>c===a)?.renderer.clone():this.internalRenderer}set renderer(a){this.activePresetRendererName=null;this.internalRenderer=a}set internalRenderer(a){this.loaded&&(a=this._configRenderer(a));this._set("internalRenderer",a)}readRenderer(a,b,c){a=b?.layerDefinition?.drawingInfo?.renderer;c=O.read(a,c);if(null==c)return null;"vector-field"===
c.type&&b.symbolTileSize&&!a.symbolTileSize&&(c.symbolTileSize=b.symbolTileSize);la.isSupportedRendererType(c)||W.getLogger(this).warn("ArcGISImageService","Imagery layer doesn't support given renderer type.");return c}writeRenderer(a,b,c){b.layerDefinition=b.layerDefinition||{};b.layerDefinition.drawingInfo=b.layerDefinition.drawingInfo||{};b.layerDefinition.drawingInfo.renderer=a.toJSON();"vector-field"===a.type&&(b.symbolTileSize=a.symbolTileSize)}get rasterFields(){const a=this._rasterAttributeTableFieldPrefix;
var b=new E({name:"Raster.ItemPixelValue",alias:"Item Pixel Value",domain:null,editable:!1,length:50,type:"string"});const c=new E({name:"Raster.ServicePixelValue",alias:"Service Pixel Value",domain:null,editable:!1,length:50,type:"string"}),d=new E({name:"Raster.ServicePixelValue.Raw",alias:"Raw Service Pixel Value",domain:null,editable:!1,length:50,type:"string"});let g=this.fields?B.clone(this.fields):[];g.push(c);this.capabilities?.operations.supportsQuery&&this.fields&&0<this.fields.length&&
g.push(b);10.4<=this.version&&null!=this.rasterFunctionInfos&&this.rasterFunctionInfos.some(e=>"none"===e.name.toLowerCase())&&g.push(d);null!=this.rasterFunctionInfos&&this.rasterFunctionInfos.filter(e=>"none"!==e.name.toLowerCase()).forEach(e=>{g.push(new E({name:"Raster.ServicePixelValue."+e.name,alias:e.name,domain:null,editable:!1,length:50,type:"string"}))});this._isVectorDataSet()&&(g.push(new E({name:"Raster.Magnitude",alias:"Magnitude",domain:null,editable:!1,type:"double"})),g.push(new E({name:"Raster.Direction",
alias:"Direction",domain:null,editable:!1,type:"double"})));({attributeTable:b}=this.rasterInfo??{});null!=b&&(b=b.fields.filter(e=>"esriFieldTypeOID"!==e.type&&"value"!==e.name.toLowerCase()).map(e=>{const m=B.clone(e);m.name=a+e.name;return m}),g=g.concat(b));return g}set rasterFunction(a){a?.rasterFunction&&(a=G.fromJSON({...a.toJSON(),rasterFunction:a.rasterFunction,rasterFunctionArguments:a.rasterFunctionArguments}));this._set("rasterFunction",a)}readRasterFunction(a,b){a=b.rasterFunctionInfos;
return b.renderingRule||a?.length&&"None"!==a[0].name?this._isRFTJson(b.renderingRule)?G.fromJSON({rasterFunctionDefinition:b.renderingRule}):G.fromJSON(b.renderingRule||{rasterFunctionInfos:b.rasterFunctionInfos}):null}readSpatialReference(a,b){return(a=a||b.extent.spatialReference)?T.fromJSON(a):null}readPixelType(a){return C.pixelTypeKebabDict.fromJSON(a)||a}writePixelType(a,b,c){if(null==this.serviceRasterInfo||this.pixelType!==this.serviceRasterInfo.pixelType)b[c]=C.pixelTypeKebabDict.toJSON(a)}readVersion(a,
b){(a=b.currentVersion)||(a=b.hasOwnProperty("fields")||b.hasOwnProperty("timeInfo")?10:9.3);return a}applyFilter(a){let b=a;this.pixelFilter&&(b=this._clonePixelData(a),this.pixelFilter(b));return b}async applyRenderer(a,b){var c=a;const {renderer:d,symbolizer:g,pixelFilter:e,bandIds:m}=this;if(!this._isPicture()&&d&&g&&!e){c=JSON.stringify(this._cachedRendererJson)!==JSON.stringify(d.toJSON());const k=this._rasterJobHandler.instance;k?(c&&(g.bind(),await k.updateSymbolizer(g,b),this._cachedRendererJson=
d.toJSON()),b=await k.symbolize({bandIds:m,...a},b),c={extent:a.extent,pixelBlock:b}):c={extent:a.extent,pixelBlock:g.symbolize({bandIds:m,...a})}}return c}destroy(){this._shutdownJobHandler()}increaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount++}decreaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount--;0>=this._rasterJobHandler.refCount&&this._shutdownJobHandler()}async computeAngles(a,b){if(!(await this._fetchCapabilities(b?.signal)).operations.supportsComputeAngles)throw new r("imagery-layer:compute-angles",
"this operation is not supported on the input image service");return v.computeAngles(this.url,a,this._getRequestOptions(b))}async computePixelSpaceLocations(a,b){if(!(await this._fetchCapabilities(b?.signal)).operations.supportsComputePixelLocation)throw new r("imagery-layer:compute-pixel-space-locations","this operation is not supported on the input image service");return v.computePixelSpaceLocations(this.url,a,this._getRequestOptions(b))}async computeHistograms(a,b){if(!(await this._fetchCapabilities(b?.signal)).operations.supportsComputeHistograms)throw new r("imagery-layer:compute-histograms",
"this operation is not supported on the input image service");a=B.clone(a);this._applyMosaicAndRenderingRules(a);return v.computeHistograms(this.url,a,this._getRequestOptions(b))}async computeStatisticsHistograms(a,b){if(!(await this._fetchCapabilities(b?.signal)).operations.supportsComputeStatisticsHistograms)throw new r("imagery-layer:compute-statistics-histograms","this operation is not supported on the input image service");a=B.clone(a);this._applyMosaicAndRenderingRules(a);return v.computeStatisticsHistograms(this.url,
a,this._getRequestOptions(b))}async measureHeight(a,b){const c=await this._fetchCapabilities(b?.signal);if(!("base-and-top"===a.operationType?c.mensuration.supportsHeightFromBaseAndTop:"base-and-top-shadow"===a.operationType?c.mensuration.supportsHeightFromBaseAndTopShadow:c.mensuration.supportsHeightFromTopAndTopShadow))throw new r("imagery-layer:measure-height","this operation is not supported on the input image service");a=B.clone(a);this._applyMosaicAndRenderingRules(a);return v.measureHeight(this.url,
a,this._getRequestOptions(b))}async measureAreaAndPerimeter(a,b){const c=await this._fetchCapabilities(b?.signal);if(!c.mensuration.supportsAreaAndPerimeter||a.is3D&&!c.mensuration.supports3D)throw new r("imagery-layer:measure-area-and-perimeter","this operation is not supported on the input image service");a=B.clone(a);this._applyMosaicAndRenderingRules(a);return v.measureAreaAndPerimeter(this.url,a,this._getRequestOptions(b))}async measureDistanceAndAngle(a,b){const c=await this._fetchCapabilities(b?.signal);
if(!c.mensuration.supportsDistanceAndAngle||a.is3D&&!c.mensuration.supports3D)throw new r("imagery-layer:measure-distance-and-angle","this operation is not supported on the input image service");a=B.clone(a);this._applyMosaicAndRenderingRules(a);return v.measureDistanceAndAngle(this.url,a,this._getRequestOptions(b))}async measurePointOrCentroid(a,b){const c=await this._fetchCapabilities(b?.signal);if(!c.mensuration.supportsPointOrCentroid||a.is3D&&!c.mensuration.supports3D)throw new r("imagery-layer:measure-point-or-centroid",
"this operation is not supported on the input image service");a=B.clone(a);this._applyMosaicAndRenderingRules(a);return v.measurePointOrCentroid(this.url,a,this._getRequestOptions(b))}async measureLengthFromImage(a,b){if(!(await this._fetchCapabilities(b?.signal)).operations.supportsMeasureFromImage)throw new r("imagery-layer:measure-length-from-image","this operation is not supported on the input image service");if("polyline"!==a.geometry.type)throw new r("imagery-layer:measure-length-from-image",
"this input geometry must be a polyline");return v.measureLengthFromImage(this.url,a,this._getRequestOptions(b))}async measureAreaFromImage(a,b){if(!(await this._fetchCapabilities(b?.signal)).operations.supportsMeasureFromImage)throw new r("imagery-layer:measure-area-from-image","this operation is not supported on the input image service");if("polygon"!==a.geometry.type)throw new r("imagery-layer:measure-area-from-image","this input geometry must be a polygon");return v.measureAreaFromImage(this.url,
a,this._getRequestOptions(b))}getField(a){const {fieldsIndex:b}=this;return null!=b?b.get(a):void 0}getFieldDomain(a,b){return(a=this.getField(a))?a.domain:null}async fetchImage(a,b,c,d={}){if(null==a||null==b||null==c)throw new r("imagery-layer:fetch-image","Insufficient parameters for requesting an image. A valid extent, width and height values are required.");if(this.renderer||this.symbolizer){var g=await this._generateRasterInfo(this.rasterFunction,{signal:d.signal});g&&(this.rasterInfo=g)}g=
this.getExportImageServiceParameters(a,b,c,d.timeExtent);if(null==g){if(d.requestAsImageElement&&this._canRequestImageElement(this.format))return a=document.createElement("canvas"),a.width=b,a.height=c,d.returnImageBitmap?{imageBitmap:await Z.createBitmap(a,`${u(this.parsedUrl)}/exportImage`,d.signal)}:{imageOrCanvasElement:a};const {bandIds:m,rasterInfo:k}=this;d=(m?.length||k.bandCount)??0;g=b*c;var e=k.pixelType;const q=[];for(let l=0;l<d;l++)q.push(P.createEmptyBand(e,g));return{pixelData:{pixelBlock:new P({width:b,
height:c,pixels:q,mask:new Uint8Array(g),pixelType:e}),extent:a}}}e=!!d.requestAsImageElement&&!this.pixelFilter;return this._requestArrayBuffer({imageServiceParameters:g,imageProps:{extent:a,width:b,height:c,format:this.format},requestAsImageElement:e,returnImageBitmap:e&&!!d.returnImageBitmap,signal:d.signal})}fetchKeyProperties(a){return A(u(this.parsedUrl)+"/keyProperties",{query:this._getQueryParams({renderingRule:10.3<=this.version?a?.rasterFunction:null})}).then(b=>b.data)}fetchRasterAttributeTable(a){return 10.1>
this.version?Promise.reject(new r("#fetchRasterAttributeTable()","Failed to get rasterAttributeTable")):A(u(this.parsedUrl)+"/rasterAttributeTable",{query:this._getQueryParams({renderingRule:10.3<=this.version?a?.rasterFunction:null})}).then(b=>va.fromJSON(b.data))}getCatalogItemRasterInfo(a,b){const c=this._getQueryParams();b={...b,query:c};return ra.getCatalogItemRasterInfo(u(this.parsedUrl),a,b)}async getCatalogItemICSInfo(a,b){var {data:c}=await A(u(this.parsedUrl)+"/"+a+"/info/ics",{query:this._getQueryParams(),
...b});if(c=c?.ics){var d=null;try{d=(await A(u(this.parsedUrl)+"/"+a+"/info",{query:this._getQueryParams(),...b})).data.extent}catch{}if(!d?.spatialReference)return{ics:c,icsToPixelTransform:null,icsExtent:null,northDirection:null};var g=10.7<=this.version?A(u(this.parsedUrl)+"/"+a+"/info/icstopixel",{query:this._getQueryParams(),...b}).then(p=>p.data).catch(()=>({})):{},e=d.spatialReference,m={geometries:JSON.stringify({geometryType:"esriGeometryEnvelope",geometries:[d]}),inSR:X.srToRESTValue(e),
outSR:"0:"+a};m=A(u(this.parsedUrl)+"/project",{query:this._getQueryParams(m),...b}).then(p=>p.data).catch(()=>({}));var k=(d.xmin+d.xmax)/2,q=(d.ymax-d.ymin)/6;d=d.ymin+q;var l=[];for(let p=0;5>p;p++)l.push({x:k,y:d+q*p});a={geometries:JSON.stringify({geometryType:"esriGeometryPoint",geometries:l}),inSR:X.srToRESTValue(e),outSR:"0:"+a};b=A(u(this.parsedUrl)+"/project",{query:this._getQueryParams(a),...b}).then(p=>p.data).catch(()=>({}));a=await Promise.all([g,m,b]);b=a[0].ipxf;null==b&&(g=c.geodataXform?.xf_0,
"topup"===g?.name?.toLowerCase()&&6===g?.coefficients?.length&&(b={affine:{name:"ics [sensor: Frame] to pixel (column, row) transformation",coefficients:g.coefficients,cellsizeRatio:0,type:"GeometricXform"}}));if(g=S.fromJSON(a[1]?.geometries?.[0]))g.spatialReference=new T({wkid:0,imageCoordinateSystem:c});a=a[2].geometries?a[2].geometries.filter(p=>null!=p?.x&&null!=p.y&&"NaN"!==p.x&&"NaN"!==p.y):[];m=a.length;if(3>m)return{ics:c,icsToPixelTransform:b,icsExtent:g,northDirection:null};d=q=k=e=0;for(l=
0;l<m;l++)e+=a[l].x,k+=a[l].y,q+=a[l].x*a[l].x,d+=a[l].x*a[l].y;m=(m*d-e*k)/(m*q-e*e);e=0;k=a[4].x>a[0].x;a=a[4].y>a[0].y;Infinity===m?e=a?90:270:0===m?e=k?0:180:0<m?e=k?180*Math.atan(m)/Math.PI:180*Math.atan(m)/Math.PI+180:0>m&&(e=a?180+180*Math.atan(m)/Math.PI:360+180*Math.atan(m)/Math.PI);return{ics:c,icsToPixelTransform:b,icsExtent:g,northDirection:e}}}async generateRasterInfo(a,b){a=H.ensureClass(G,a);const c={...b,query:this._getQueryParams()};if(!a||"none"===a.functionName?.toLowerCase()||
this._isVectorFieldResampleFunction(a))return this.serviceRasterInfo??M.fetchServiceRasterInfo(u(this.parsedUrl),this.sourceJSON,c);b=ya(a);if(!b)throw new r("imagery-layer:generate-raster-info","the rendering rule is not supported");if(this._functionRasterInfos[b])return this._functionRasterInfos[b];a=M.generateRasterInfo(u(this.parsedUrl),a,c);this._functionRasterInfos[b]=a;try{return await a}catch(d){throw this._functionRasterInfos[b]=null,d;}}getExportImageServiceParameters(a,b,c,d){a=a.clone().shiftCentralMeridian();
const g=v.getImageSpatialReferenceQueryParameter(a.spatialReference,u(this.parsedUrl));this.pixelType!==this.serviceRasterInfo.pixelType&&(this.exportImageServiceParameters.pixelType=this.pixelType);const e=this.exportImageServiceParameters.toJSON(),{bandIds:m,noData:k}=e;var {renderingRule:q}=e,l=this.rasterFunction?.rasterFunctionDefinition,p=this.renderer?.type;p=!p||"raster-stretch"===p||"raster-colormap"===p||"unique-value"===p||"class-breaks"===p||"raster-shaded-relief"===p;m?.length&&this._hasRasterFunction(this.rasterFunction)&&
!l&&p?(l={rasterFunction:"ExtractBand",rasterFunctionArguments:{BandIds:m}},"Stretch"===q.rasterFunction?(l.rasterFunctionArguments.Raster=q.rasterFunctionArguments.Raster,q.rasterFunctionArguments.Raster=l):"Colormap"===q.rasterFunction?(p=q.rasterFunctionArguments.Raster,"Stretch"===p?.rasterFunction?(l.rasterFunctionArguments.Raster=p.rasterFunctionArguments.Raster,p.rasterFunctionArguments.Raster=l):(l.rasterFunctionArguments.Raster=p,q.rasterFunctionArguments.Raster=l)):(l.rasterFunctionArguments.Raster=
q,q=l),e.bandIds=void 0):e.bandIds=m?.join(",");Array.isArray(k)&&0<k.length&&(e.noData=k.join(","));d=this._processMultidimensionalIntersection(null,d,this.exportImageServiceParameters.mosaicRule);if(d.isOutSide)return null;e.mosaicRule=null!=d.mosaicRule?JSON.stringify(d.mosaicRule):null;d=d.timeExtent;e.renderingRule=this._getRenderingRuleString(G.fromJSON(q));q={};if(null!=d){const {start:t,end:w}=d.toJSON();if(t&&w&&t===w)q.time=""+t;else if(null!=t||null!=w)q.time=`${null==t?"null":t},${null==
w?"null":w}`}return{bbox:a.xmin+","+a.ymin+","+a.xmax+","+a.ymax,bboxSR:g,imageSR:g,size:b+","+c,...e,...q}}async getSamples(a,b){if(!(await this._fetchCapabilities(b?.signal))?.operations.supportsGetSamples)throw new r("imagery-layer:get-samples","getSamples operation is not supported on the input image service");a=B.clone(a);const {raster:c}=this;c&&null==a.raster&&(a.raster=c);return v.getSamples(this.url,a,this._getRequestOptions(b))}async identify(a,b){if(!(await this._fetchCapabilities(b?.signal)).operations.supportsIdentify)throw new r("imagery-layer:identify",
"identify operation is not supported on the input image service");a=B.clone(a);10.91>this.version&&"extent"===a.geometry?.type&&(a.geometry=aa.fromExtent(a.geometry));const c=this._processMultidimensionalIntersection(a.geometry,a.timeExtent,a.mosaicRule||this.mosaicRule);if(c.isOutSide)throw new r("imagery-layer:identify","the request cannot be fulfilled when falling outside of the multidimensional subset");a.timeExtent=c.timeExtent;a.mosaicRule=c.mosaicRule;const {raster:d,rasterFunction:g}=this;
g&&null==a.rasterFunction&&(a.rasterFunction=g);d&&null==a.raster&&(a.raster=d);return v.identify(this.url,a,this._getRequestOptions(b))}async imageToMap(a,b){if(!(await this._fetchCapabilities(b?.signal)).operations.supportsImageToMap)throw new r("imagery-layer:image-to-map","imageToMap operation is not supported on the input image service");return v.imageToMap(u(this.parsedUrl),a,this._getRequestOptions(b))}async imageToMapMultiray(a,b){if(!(await this._fetchCapabilities(b?.signal)).operations.supportsImageToMapMultiray)throw new r("imagery-layer:image-to-map-multiray",
"imageToMapMultiray operation is not supported on the input image service");return v.imageToMapMultiray(u(this.parsedUrl),a,this._getRequestOptions(b))}async mapToImage(a,b){if(!(await this._fetchCapabilities(b?.signal)).operations.supportsMapToImage)throw new r("imagery-layer:map-to-image","mapToImage operation is not supported on the input image service");return v.mapToImage(u(this.parsedUrl),a,this._getRequestOptions(b))}async findImages(a,b){if(!(await this._fetchCapabilities(b?.signal)).operations.supportsFindImages)throw new r("imagery-layer:find-images",
"findImages operation is not supported on the input image service");return v.findImages(u(this.parsedUrl),a,this._getRequestOptions(b))}async getImageUrl(a,b){if(!(await this._fetchCapabilities(b?.signal)).operations.supportsGetImageUrl)throw new r("imagery-layer:get-image-url","getImageUrl operation is not supported on the input image service");return v.getImageUrl(u(this.parsedUrl),a,this._getRequestOptions(b))}createQuery(){return new R({outFields:["*"],returnGeometry:!0,where:this.definitionExpression||
"1\x3d1"})}async queryBoundary(a,b){if(!(await this._fetchCapabilities(b?.signal)).operations.supportsQueryBoundary)throw new r("imagery-layer:query-boundary","queryBoundary operation is not supported on the input image service");a=a??{outSpatialReference:this.spatialReference};return v.queryBoundary(u(this.parsedUrl),a,this._getRequestOptions(b))}async queryRasters(a,b){({query:a,requestOptions:b}=await this._prepareForQuery(a,b));return ua.executeQueryJSON(this.url,a,b)}async queryObjectIds(a,b){({query:a,
requestOptions:b}=await this._prepareForQuery(a,b));return ta.executeForIds(this.url,a,b)}async queryGPSInfo(a,b){if(!(await this._fetchCapabilities(b?.signal)).operations.supportsQueryGPSInfo)throw new r("imagery-layer:query-gps-info","queryGPSInfo operation is not supported on the input image service");a=a??{where:"1\x3d1"};return v.queryGPSInfo(u(this.parsedUrl),a,this._getRequestOptions(b))}async queryRasterCount(a,b){({query:a,requestOptions:b}=await this._prepareForQuery(a,b));return sa.executeForCount(this.url,
a,b)}async queryVisibleRasters(a,b){if(!a)throw new r("imagery-layer: query-visible-rasters","missing query parameter");await this.load();const {pixelSize:c,returnDomainValues:d,returnTopmostRaster:g,showNoDataRecords:e}=b||{pixelSize:null,returnDomainValues:!1,returnTopmostRaster:!1,showNoDataRecords:!1};let m=!1;var k=null,q=null;const l=this._rasterFunctionNamesIndex;if(null!=a.outFields&&(m=a.outFields.some(y=>!y.toLowerCase().includes("raster.servicepixelvalue")),10.4<=this.version)){q=a.outFields.filter(x=>
x.toLowerCase().includes("raster.servicepixelvalue")&&24<x.length).map(x=>{x=x.slice(25);return[this._updateRenderingRulesFunctionName(x,l),x]});k=q.map(x=>new G({functionName:x[0]}));q=q.map(x=>x[1]);const {rasterFunction:y}=this;0===k.length?y?.functionName?(k.push(y),q.push(y.functionName)):k=null:y?.functionName&&!k.some(x=>x.functionName===y.functionName)&&(k.push(y),q.push(y.functionName))}const p=null==a.outSpatialReference||a.outSpatialReference.equals(this.spatialReference);var {multidimensionalSubset:t}=
this;let w=a.timeExtent||this.timeExtent;if(t){const {isOutside:y,intersection:x}=J.intersectMultimensionalSubset(t,{geometry:a.geometry,timeExtent:a.timeExtent,multidimensionalDefinition:this.exportImageServiceParameters.mosaicRule?.multidimensionalDefinition});if(y)throw new r("imagery-layer:query-visible-rasters","the request cannot be fulfilled when falling outside of the multidimensional subset");null!=x?.timeExtent&&(w=x.timeExtent)}t=this._combineMosaicRuleWithTimeExtent(this.exportImageServiceParameters.mosaicRule,
w);let D=a.geometry;10.91>this.version&&"extent"===D?.type&&(D=aa.fromExtent(D));k=this._getQueryParams({geometry:D,timeExtent:w,mosaicRule:t,rasterFunction:10.4>this.version?this.rasterFunction:null,rasterFunctions:k,pixelSize:c,returnCatalogItems:m,returnGeometry:p,raster:this.raster,maxItemCount:g?1:null});delete k.f;k=new wa(k);try{await this._generateRasterInfo(this.rasterFunction);const y=await v.identify(this.url,k,{signal:b?.signal,query:{...this.customParameters}}),x=a.outFields,Ba=null!=
y.value&&y.value.toLowerCase().includes("nodata");if(!m||p||!y?.catalogItems?.features.length||!e&&Ba)return this._processVisibleRastersResponse(y,{returnDomainValues:d,templateRRFunctionNames:q,showNoDataRecords:e,templateFields:x});const N=this.objectIdField||"ObjectId",ba=y.catalogItems?.features??[],Ca=ba.map(L=>L.attributes?.[N]),Da=new R({objectIds:Ca,returnGeometry:!0,outSpatialReference:a.outSpatialReference,outFields:[N]}),ca=await this.queryRasters(Da);ca?.features?.length&&ca.features.forEach(L=>
{ba.forEach(U=>{U.attributes[N]===L.attributes[N]&&L.geometry&&(U.geometry=L.geometry.clone(),null!=a.outSpatialReference&&(U.geometry.spatialReference=a.outSpatialReference))})});return this._processVisibleRastersResponse(y,{returnDomainValues:d,templateRRFunctionNames:q,showNoDataRecords:e,templateFields:x})}catch{throw new r("imagery-layer:query-visible-rasters","encountered error when querying visible rasters");}}async fetchVariableStatisticsHistograms(a,b){var c=A(u(this.parsedUrl)+"/statistics",
{query:this._getQueryParams({variable:a}),signal:b}).then(d=>d.data?.statistics);a=A(u(this.parsedUrl)+"/histograms",{query:this._getQueryParams({variable:a}),signal:b}).then(d=>d.data?.histograms);c=await Promise.all([c,a]);c[0]&&c[0].forEach(d=>{d.avg=d.mean;d.stddev=d.standardDeviation});return{statistics:c[0]||null,histograms:c[1]||null}}async createFlowMesh(a,b){const c=this._rasterJobHandler.instance;return c?c.createFlowMesh(a,b):xa.createFlowMesh(a.meshType,a.simulationSettings,a.flowData,
null!=b.signal?b.signal:(new AbortController).signal)}getMultidimensionalSubsetVariables(a){return J.getSubsetVariablesFromMdInfo(this.multidimensionalSubset,a??this.serviceRasterInfo.multidimensionalInfo)}async _fetchService(a){await this._fetchServiceInfo(a);this.rasterInfo||(this.rasterInfo=this.serviceRasterInfo);const b=this.sourceJSON,c=null!=this.serviceRasterInfo?Promise.resolve(this.serviceRasterInfo):M.fetchServiceRasterInfo(u(this.parsedUrl),b,{signal:a,query:this._getQueryParams()}).then(g=>
{this._set("serviceRasterInfo",g);this._set("multidimensionalInfo",g.multidimensionalInfo);M.patchServiceInfo(g,b);return g});a=this._hasRasterFunction(this.rasterFunction)?this._generateRasterInfo(this.rasterFunction,{signal:a}):null;const d=this._getRasterFunctionInfos();return Promise.all([c,a,d]).then(g=>{g[1]?this._set("rasterInfo",g[1]):this._set("rasterInfo",g[0]);g[2]&&this._set("rasterFunctionInfos",g[2]);this.internalRenderer&&!this._isSupportedRenderer(this.internalRenderer)&&(this._set("internalRenderer",
null),W.getLogger(this).warn("ArcGISImageService","Switching to the default renderer. Renderer applied is not valid for this Imagery Layer"));this._set("internalRenderer",this._configRenderer(this.renderer));this.addHandles([ea.watch(()=>this.rasterFunction,e=>{(this.renderer||this.symbolizer||this.popupEnabled&&this.popupTemplate)&&this._generateRasterInfo(e).then(m=>{m&&(this.rasterInfo=m)})})]);({serviceRasterInfo:g}=this);null!=g.multidimensionalInfo&&this._updateMultidimensionalDefinition(g)})}_combineMosaicRuleWithTimeExtent(a,
b){var c=this.timeInfo,{multidimensionalInfo:d}=this.serviceRasterInfo;if(null==a||null==d||null==b||null==c?.startField)return a;const {startField:g}=c,e=d.variables.some(l=>l.dimensions.some(p=>p.name===g))?g:"StdTime";a=a.clone();if("mosaic-dataset"===this.sourceType)return a.multidimensionalDefinition=a.multidimensionalDefinition?.filter(l=>l.dimensionName!==e),this._cleanupMultidimensionalDefinition(a);a.multidimensionalDefinition=a.multidimensionalDefinition||[];c=a.multidimensionalDefinition.filter(l=>
l.dimensionName===e);d=null!=b.start?b.start.getTime():null;b=null!=b.end?b.end.getTime():null;const m=null==d||null==b||d===b,k=m?[d||b]:[[d,b]],q=10.8<=this.version;c.length?c.forEach(l=>{l.dimensionName===e&&(q?(l.dimensionName=null,l.isSlice=!1,l.values=[]):(l.isSlice=m,l.values=k))}):q||(b=a.multidimensionalDefinition.filter(l=>null!=l.variableName&&null==l.dimensionName),b.length?b.forEach(l=>{l.dimensionName=e;l.isSlice=m;l.values=k}):a.multidimensionalDefinition.push(new ia({variableName:"",
dimensionName:e,isSlice:m,values:k})));return this._cleanupMultidimensionalDefinition(a)}_cleanupMultidimensionalDefinition(a){if(null==a)return null;a.multidimensionalDefinition&&(a.multidimensionalDefinition=a.multidimensionalDefinition.filter(b=>!(!b.variableName&&!b.dimensionName)),0===a.multidimensionalDefinition.length&&(a.multidimensionalDefinition=null));return"mosaic-dataset"!==this.sourceType&&null==a.multidimensionalDefinition?null:a}async _prepareForQuery(a,b){if(!(await this._fetchCapabilities(b?.signal)).operations.supportsQuery)throw new r("imagery-layer:query-rasters",
"query operation is not supported on the input image service");a=null!=a?H.ensureClass(R,a):this.createQuery();b=this._getRequestOptions(b);this.raster&&(b.query={...b.query,raster:this.raster});return{query:a,requestOptions:b}}async _initJobHandler(){if(null!=this._rasterJobHandler.connectionPromise)return this._rasterJobHandler.connectionPromise;const a=new oa;this._rasterJobHandler.connectionPromise=a.initialize().then(()=>{this._rasterJobHandler.instance=a},()=>{});await this._rasterJobHandler.connectionPromise}_shutdownJobHandler(){this._rasterJobHandler.instance&&
this._rasterJobHandler.instance.destroy();this._rasterJobHandler.instance=null;this._rasterJobHandler.connectionPromise=null;this._rasterJobHandler.refCount=0;this._cachedRendererJson=null}_isSupportedRenderer(a){const {rasterInfo:b,rasterFunction:c}=this;return"unique-value"===a.type&&this._hasRasterFunction(c)&&1===b?.bandCount&&["u8","s8"].includes(b.pixelType)||null!=b&&null!=a&&K.getSupportedRendererTypes(b).includes(a.type)}async _fetchCapabilities(a){if(this.capabilities)return this.capabilities;
await this._fetchServiceInfo(a);return this.capabilities}async _fetchServiceInfo(a){let b=this.sourceJSON;if(!b){const {data:c,ssl:d}=await A(u(this.parsedUrl),{query:this._getQueryParams(),signal:a});this.sourceJSON=b=c;d&&(this.url=this.url.replace(/^http:/i,"https:"))}if(-1<b.capabilities?.toLowerCase().split(",").map(c=>c.trim()).indexOf("tilesonly"))throw new r("imagery-layer:fetch-service-info","use ImageryTileLayer to open tiles-only image services");this.read(b,{origin:"service",url:this.parsedUrl})}_isMosaicDataset(a){return a.serviceSourceType?
"esriImageServiceSourceTypeMosaicDataset"===a.serviceSourceType:0<a.fields?.length}_isMosaicRuleSupported(a){if(!a)return!1;const b=this._isMosaicDataset(a);a=10.71<=a.currentVersion&&a.hasMultidimensions&&!(1<a.fields?.length);return b||a}_isVectorFieldResampleFunction(a){if(null==a)return!1;const {functionName:b,functionArguments:c}=a;a="resample"===b?.toLowerCase();const d=c?.ResampleType||c?.resampleType;return a&&(7===d||10===d)}_isPicture(){return!this.format||this.format.includes("jpg")||this.format.includes("png")}_configRenderer(a){var b=
this._isPicture();const {rasterInfo:c}=this;if(!b&&!this.pixelFilter||this._isVectorDataSet()){b=this.mosaicRule?.multidimensionalDefinition?.[0].variableName;const d=K.matchPresetRenderer({variableName:b,rasterFunctionName:this.rasterFunction?.functionName,presetRenderers:this.presetRenderers});if(!this.bandIds&&3<=c.bandCount){const g=d?.bandIds??K.getDefaultBandCombination(c);!g||3===c.bandCount&&0===g[0]&&1===g[1]&&2===g[2]||(this.bandIds=g)}a||=d?.renderer??K.createDefaultRenderer(c,{bandIds:this.bandIds,
variableName:this.rasterFunction?null:b});b=K.normalizeRendererJSON(a.toJSON());this.symbolizer?(this.symbolizer.rendererJSON=b,this.symbolizer.rasterInfo=c):this.symbolizer=new qa({rendererJSON:b,rasterInfo:c});this.symbolizer.bind().success||(this.symbolizer=null)}return a}_clonePixelData(a){return null==a?a:{extent:a.extent&&a.extent.clone(),pixelBlock:null!=a.pixelBlock?a.pixelBlock.clone():null}}_getQueryParams(a){null!=a?.renderingRule&&"string"!==typeof a.renderingRule&&(a.renderingRule=this._getRenderingRuleString(a.renderingRule));
const {raster:b,viewId:c}=this;return{raster:b,viewId:c,f:"json",...a,...this.customParameters}}_getRequestOptions(a){return{...a,query:{...a?.query,...this.customParameters}}}_decodePixelBlock(a,b,c){return this._rasterJobHandler.instance?this._rasterJobHandler.instance.decode({data:a,options:b}):Q.decode(a,b,c)}async _getRasterFunctionInfos(a){const b=this.sourceJSON.rasterFunctionInfos;return this.loaded?b:b&&10.3<=this.version?1===b.length&&"none"===b[0].name.toLowerCase()?b:(await A(u(this.parsedUrl)+
"/rasterFunctionInfos",{query:this._getQueryParams(),signal:a})).data?.rasterFunctionInfos:null}_canRequestImageElement(a){return!this.pixelFilter&&(!a||a.includes("png"))}async _requestArrayBuffer(a){const {imageProps:b,requestAsImageElement:c,returnImageBitmap:d,signal:g}=a;if(c&&this._canRequestImageElement(b.format)){var e=`${u(this.parsedUrl)}/exportImage`;({data:a}=await A(e,{responseType:d?"blob":"image",query:this._getQueryParams({f:"image",...this.refreshParameters,...a.imageServiceParameters}),
signal:g}));return a instanceof Blob?{imageBitmap:await Z.createBitmap(a,e,g),params:b}:{imageOrCanvasElement:a,params:b}}e=this._initJobHandler();a=A(u(this.parsedUrl)+"/exportImage",{responseType:"array-buffer",query:this._getQueryParams({f:"image",...a.imageServiceParameters}),signal:g});a=(await Promise.all([a,e]))[0].data;var m=e=b.format||"jpgpng";"bsq"!==m&&"bip"!==m&&(m=Q.getFormat(a));if(!m)throw new r("imagery-layer:fetch-image","unsupported format signature "+String.fromCharCode.apply(null,
new Uint8Array(a)));m="gif"===e||"bmp"===e||e.includes("png")&&("png"===m||"jpg"===m);const k={signal:g};return{pixelData:{pixelBlock:await (m?Q.decode(a,{useCanvas:!0,...b},k):this._decodePixelBlock(a,{width:b.width,height:b.height,planes:null,pixelType:null,noDataValue:null,format:e},k)),extent:b.extent},params:b}}_generateRasterInfo(a,b){return this.generateRasterInfo(a,b).catch(()=>null)}_isValidCustomizedMosaicRule(a){return a&&JSON.stringify(a.toJSON())!==JSON.stringify(this.defaultMosaicRule?.toJSON())}_updateMultidimensionalDefinition(a){if(!this._isValidCustomizedMosaicRule(this.mosaicRule)&&
(a=J.getDefaultMultidimensionalDefinition(a,{multidimensionalSubset:this.multidimensionalSubset}),null!=a&&0<a.length)){this.mosaicRule=this.mosaicRule||new F;const b=this.mosaicRule.multidimensionalDefinition;!this.sourceJSON.defaultVariableName&&this.rasterFunction&&"none"!==this.rasterFunction.functionName?.toLowerCase()&&a.forEach(c=>c.variableName="");a=a.filter(({variableName:c,dimensionName:d})=>c&&"*"!==c||d);!b?.length&&a.length&&(this.mosaicRule.multidimensionalDefinition=a)}}_processVisibleRastersResponse(a,
b){b=b||{};const c=a.value,{templateRRFunctionNames:d,showNoDataRecords:g,returnDomainValues:e,templateFields:m}=b;b=a.processedValues;var k=a.catalogItems?.features;let q=a.properties?.Values?.map(D=>D.replaceAll(/ /gi,", "))||[];var l=this.objectIdField||"ObjectId",p="string"===typeof c&&c.toLowerCase().includes("nodata");a=[];!c||k||p||(k={},k[l]=0,k=new da({geometry:this.fullExtent,attributes:k}),q=[c],k=[k]);if(!k)return[];this._updateResponseFieldNames(k,m);p&&!g&&(k=[]);for(l=0;l<k.length;l++){p=
k[l];if(null!=c){var t=q[l];var w=this.rasterFunction&&b&&0<b.length&&d&&0<d.length&&d.includes(this.rasterFunction.functionName)?b[d.indexOf(this.rasterFunction.functionName)]:c;if("nodata"===t.toLowerCase()&&!g)continue;p.attributes["Raster.ItemPixelValue"]=t;p.attributes["Raster.ServicePixelValue"]=w;this._updateFeatureWithMagDirValues(p,t);const D=this.fields&&0<this.fields.length;w=this.rasterFunction&&null!=this.serviceRasterInfo.attributeTable?D?t:c:w;this.rasterFunction||(w=D?t:c);this._updateFeatureWithRasterAttributeTableValues(p,
w)}p.sourceLayer=p.layer=this;e&&this._updateFeatureWithDomainValues(p);if(d&&b&&d.length===b.length)for(t=0;t<d.length;t++)p.attributes["Raster.ServicePixelValue."+d[t]]=b[t];a.push(k[l])}return a}_processMultidimensionalIntersection(a,b,c){const {multidimensionalSubset:d}=this;if(!d)return c=this._combineMosaicRuleWithTimeExtent(c,b),{isOutSide:!1,timeExtent:b,mosaicRule:c};if(d){const {isOutside:g,intersection:e}=J.intersectMultimensionalSubset(d,{geometry:a,timeExtent:b});if(g)return{isOutSide:!0,
timeExtent:null,mosaicRule:null};null!=e?.timeExtent&&(b=e.timeExtent)}c=this._combineMosaicRuleWithTimeExtent(c,b);return c?.multidimensionalDefinition&&({isOutside:a}=J.intersectMultimensionalSubset(d,{multidimensionalDefinition:c.multidimensionalDefinition}),a)?{isOutSide:!0,timeExtent:null,mosaicRule:null}:{isOutSide:!1,timeExtent:b,mosaicRule:c}}_updateFeatureWithRasterAttributeTableValues(a,b){const c=this.rasterInfo.attributeTable||this.serviceRasterInfo.attributeTable;if(null!=c){var {features:d,
fields:g}=c,e=g.map(k=>k.name).find(k=>"value"===k.toLowerCase());if(e){var m=d.filter(k=>k.attributes[e]===(null!=b?parseInt(b,10):null));m&&m[0]&&g.forEach(k=>{a.attributes[this._rasterAttributeTableFieldPrefix+k.name]=m[0].attributes[k.name]})}}}_updateFeatureWithMagDirValues(a,b){if(this._isVectorDataSet()){var c=b.split(/,\s*/).map(d=>parseFloat(d));b=c.map(d=>[d]);c=c.map(d=>({minValue:d,maxValue:d,noDataValue:null}));b=new P({height:1,width:1,pixelType:"f32",pixels:b,statistics:c});null!=this.pixelFilter&&
this.pixelFilter({pixelBlock:b,extent:new S(0,0,0,0,this.spatialReference)});b="esriImageServiceDataTypeVector-MagDir"===this.serviceDataType?[b.pixels[0][0],b.pixels[1][0]]:pa.uvComponentToVector([b.pixels[0][0],b.pixels[1][0]]);a.attributes["Raster.Magnitude"]=b[0];a.attributes["Raster.Direction"]=b[1]}}_updateFeatureWithDomainValues(a){const b=this.fields&&this.fields.filter(c=>c.domain&&"coded-value"===c.domain.type);null!=b&&b.forEach(c=>{const d=a.attributes[c.name];if(null!=d){const g=c.domain.codedValues.find(e=>
e.code===d);g&&(a.attributes[c.name]=g.name)}})}_updateResponseFieldNames(a,b){if(b&&!(1>b.length)){var c=this.fieldsIndex;null!=c&&a.forEach(d=>{if(d?.attributes)for(const g of b){const e=c.get(g)?.name;e&&e!==g&&(d.attributes[g]=d.attributes[e],delete d.attributes[e])}})}}_getRenderingRuleString(a){if(a){a=a.toJSON();a=a.rasterFunctionDefinition??a;if(a.thumbnail||a.thumbnailEx)a.thumbnail=a.thumbnailEx=null;return JSON.stringify(a)}return null}_hasRasterFunction(a){return null!=a?.functionName&&
"none"!==a.functionName.toLowerCase()}_updateRenderingRulesFunctionName(a,b){if(a&&!(1>a.length)){if("Raw"===a)return a.replace("Raw","None");var c=a.toLowerCase().replaceAll(/ /gi,"_");return b.has(c)?b.get(c):a}}_isRFTJson(a){return a?.name&&a.arguments&&a.function&&a.hasOwnProperty("functionType")}_isVectorDataSet(){return"esriImageServiceDataTypeVector-UV"===this.serviceDataType||"esriImageServiceDataTypeVector-MagDir"===this.serviceDataType}_applyMosaicAndRenderingRules(a){const {raster:b,mosaicRule:c,
rasterFunction:d}=this;d&&"rasterFunction"in a&&null==a.rasterFunction&&(a.rasterFunction=d);c&&null==a.mosaicRule&&(a.mosaicRule=c);b&&null==a.raster&&(a.raster=b)}_readCapabilities(a){var b=a.capabilities?a.capabilities.toLowerCase().split(",").map(w=>w.trim()):["image","catalog"];const {currentVersion:c,advancedQueryCapabilities:d,maxRecordCount:g}=a,e=b.includes("image"),m="esriImageServiceDataTypeElevation"===a.serviceDataType;var k=!(!a.spatialReference&&!a.extent?.spatialReference);const q=
b.includes("edit");k=b.includes("mensuration")&&k;const l=null==a.mensurationCapabilities?[]:a.mensurationCapabilities.toLowerCase().split(",").map(w=>w.trim()),p=k&&l.includes("basic"),t=this._isMosaicDataset(a)&&b.includes("catalog");b=b.includes("download");return{data:{supportsAttachment:!1},operations:{supportsComputeHistograms:e,supportsExportImage:e,supportsIdentify:e,supportsImageToMap:11.2<=c&&t,supportsImageToMapMultiray:11.2<=c&&t,supportsMapToImage:11.2<=c&&t,supportsFindImages:11.2<=
c&&t,supportsGetImageUrl:11.3<=c&&b,supportsMeasure:k,supportsMeasureFromImage:11.2<=c,supportsDownload:b,supportsQuery:t&&a.fields&&0<a.fields.length,supportsGetSamples:10.2<=c&&e,supportsProject:10.3<=c&&e,supportsComputeStatisticsHistograms:10.4<=c&&e,supportsQueryBoundary:10.6<=c&&e,supportsCalculateVolume:10.7<=c&&m,supportsComputePixelLocation:10.7<=c&&t,supportsComputeAngles:10.91<=c,supportsQueryGPSInfo:11.2<=c&&t,supportsAdd:q,supportsDelete:q,supportsEditing:q,supportsUpdate:q,supportsCalculate:!1,
supportsTruncate:!1,supportsValidateSql:!1,supportsChangeTracking:!1,supportsQueryAttachments:!1,supportsResizeAttachments:!1,supportsSync:!1,supportsExceedsLimitStatistics:!1,supportsQueryAnalytics:!1,supportsQueryBins:!1,supportsQueryTopFeatures:!1,supportsAsyncConvert3D:!1},query:{maxRecordCount:g,maxRecordCountFactor:void 0,supportsStatistics:!!d?.supportsStatistics,supportsOrderBy:!!d?.supportsOrderBy,supportsDistinct:!!d?.supportsDistinct,supportsPagination:!!d?.supportsPagination,supportsStandardizedQueriesOnly:!!d?.useStandardizedQueries,
supportsPercentileStatistics:!!d?.supportsPercentileStatistics,supportsCentroid:!!d?.supportsReturningGeometryCentroid,supportsDistance:!!d?.supportsQueryWithDistance,supportsExtent:!!d?.supportsReturningQueryExtent,supportsGeometryProperties:!!d?.supportsReturningGeometryProperties,supportsHavingClause:!!d?.supportsHavingClause,supportsQuantization:!1,supportsQuantizationEditMode:!1,supportsQueryGeometry:!1,supportsResultType:!1,supportsMaxRecordCountFactor:!1,supportsSqlExpression:!1,supportsTopFeaturesQuery:!1,
supportsQueryByAnonymous:!1,supportsQueryByOthers:!1,supportsHistoricMoment:!1,supportsFormatPBF:!1,supportsDisjointSpatialRelationship:!1,supportsCacheHint:!1,supportsSpatialAggregationStatistics:!1,supportedSpatialAggregationStatistics:{envelope:!1,centroid:!1,convexHull:!1},supportsDefaultSpatialReference:!!d?.supportsDefaultSR,supportsFullTextSearch:!1,supportsCompactGeometry:!1,standardMaxRecordCount:void 0,tileMaxRecordCount:void 0},mensuration:{supportsDistanceAndAngle:p,supportsAreaAndPerimeter:p,
supportsPointOrCentroid:p,supportsHeightFromBaseAndTop:k&&l.includes("base-top height"),supportsHeightFromBaseAndTopShadow:k&&l.includes("base-top shadow height"),supportsHeightFromTopAndTopShadow:k&&l.includes("top-top shadow height"),supports3D:k&&l.includes("3d")}}}};h.__decorate([n.property({clonable:!1})],f.prototype,"_functionRasterInfos",void 0);h.__decorate([n.property({clonable:!1})],f.prototype,"_rasterJobHandler",void 0);h.__decorate([n.property({clonable:!1})],f.prototype,"_cachedRendererJson",
void 0);h.__decorate([n.property({readOnly:!0})],f.prototype,"_serviceSupportsMosaicRule",void 0);h.__decorate([z.reader("_serviceSupportsMosaicRule",["currentVersion","fields"])],f.prototype,"readServiceSupportsMosaicRule",null);h.__decorate([n.property({readOnly:!0})],f.prototype,"_rasterAttributeTableFieldPrefix",void 0);h.__decorate([n.property({readOnly:!0})],f.prototype,"_rasterFunctionNamesIndex",null);h.__decorate([n.property()],f.prototype,"adjustAspectRatio",void 0);h.__decorate([n.property({type:[H.Integer],
json:{write:!0}})],f.prototype,"bandIds",void 0);h.__decorate([z.reader("bandIds")],f.prototype,"readBandIds",null);h.__decorate([n.property({readOnly:!0,json:{read:!1}})],f.prototype,"capabilities",void 0);h.__decorate([z.reader("service","capabilities",["capabilities","currentVersion","serviceDataType"])],f.prototype,"readCapabilities",null);h.__decorate([n.property({type:Number})],f.prototype,"compressionQuality",void 0);h.__decorate([I.writer("compressionQuality")],f.prototype,"writeCompressionQuality",
null);h.__decorate([n.property({type:Number})],f.prototype,"compressionTolerance",void 0);h.__decorate([I.writer("compressionTolerance")],f.prototype,"writeCompressionTolerance",null);h.__decorate([n.property({json:{read:{source:"copyrightText"}}})],f.prototype,"copyright",void 0);h.__decorate([n.property({readOnly:!0,dependsOn:["_serviceSupportsMosaicRule"]})],f.prototype,"defaultMosaicRule",void 0);h.__decorate([z.reader("defaultMosaicRule",["defaultMosaicMethod"])],f.prototype,"readDefaultMosaicRule",
null);h.__decorate([n.property({type:String,json:{name:"layerDefinition.definitionExpression",write:{enabled:!0,allowNull:!0}}})],f.prototype,"definitionExpression",void 0);h.__decorate([n.property({readOnly:!0,constructOnly:!0})],f.prototype,"exportImageServiceParameters",void 0);h.__decorate([n.property()],f.prototype,"rasterInfo",void 0);h.__decorate([n.property({readOnly:!0,type:[E]})],f.prototype,"fields",void 0);h.__decorate([n.property({readOnly:!0})],f.prototype,"fieldsIndex",null);h.__decorate([n.property({type:"png png8 png24 png32 jpg bmp gif jpgpng lerc tiff bip bsq".split(" "),
json:{write:!0}})],f.prototype,"format",null);h.__decorate([z.reader("service","format",["serviceDataType"])],f.prototype,"readFormat",null);h.__decorate([n.property({type:S})],f.prototype,"fullExtent",void 0);h.__decorate([n.property({readOnly:!0})],f.prototype,"hasMultidimensions",void 0);h.__decorate([n.property({json:{read:{source:"maxImageHeight"}}})],f.prototype,"imageMaxHeight",void 0);h.__decorate([n.property({json:{read:{source:"maxImageWidth"}}})],f.prototype,"imageMaxWidth",void 0);h.__decorate([n.property({type:String,
json:{type:C.interpolationKebab.jsonValues,read:C.interpolationKebab.read,write:C.interpolationKebab.write}})],f.prototype,"interpolation",void 0);h.__decorate([n.property()],f.prototype,"minScale",void 0);h.__decorate([z.reader("service","minScale")],f.prototype,"readMinScale",null);h.__decorate([n.property()],f.prototype,"maxScale",void 0);h.__decorate([z.reader("service","maxScale")],f.prototype,"readMaxScale",null);h.__decorate([n.property({type:F})],f.prototype,"mosaicRule",null);h.__decorate([z.reader("mosaicRule",
["mosaicRule","defaultMosaicMethod"])],f.prototype,"readMosaicRule",null);h.__decorate([I.writer("mosaicRule")],f.prototype,"writeMosaicRule",null);h.__decorate([n.property()],f.prototype,"multidimensionalInfo",void 0);h.__decorate([n.property({type:ma,json:{write:!0}})],f.prototype,"multidimensionalSubset",void 0);h.__decorate([n.property({json:{type:H.Integer}})],f.prototype,"noData",void 0);h.__decorate([I.writer("noData")],f.prototype,"writeNoData",null);h.__decorate([n.property({type:String,
json:{type:C.noDataInterpretationKebab.jsonValues,read:C.noDataInterpretationKebab.read,write:C.noDataInterpretationKebab.write}})],f.prototype,"noDataInterpretation",void 0);h.__decorate([n.property({type:String,readOnly:!0,json:{read:{source:["fields"]}}})],f.prototype,"objectIdField",void 0);h.__decorate([z.reader("objectIdField")],f.prototype,"readObjectIdField",null);h.__decorate([n.property({readOnly:!0})],f.prototype,"geometryType",void 0);h.__decorate([n.property({})],f.prototype,"typeIdField",
void 0);h.__decorate([n.property({})],f.prototype,"types",void 0);h.__decorate([n.property({readOnly:!0})],f.prototype,"parsedUrl",null);h.__decorate([n.property({type:Function})],f.prototype,"pixelFilter",void 0);h.__decorate([n.property()],f.prototype,"raster",void 0);h.__decorate([n.property({readOnly:!0})],f.prototype,"sourceType",void 0);h.__decorate([z.reader("sourceType",["serviceSourceType","fields"])],f.prototype,"readSourceType",null);h.__decorate([n.property()],f.prototype,"viewId",void 0);
h.__decorate([n.property()],f.prototype,"renderer",null);h.__decorate([n.property({types:O.rasterRendererTypes,json:{name:"layerDefinition.drawingInfo.renderer",origins:{"web-scene":{types:O.websceneRasterRendererTypes,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy(a){return{enabled:a&&"vector-field"!==a.type&&"flow"!==a.type}}}}}}})],f.prototype,"internalRenderer",null);h.__decorate([z.reader("internalRenderer")],f.prototype,"readRenderer",null);h.__decorate([I.writer("internalRenderer")],
f.prototype,"writeRenderer",null);h.__decorate([n.property({clonable:!1})],f.prototype,"symbolizer",void 0);h.__decorate([n.property(Y.opacity)],f.prototype,"opacity",void 0);h.__decorate([n.property({readOnly:!0})],f.prototype,"rasterFields",null);h.__decorate([n.property({constructOnly:!0})],f.prototype,"rasterFunctionInfos",void 0);h.__decorate([n.property({type:G,json:{name:"renderingRule"}})],f.prototype,"rasterFunction",null);h.__decorate([z.reader("rasterFunction",["renderingRule","rasterFunctionInfos"])],
f.prototype,"readRasterFunction",null);h.__decorate([n.property({readOnly:!0})],f.prototype,"serviceDataType",void 0);h.__decorate([n.property({readOnly:!0,type:T})],f.prototype,"spatialReference",void 0);h.__decorate([z.reader("spatialReference",["spatialReference","extent"])],f.prototype,"readSpatialReference",null);h.__decorate([n.property({json:{type:C.pixelTypeKebabDict.jsonValues}})],f.prototype,"pixelType",void 0);h.__decorate([z.reader("pixelType")],f.prototype,"readPixelType",null);h.__decorate([I.writer("pixelType")],
f.prototype,"writePixelType",null);h.__decorate([n.property({constructOnly:!0,type:na})],f.prototype,"serviceRasterInfo",void 0);h.__decorate([n.property()],f.prototype,"sourceJSON",void 0);h.__decorate([n.property(Y.url)],f.prototype,"url",void 0);h.__decorate([n.property({readOnly:!0})],f.prototype,"version",void 0);h.__decorate([z.reader("version",["currentVersion","fields","timeInfo"])],f.prototype,"readVersion",null);return f=h.__decorate([ha.subclass("esri.layers.mixins.ArcGISImageService")],
f)};Object.defineProperty(V,Symbol.toStringTag,{value:"Module"})});