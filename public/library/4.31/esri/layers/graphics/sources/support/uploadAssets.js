// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.31/esri/copyright.txt for details.
//>>built
define("exports ../../../../geometry ../../../../request ../../../../core/has ../../../../core/Logger ../../../../core/promiseUtils ../../../../core/time ../../../../core/urlUtils ../../../../core/uuid ../../../../geometry/support/meshUtils/External ./uploadAssetErrors ./uploadProgressWeights ./uploads ../../../support/infoFor3D ../../../support/meshSpatialReferenceScaleUtils ../../../../rest/support/meshFeatureAttributes ../../../../support/progressUtils ../../../../geometry/SpatialReference".split(" "),
function(w,ca,r,x,E,l,F,u,G,p,m,v,H,t,I,y,q,J){async function K(a,{layer:b,ongoingUploads:c},d){const e=c.get(a);if(e)return e;if(!b.infoFor3D||!b.url)throw new m.UnsupportedError;if(L(a,b))return d?.onProgress?.(1),a;b=M(a,b,d);c.set(a,b);try{await b}finally{c.delete(a)}return a}function L(a,b){const {parsedUrl:c}=b;return null!=c&&a.metadata.externalSources.some(d=>p.externalIsOnService(d,c))}async function M(a,b,c){const {metadata:d}=a;var {displaySource:e}=d;e=z(e?.source,b,{checkForConversionRequired:x("enable-feature:georeferenced-uploads")});
b=await (null!=e?N(e,b,c):0<d.externalSources.length?O(a,b,c):P(a,b,c));l.throwIfAborted(c);a.addExternalSources([b]);return a}async function N(a,b,c){return{source:await A(a,b,c),original:!0,unitConversionDisabled:!0}}async function O(a,b,c){const d=B(b);var {externalSources:e}=a.metadata,f=Q(e,b);if(!f)throw new m.NoSupportedSourceError;var k=q.makeProgressManager(v.uploadProgressWeights.uploadConvertibleSource,c?.onProgress,"uploadConvertibleSource");e=await A(f,b,{onProgress:k.makeOnProgress("uploadEditSource")});
a.addExternalSources([{source:e,original:!0}]);f=f.reduce((h,{asset:g})=>g instanceof File?h+g.size:h,0);k=k.simulate("serviceAssetsToGlb",q.estimatedConversionTime(f));try{const {source:h,transform:g,origin:n}=await R(e,b,d);a.transform=g;n&&(a.metadata.georeferenced=!0,c?.useAssetOrigin&&(a.vertexSpace.origin=[n.x,n.y,n.z??0],a.spatialReference=n.spatialReference));return{source:h,unitConversionDisabled:!0}}finally{k.remove()}}async function P(a,b,c){const d=q.makeProgressManager(v.uploadProgressWeights.uploadLocalMesh,
c?.onProgress,"uploadLocalMesh"),e=S(a,b,{...c,onProgress:d.makeOnProgress("meshToAssetBlob")});return{source:await C([e],b,{...c,onProgress:d.makeOnProgress("uploadAssetBlobs")}),extent:a.extent.clone(),original:!0}}async function S(a,b,c){b=B(b);a=await a.load(c);a=await a.toBinaryGLTF({origin:a.origin,signal:c?.signal,ignoreLocalTransform:!0,unitConversionDisabled:!0});l.throwIfAborted(c);return{blob:new Blob([a],{type:"model/gltf-binary"}),assetName:`${G.generateBracedUUID()}.glb`,assetType:b}}
function Q(a,b){for(const c of a)if(a=z(c.source,b))return a;return null}function z(a,{infoFor3D:b},c={}){if(!a)return null;const {supportedFormats:d,editFormats:e}=b;var f=p.externalSourceToMultiPart(a);a=[];const k=t.getPrjFormatId(b);b=t.getWorldFileFormatId(b);let h=!1;for(const n of f){f=n;var g=p.assetFormatId(f,d);f=g?{asset:f,assetType:g}:null;if(!f)return null;({assetType:g}=f);if(c.checkForConversionRequired&&(g===k||g===b))return null;e.includes(g)&&(h=!0);a.push(f)}return h?a:null}async function A(a,
b,c){a=a.map(d=>T(d,c));return C(a,b,c)}async function C(a,b,c){const d=q.makeProgressManager(v.uploadProgressWeights.uploadAssetBlobs,c?.onProgress,"uploadAssetBlobs"),e=await U(a,b,{...c,onProgress:d.makeOnProgress("prepareAssetItems")});l.throwIfAborted(c);const f=e.map(({item:h})=>h),{uploadResults:k}=await V(f,b,{...c,onProgress:d.makeOnProgress("uploadAssetItems")});l.throwIfAborted(c);return a.map((h,g)=>{h=e[g];g=k[g];const {success:n}=g;if(!n)throw{error:g}=g,new m.UploadFailedError(h.assetName,
g);({assetHash:g}=g);const {assetName:W,item:{assetType:D}}=h;({infoFor3D:{supportedFormats:h}}=b);h=t.getFormatIdMimeType(D,h);if(!h)throw new m.UnsupportedFormatUploadedError(D);return new p.ServiceAsset(W,h,[new p.ServiceAssetPart(`${b.parsedUrl.path}/assets/${g}`,g)])})}async function T(a,b){const {asset:c,assetType:d}=a;if(c instanceof File)return{blob:c,assetName:c.name,assetType:d};a=await c.toBlob(b);l.throwIfAborted(b);return{blob:a,assetName:c.assetName,assetType:d}}async function X(a,b,
c){const {blob:d,assetType:e,assetName:f}=a;a=null;try{const k=await H.uploadItem({data:d,name:f},b.url,c);l.throwIfAborted(c);a={assetType:e,assetUploadId:k.itemID}}catch(k){l.throwIfAbortError(k),E.getLogger("esri.layers.graphics.sources.support.uploadAssets").warnOnce(`Service ${b.url} does not support the REST Uploads API.`)}if(!a){b=await u.parseData(d);l.throwIfAborted(c);if(!b.isBase64)throw new m.NotBase64Error;a={assetType:e,assetData:b.data}}if(!a)throw new m.UnableToPrepareOptionsError;
return{item:a,assetName:f}}function U(a,b,c){const d=q.makeProgressManager(a.length,c?.onProgress,"prepareAssetItems");return Promise.all(a.map(async(e,f)=>{e=X(await e,b,{...c,onProgress:d.makeOnProgress(f)});l.throwIfAborted(c);return e}))}async function V(a,b,c){const d=q.simulateProgress(c?.onProgress);try{const e=await r(u.join(b.parsedUrl.path,"uploadAssets"),{timeout:0,query:{f:"json",assets:JSON.stringify(a)},method:"post",responseType:"json"});l.throwIfAborted(c);if(e.data.uploadResults.length!==
a.length)throw new m.BadResponseError(a.length,e.data.uploadResults.length);return e.data}finally{d.remove()}}async function R(a,b,c){a=a.map(({assetName:e,parts:f})=>({assetName:e,assetHash:f[0].partHash}));let d;try{const e=u.join(b.parsedUrl.path,"convert3D"),f=b.capabilities?.operations.supportsAsyncConvert3D;d=(await (f?Y:Z)(e,{query:{f:"json",assets:JSON.stringify(a),transportType:"esriTransportTypeUrl",targetFormat:c,async:f},responseType:"json",timeout:0})).data}catch(e){throw new m.Convert3DFailedError;
}return aa(b,d)}function aa(a,b){const c={source:b.assets.map(d=>{const e=t.getMimeTypeFormatId(d.contentType,a.infoFor3D.supportedFormats);if(!e)throw new m.UnsupportedFormatUploadedError(e);return new p.ServiceAsset(d.assetName,d.contentType,[new p.ServiceAssetPart(d.assetURL,d.assetHash)])}),origin:void 0,transform:void 0};if(x("enable-feature:georeferenced-uploads")&&b.transform){if(c.transform=y.extractMeshFeatureTransform(b.transform),b.spatialReference){const d=J.fromJSON(b.spatialReference);
c.origin=y.extractMeshFeatureOrigin(b.transform,d)}}else c.transform=I.getMeshTransformForMetersToSpatialReference(a.spatialReference);return c}function Z(a,b){return r(a,b)}async function Y(a,b){for(a=(await r(a,b)).data.statusUrl;;){b=(await r(a,{query:{f:"json"},responseType:"json"})).data;switch(b.status){case "Completed":return r(b.resultUrl,{query:{f:"json"},responseType:"json"});case "CompletedWithErrors":throw Error(b.status);case "Failed ImportChanges":case "InProgress":case "Pending":case "ExportAttachments":case "ExportChanges":case "ExportingData":case "ExportingSnapshot":case "ImportAttachments":case "ProvisioningReplica":case "UnRegisteringReplica":break;
default:throw Error();}await l.after(ba)}}function B({infoFor3D:a}){a=t.getGlbFormatId(a);if(!a)throw new m.NoGlbSupportError;return a}const ba=F.Milliseconds(1E3);w.uploadAssets=async function(a,b,c){const d=a.length;if(!d)return c?.onProgress?.(1),[];const e=q.makeProgressManager(d,c?.onProgress,"uploadAssets");return Promise.all(a.map((f,k)=>K(f,b,{...c,onProgress:e.makeOnProgress(k)})))};Object.defineProperty(w,Symbol.toStringTag,{value:"Module"})});