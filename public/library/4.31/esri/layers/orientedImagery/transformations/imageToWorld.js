// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.31/esri/copyright.txt for details.
//>>built
define("exports ../../../geometry ../../../core/arrayUtils ../../../core/libs/gl-matrix-2/factories/vec3f64 ../../../chunks/vec32 ../../../geometry/support/ray ../../../chunks/sphere ../core/ElevationSourceDefinitions ./rectifyMapPoint ./utils ./worldToImage ../../../widgets/PanoramicViewer/constants ../../../geometry/Point".split(" "),function(C,S,J,D,K,F,G,L,H,d,E,M,y){async function N(a,b,c,f,h,e,m,g,t,q){for(const u of a){var k=void 0;a=c;var x=u,B=f,z=h,n=null;let p=0,l=b;for(var v=a;9>=p;){k=
void 0;k=x;n=z;const {cameraLocation:A}=n;v=d.projectiveTransform(k,v,l);const {x:w,y:r}=E.worldToImage(new y(v,A.spatialReference),n);n=[w,r,1];k=Math.abs(k[0]-n[0])+Math.abs(k[1]-n[1]);n=v;if(d.or(1>=k,9===p))break;l=d.computeNewReferenceCoordinates(l,k,x,a);v=O(l,B,z);p++}a=n;q&&d.or(d.isElevationSampler(q.elevationSample),d.isUpdateElevationWithElevationSource(q))&&(a=await H.rectifyMapPoint(f(a),{x:u[0],y:u[1]},{...h,...q,farPlaneVertices:b.map(f)}));e.push(f(I(a,m,g,h.averageElevation,h.cameraPitch,
t)))}}function I(a,b,c,f,h,e){let m=D.clone(a);var g=Math.sqrt((a[2]-b[2])**2+(Math.sqrt((a[0]-b[0])**2+(a[1]-b[1])**2)/c)**2)*c;g=d.scaleWithFactor(K.sub(D.zeros(),a,b),1/g,1/c);a[2]<f||90>h+e/2?m=d.scaleAndAddWithFactor(b,g,Math.abs((b[2]-f)/-g[2])*c,c):m[2]=f;return m}function O(a,b,c){return E.worldToImage(a.map(b),c).map(({x:f,y:h})=>[f,h,1])}function P(a,b){a=J.isArrayLike(a)||"items"in a?a:[a];const {cameraLocation:c,rotationMatrix:f}=b;d.validatePixelsToTransform(a,c);d.validateRotationMatrix(f);
if(9!==f?.length)throw Error("Rotation matrix is not provided or is not a valid 3x3 matrix");const h=d.getWebMercatorScalingFactor(c.y,c.spatialReference),e=d.computeFarplaneVertices({...b,scalingFactor:h}),m=E.worldToImage(e.map(g=>new y(g,c.spatialReference)),b);({vfov:b}=d.computeHFOVAndVFOV(b.horizontalFieldOfView,b.verticalFieldOfView,b.cameraRoll));return{cameraLocation:c.toArray(),imageBoundaries:m.map(({x:g,y:t})=>[g,t,1]),verticalFieldOfView:b,farPlaneVertices:e,scalingFactor:h,pixelsToTransform:a.map(g=>
[g.x,g.y,1]),vecToPoint:d.vecToPoint(c.spatialReference)}}C.imageToWorld=async function(a,b,c){const {verticalFieldOfView:f,imageBoundaries:h,scalingFactor:e,farPlaneVertices:m,cameraLocation:g,pixelsToTransform:t,vecToPoint:q}=P(a,b),k=[];await N(t,m,h,q,b,k,g,e,f,c);return Array.isArray(a)?k:k[0]};C.imageToWorldPanoramic=async function(a,b,c){const {averageElevation:f,cameraHeading:h,cameraLocation:e,farDistance:m,imageHeight:g,imageWidth:t,verticalFieldOfView:q}=b,k=d.getWebMercatorScalingFactor(e.y,
e.spatialReference),x=[],[B,z,n]=e.toArray(),v=G.fromCenterAndRadius([B,z,n??0],m*k),u=M.defaultImageSphereCenter.toArray();var p=Array.isArray(a)?a:[a];for(const w of p){var l=void 0;d.hasAngles(w)?(p=w.heading,l=w.pitch):(l=d.convertPixelToHeadingPitch({x:w.x,y:w.y},t,g),p=l.heading,l=l.pitch);p=(p+h)%360;var A=F.fromPoints([u[0],u[1],u[2]],d.convertHeadingPitchToSphereVertex(p,l));A=F.fromValues([B,z,n??0],A.direction);let r=D.zeros();G.intersectRay(v,A,r);c&&(L.isElevationSource(c)||d.isElevationSampler(c.elevationSample))&&
90>l+q/2&&(r=await H.rectifyMapPointPanoramic(new y(r,e.spatialReference),{heading:p,pitch:l},{...b,...c,farPlaneVertices:d.reducerFn(m,m).map(([Q,R])=>new y([e.x+Q,e.y+R],e.spatialReference))}));r=I(r,e.toArray(),k,f,l,q);x.push(new y(r,e.spatialReference))}return Array.isArray(a)?x:x[0]};Object.defineProperty(C,Symbol.toStringTag,{value:"Module"})});