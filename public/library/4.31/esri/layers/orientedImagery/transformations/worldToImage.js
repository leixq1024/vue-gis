// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.31/esri/copyright.txt for details.
//>>built
define("exports ../../../core/mathUtils ../../../core/libs/gl-matrix-2/factories/vec3f64 ../../../chunks/vec32 ../../../geometry/support/webMercatorUtils ./utils".split(" "),function(t,u,I,D,J,p){function E(b,a){const {cameraLocation:d,pointsToTransform:f,scalingFactor:x}=K(b,a.cameraLocation,a.rotationMatrix),g=[];if(null!=a?.focalLength)var c={focalLengthX:a.focalLength,focalLengthY:a.focalLength};else{var {imageWidth:q,imageHeight:k,horizontalFieldOfView:y,verticalFieldOfView:L}=a;c=q/(2*Math.tan(u.deg2rad(y)/
2));var v=k/(2*Math.tan(u.deg2rad(L)/2));c={focalLengthX:c,focalLengthY:v}}const {affineTransformations:l,cameraLocation:M,focalLengthX:N,focalLengthY:O,principalOffsetPoint:z,radialDistortionCoefficients:w,rotationMatrix:e,scalingFactor:F,tangentialDistortionCoefficients:A}={...a,cameraLocation:d,scalingFactor:x,...c};for(const P of f){c=I.create();D.sub(c,P,M);c[0]/=F;c[1]/=F;a=(e[0]*c[0]+e[3]*c[1]+e[6]*c[2])/(e[2]*c[0]+e[5]*c[1]+e[8]*c[2])*-N;const m=(e[1]*c[0]+e[4]*c[1]+e[7]*c[2])/(e[2]*c[0]+
e[5]*c[1]+e[8]*c[2])*-O,h=a*a+m*m;var n=0,r=0;let G=0,B=0,C=0;v=c=0;w&&(n=w[0]??0,r=w[1]??0,G=w[2]??0);A&&(B=A[0],C=A[1]);z&&(c=z[0]??0,v=z[1]??0);r=1+n*h+r*h*h+G*h*h*h;n=a*r+B*(h+2*a**2)+2*C*a*m;a=m*r+C*(h+2*m**2)+2*B*a*m;n+=c;a+=v;g.push({x:Number(l[0])+Number(l[1])*n+Number(l[2])*a,y:Number(l[3])+Number(l[4])*n+Number(l[5])*a})}return Array.isArray(b)?g:g[0]}function K(b,a,d){b=Array.isArray(b)||"items"in b?b:[b];p.validatePointsToTransform(b,a);H(b,a);p.validateRotationMatrix(d);d=p.getWebMercatorScalingFactor(a.y,
a.spatialReference);return{pointsToTransform:b.map(f=>f.toArray()),scalingFactor:d,cameraLocation:a.toArray()}}function Q(b,a){b=Array.isArray(b)||"items"in b?b:[b];p.validatePointsToTransform(b,a);H(b,a);return{pointsToTransform:b.map(d=>d.toArray()),cameraLocation:a.toArray()}}function H(b,a){if(b.some(d=>!d.spatialReference.equals(a.spatialReference)))throw Error("Input points and camera location must have the same spatial reference");}t.worldToImage=E;t.worldToImagePanoramic=function(b,a){const {cameraHeading:d,
imageHeight:f,imageWidth:x}=a,{cameraLocation:g,pointsToTransform:c}=Q(b,a.cameraLocation);a=[];for(const k of c){var q=D.distance(g,k);const y=(u.rad2deg(Math.atan2(k[0]-g[0],k[1]-g[1]))-d)%360;q=u.rad2deg(Math.acos((g[2]-k[2])/q));a.push(p.convertOrientationToPixelLocation(y,q,x,f))}return Array.isArray(b)?a:a[0]};t.worldToImageWithLTPFlag=function(b,a,d){b=b?a.map(f=>J.webMercatorToGeographic(f)):a;return E(b,d).map(f=>({...f,z:1}))};Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})});