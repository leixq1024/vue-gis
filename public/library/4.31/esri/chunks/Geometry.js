// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.31/esri/copyright.txt for details.
//>>built
define(["exports"],function(b){function r(a){switch(a){case 1:return"Unknown error";case 2:return"Corrupted geometry";case 3:return"Empty geometry";case 4:return"Math singularity";case 5:return"Buffer is too small";case 6:return"Invalid shape type";case 7:return"Projection out of supported range";case 8:return"Non simple geometry";case 9:return"Cannot calculate geodesic";case 10:return"Notation conversion";case 11:return"Missing grid file";case 12:return"Invalid call";case 13:return"Internal error";
case 14:return"Not implemented";case 15:return"IO error";case 16:return"Invalid 3D";case 17:return"An ambiguous geography edge with antipodal points";case 18:return"Geocentric coordinates require ellipsoidal height";case 19:return"Geography cannot be projected into a gnomonic plane or a result of an operation cannot fit into a gnomonic plane";case 20:return"Geometry is too large to be exported in to a given format";case 21:return"Operation is canceled by the user";default:return"unknown error"}}function g(a){return 0!==
(a&4096)}function l(a){return 0!==(a&8192)}function m(a){return 0!==(a&16384)}function n(a){return 0!==(a&32768)}function h(a){const c=a.getGeometryType();if(m(c))return a.hasNonLinearSegments();if(c===b.GeometryType.enumGeometryCollection)for(let f=0,t=a.getGeometryCount();f<t;f++){if(h(a.getGeometry(f)))return!0}else if(g(c))return c!==b.GeometryType.enumLine;return!1}function e(a){a=Error(a);a.name="invalid argument exception";throw a;}function k(a){a=new d(14,a);a.name="not implemented";throw a;
}function p(a){a=new d(13,a);a.name="internal error";throw a;}function q(a){a===b.GeometryType.enumGeometryCollection&&e("Geometry_collection instances are not supported in this operation")}class d extends Error{constructor(a,c){super();this.m_AdditionalMessage=c;this.m_ErrorType=a}what(){return r(this.m_ErrorType)}additionalMessage(){return this.m_AdditionalMessage?this.m_AdditionalMessage:""}code(){return this.m_ErrorType}}class u extends d{constructor(a){super(2,a);this.name="corrupted geometry exception"}}
class v extends d{constructor(a){super(3,a);this.name="empty gemetry exception"}}class w extends d{constructor(a){super(4,a);this.name="match singularity exception"}}class x extends d{constructor(a){super(8,a);this.name="non simple geometry exception"}}b.GeometryType=void 0;(function(a){a[a.enumUnknown=0]="enumUnknown";a[a.enumPoint=513]="enumPoint";a[a.enumLine=5122]="enumLine";a[a.enumBezier=5123]="enumBezier";a[a.enumEllipticArc=5124]="enumEllipticArc";a[a.enumEnvelope=3077]="enumEnvelope";a[a.enumMultiPoint=
8710]="enumMultiPoint";a[a.enumPolyline=25607]="enumPolyline";a[a.enumPolygon=27656]="enumPolygon";a[a.enumMultipatch=40969]="enumMultipatch";a[a.enumGeometryCollection=3594]="enumGeometryCollection";a[a.enumRationalBezier2=5134]="enumRationalBezier2";a[a.enumBezier2=5135]="enumBezier2";a[a.enumRationalBezier23d=5392]="enumRationalBezier23d";a[a.enumGreatArc3d=5393]="enumGreatArc3d"})(b.GeometryType||(b.GeometryType={}));const y=[0,0,1,1,1,2,0,1,2,3,-1,-1,-1,-1,1,1];b.checkAndThrow=function(a,c){a||
e(c)};b.geometryReleaseAssert=function(a,c){try{if(!a)throw Error(c);}catch(f){throw f;}};b.getDimensionFromType=function(a){return y[a&15]};b.hasNonLinearSegments=h;b.isArea=function(a){return 0!==(a&2048)};b.isLinear=function(a){return 0!==(a&1024)};b.isMesh=n;b.isMultiPath=m;b.isMultiVertex=l;b.isPoint=function(a){return 0!==(a&512)};b.isSegment=g;b.throwCorruptedGeometryException=function(a){throw new u(a);};b.throwEmptyGeometryException=function(a){throw new v(a);};b.throwIfCurves=function(a){a&&
h(a)&&k("operation does not support curves yet")};b.throwIfGeometryCollection=function(a){q(a.getGeometryType())};b.throwIfGeometryCollectionType=q;b.throwIfMesh=function(a){a&&n(a.getGeometryType())&&k("Unsupported geometry type.")};b.throwInternalErrorException=p;b.throwInvalidArgumentException=e;b.throwInvalidCallException=function(a){throw new d(12,a);};b.throwInvalidGeometryTypeFor3DOps=function(){e("Geometry type is not supported for 3D operations.")};b.throwInvalidWkidException=function(a){e(`bad wkid: ${a}`)};
b.throwInvalidWktException=function(a){e("bad wkt: "+a+"...")};b.throwLogicErrorException=function(a){a=Error(a);a.name="logic error exception";throw a;};b.throwMathSingularityException=function(a){a=new w(a);a.name="invalid argument exception";throw a;};b.throwNonSimpleGeometryException=function(a){throw new x(a);};b.throwNotImplementedException=k;b.throwOutOfRangeException=function(a){a=Error(a);a.name="out of range exception";throw a;};b.vertexCount=function(a){const c=a.getGeometryType();if(l(c))return a.getPointCount();
if(a.isEmpty())return 0;if(c===b.GeometryType.enumEnvelope)return 4;if(c===b.GeometryType.enumPoint)return 1;if(g(c))return 2;p("missing type")}});