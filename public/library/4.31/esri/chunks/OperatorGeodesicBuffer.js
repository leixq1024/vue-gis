// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.31/esri/copyright.txt for details.
//>>built
define("exports ./SimpleGeometryCursor ./Geometry ./QuadraticBezier ./tslib.es6 ./Transformation2D ./GeometryCleaner-k94LXQsr".split(" "),function(K,L,w,d,u,n,W){function H(a,b,c,e,k,h,g){if(a.isEmpty())return new d.Polygon({vd:a.getDescription()});var f=a;w.hasNonLinearSegments(f)&&(a=10*b.getTolerance(0),f=(new d.OperatorDensify).execute(f,0,a,0,g,12E3));a=new X(g);a.m_sr=b;a.m_gcs=b.getGCS();a.m_transform=d.createEx(b,a.m_gcs,null);var m=d.makeSpheroidData();a.m_gcs.querySpheroidData(m);var l=
new d.Envelope2D;f.queryEnvelope(l);a.m_a=m.majorSemiAxis;a.m_eSquared=m.e2;a.m_rpu=a.m_gcs.getUnit().getUnitToBaseFactor();a.m_gcs90=.5*Math.PI/a.m_rpu;a.m_gcs180=Math.PI/a.m_rpu;a.m_gcs360=2*Math.PI/a.m_rpu;a.m_gcs60=a.m_gcs360/6;a.m_q90=d.peMath.q90(a.m_a,a.m_eSquared);a.m_ellipticToGeodesicMaxRatio=.5*a.m_a*Math.PI/a.m_q90;m=a.m_gcs.getTolerance(0);a.m_radTolerance=m*a.m_rpu;4===c?(a.m_curveType=2,a.m_bShapePreserving=!0):(a.m_curveType=c,a.m_bShapePreserving=!1);a.m_distance=e;a.m_absDistance=
Math.abs(e);Number.isNaN(k)||0>=k?a.setConvergenceOffset():a.m_convergenceOffset=Math.max(k,.001);a.m_convergenceOffset/=h;c=f.getGeometryType();w.isSegment(c)?(l=new d.Polyline({vd:f.getDescription()}),l.addSegment(f,!0),f=l,c=w.GeometryType.enumPolyline):c===w.GeometryType.enumEnvelope&&(c=f,e=new d.Envelope2D,c.queryEnvelope(e),l=d.adjustToleranceForTEClustering(d.calculateToleranceFromGeometryForOp(a.m_sr,l,!0)),e.minDimension()<=l?0===e.maxDimension()?(f=new d.Point({vd:f.getDescription()}),
c.getCenter(f),c=w.GeometryType.enumPoint):(f=new d.Polyline({vd:f.getDescription()}),f.addEnvelope(c,!1),c=w.GeometryType.enumPolyline):(f=new d.Polygon({vd:f.getDescription()}),f.addEnvelope(c,!1),c=w.GeometryType.enumPolygon));a.setMinCornerStep();w.isPoint(c)||a.setMinSegmentStep();if(a.m_absDistance<=.5*a.m_convergenceOffset)return c!==w.GeometryType.enumPolygon?new d.Polygon({vd:f.getDescription()}):a.m_bShapePreserving?f:d.densify(f,a.m_sr,a.m_curveType,a.m_segmentStep,-1,g);if(0>a.m_distance&&
c!==w.GeometryType.enumPolygon)return new d.Polygon({vd:f.getDescription()});a.m_bShapePreserving&&w.isMultiPath(c)?(b=d.densify(f,b,4,Number.NaN,a.m_convergenceOffset,g),f=(new d.OperatorProject).execute(b,a.m_transform,g)):f=(new d.OperatorProject).execute(f,a.m_transform,g);f=d.clipGeometryFromTopAndBottom(f,a.m_gcs);if(f.isEmpty())return new d.Polygon({vd:f.getDescription()});!a.m_bShapePreserving&&w.isMultiPath(c)&&(f=d.normalizeMultiPathGcs(a.m_rpu,f));f=Y(f,a.m_gcs);b=new d.Polygon;switch(c){case w.GeometryType.enumPolygon:b=
a.bufferPolygon(f);break;case w.GeometryType.enumPolyline:b=a.bufferPolyline(f);break;case w.GeometryType.enumMultiPoint:b=a.bufferMultiPoint(f);break;case w.GeometryType.enumPoint:b=a.bufferPoint(f);break;default:w.throwCorruptedGeometryException("")}g=(new d.OperatorProject).execute(b,a.m_transform.getInverse(),g);g.mergeVertexDescription(f.getDescription());return g}function I(a,b,c,e,k,h,g,f,m,l,p){const q={stack:[],error:void 0,hasError:!1};try{const r=new n.Point2D;r.setNAN();!m&&0<p.getPointCount()&&
(r.setCoordsPoint2D(p.getXY(p.getPointCount()-1)),r.scale(c));const t=u.__addDisposableResource(q,new d.PeDoubleClass,!1),v=u.__addDisposableResource(q,new n.SimpleDisposableArray(new d.PeDoubleClass,new d.PeDoubleClass),!1),x=new n.Point2D,z=new n.Point2D,B=h.at(-1);c=1/c;for(let A=0;A<h.length;A++){const y=h[A];let C;0===A?C=g:A===h.length-1?C=f:(d.peLineType.geodeticDistance(a,b,B.x,B.y,y.x,y.y,null,null,t,k),C=t.val-.5*Math.PI);d.peLineType.geodesicCoordinate(a,b,y.x,y.y,e,C,v.at(0),v.at(1));
m?z.setCoords(v.at(0).val,v.at(1).val):(x.setCoords(v.at(0).val,v.at(1).val),l=M(y.x,x.x,r.x,l),z.setCoords(l+x.x,x.y),r.setCoordsPoint2D(z));z.scale(c);p.insertPoint2D(0,-1,z)}return l}catch(r){q.error=r,q.hasError=!0}finally{u.__disposeResources(q)}}function D(a,b,c,e,k,h,g,f,m,l,p,q=Number.NaN,r=Number.NaN){const t={stack:[],error:void 0,hasError:!1};try{if(g-h<f)return l;const v=u.__addDisposableResource(t,new n.SimpleDisposableArray(new d.PeDoubleClass,new d.PeDoubleClass),!1),x=new n.Point2D,
z=new n.Point2D,B=new n.Point2D;z.setNAN();!m&&0<p.getPointCount()&&(z.setCoordsPoint2D(p.getXY(p.getPointCount()-1)),z.scale(c));let A=Math.ceil(h/f),y=A++*f;y===h&&(y=A++*f);for(c=1/c;y<g+f;){h<q&&q<y?(y=q,A--):h<r&&r<y&&(y=r,A--);if(y>=g)break;d.peLineType.geodesicCoordinate(a,b,k.x,k.y,e,y,v.at(0),v.at(1));m?B.setCoords(v.at(0).val,v.at(1).val):(x.setCoords(v.at(0).val,v.at(1).val),l=M(k.x,x.x,z.x,l),B.setCoords(l+x.x,x.y),z.setCoordsPoint2D(B));B.scale(c);p.insertPoint2D(0,-1,B);h=y;y=A++*f}return l}catch(v){t.error=
v,t.hasError=!0}finally{u.__disposeResources(t)}}function N(a,b,c,e,k,h,g,f,m,l,p){c={stack:[],error:void 0,hasError:!1};try{const q=new n.Point2D,r=new n.Point2D,t=u.__addDisposableResource(c,new n.SimpleDisposableArray(new d.PeDoubleClass,new d.PeDoubleClass),!1);d.peLineType.geodesicCoordinate(a,b,k.x,k.y,e,h,t.at(0),t.at(1));q.setCoords(t.at(0).val,t.at(1).val);d.peLineType.geodesicCoordinate(a,b,k.x,k.y,e,g,t.at(0),t.at(1));r.setCoords(t.at(0).val,t.at(1).val);const v=u.__addDisposableResource(c,
new d.PeDoubleClass,!1);d.peLineType.geodeticDistance(a,b,f.x,f.y,q.x,q.y,null,v,null,0);l[0]=v.val;d.peLineType.geodeticDistance(a,b,f.x,f.y,r.x,r.y,null,v,null,0);for(p[0]=v.val;l[0]<=p[0];)l[0]+=n.geometry2Pi;for(;l[0]>p[0];)l[0]-=n.geometry2Pi;for(;l[0]>=m;)l[0]-=n.geometry2Pi,p[0]-=n.geometry2Pi;for(;l[0]<m;)l[0]+=n.geometry2Pi,p[0]+=n.geometry2Pi}catch(q){c.error=q,c.hasError=!0}finally{u.__disposeResources(c)}}function M(a,b,c,e){if(Number.isNaN(c)){for(;e+b-a>Math.PI;)e-=n.geometry2Pi;for(;a-
(e+b)>Math.PI;)e+=n.geometry2Pi;return e}e+b-c>Math.PI?e-=n.geometry2Pi:c-(e+b)>Math.PI&&(e+=n.geometry2Pi);return e}function Y(a,b){const c=a.getGeometryType();let e;e=w.isMultiPath(c)?a.getPathCount():c===w.GeometryType.enumMultiPoint?a.getPointCount():1;if(1===e)return a;const k=[],h=[];for(var g=0;g<e;g++){k.push(g);var f=new n.Point2D;if(w.isMultiPath(c)){const m=new d.Envelope2D;a.queryPathEnvelope(g,m);f.assign(m.getCenter())}else f.assign(a.getXY(g));f=b.toGeohash(f);h.push(f)}k.sort((m,l)=>
h[m]<h[l]?-1:h[m]>h[l]?1:0);b=a.createInstance();for(g=0;g<e;g++)f=k[g],w.isMultiPath(c)?b.addPath(a,f,!0):b.addPoints(a,f,f+1);return b}function O(a,b,c,e,k,h){const g={stack:[],error:void 0,hasError:!1};try{if(e>=h)return!1;var f=c[0];const m=c.at(-1),l=u.__addDisposableResource(g,new d.PeDoubleClass,!1),p=u.__addDisposableResource(g,new d.PeDoubleClass,!1),q=u.__addDisposableResource(g,new d.PeDoubleClass,!1);d.peLineType.greatEllipticDistance(a,b,k.x,k.y,f.x,f.y,l,null,null);d.peLineType.greatEllipticDistance(a,
b,k.x,k.y,m.x,m.y,p,null,null);d.peLineType.greatEllipticDistance(a,b,f.x,f.y,m.x,m.y,q,null,null);let r=Math.min(l.val,p.val)+q.val;if(r+e<h)return!0;const t=u.__addDisposableResource(g,new d.PeDoubleClass,!1);r=Math.max(l.val,p.val);for(f=1;f<c.length-1;f++){const v=c[f];d.peLineType.greatEllipticDistance(a,b,k.x,k.y,v.x,v.y,t,null,null);t.val>r&&(r=t.val)}return r+e<h}catch(m){g.error=m,g.hasError=!0}finally{u.__disposeResources(g)}}function P(a,b,c,e,k,h,g,f){if(0===e.length%2){var m=e.length>>
1;m=n.Point2D.lerp(e[m],e[m-1],.5)}else m=e[e.length-1>>1].clone();const l=m.clone(),p=d.calculateTightRadiusInMeters(a,b,l,75/180*Math.PI);if(!O(a,b,e,k,l,p))return!1;null!==h&&(h.setCoordsPoint2D(m),h.scale(1/c));null!==g&&g.setCoordsPoint2D(l);null!==f&&(f[0]=p);return!0}function Q(a,b,c,e,k,h){const g={stack:[],error:void 0,hasError:!1};try{if(e>=h)return!1;const f=u.__addDisposableResource(g,new d.PeDoubleClass,!1);d.peLineType.greatEllipticDistance(a,b,k.x,k.y,c.x,c.y,f,null,null);return f.val+
e<h}catch(f){g.error=f,g.hasError=!0}finally{u.__disposeResources(g)}}function E(a){d.isAtLeastWeakSimpleGeom(a,0)||d.setWeakSimple(a,0);return a}class X{constructor(a){this.m_transform=this.m_gcs=this.m_sr=null;this.m_curveType=this.m_ellipticToGeodesicMaxRatio=this.m_gcs60=this.m_gcs360=this.m_gcs180=this.m_gcs90=this.m_q90=this.m_radTolerance=this.m_rpu=this.m_eSquared=this.m_a=0;this.m_bShapePreserving=!1;this.m_segmentStep=this.m_cornerStep=this.m_convergenceOffset=this.m_absDistance=this.m_distance=
0;this.m_progressTracker=a}bufferPolygon(a){const b=new d.Polygon;a=new R(this,a,b);return this.processGnomonicBufferPiecesCursor(!0,a)}bufferPolyline(a){a=new R(this,a,null);return this.processGnomonicBufferPiecesCursor(!0,a)}bufferMultiPoint(a){a=new Z(this,a);return this.processGnomonicBufferPiecesCursor(!1,a)}bufferPoint(a){var b=a.getXY();b.scale(this.m_rpu);a=new d.Polygon;this.bufferPoint2D(b,!1,a)&&(b=d.calculateToleranceFromGeometryForOpFromGeom(null,a,!0),a=d.planarSimplify(a,b,!0,!0,-1,
this.m_progressTracker,0,!1));return a=(new d.OperatorProject).foldInto360RangeGeodetic(a,this.m_gcs,2)}processGnomonicBufferPiecesCursor(a,b){var c=b.getGnomonic(),e=d.createLocal(d.create$6()),k=new d.SpatialReferencePrecisionDescriptor;e.queryPrecisionDescriptor(k);k.setTolerance(0,.001);d.createLocal(d.create$6(),void 0,k);var h=new d.ListeningGeometryCursor,g=(new d.OperatorUnion).executeMany(h,e,this.m_progressTracker,2);const f=n.makePrimitiveArray(6,!1),m=n.makeObjectArray(d.Envelope2D,6);
this.initializeGrid(f,m);k=[null,null,null,null,null,null];for(var l=[null,null,null,null,null,null],p=[null,null,null,null,null,null],q,r;null!==(q=b.next());){r=b.getGnomonic();if(r!==c){if(null!==c){var t=g.next();g=h=null;if(null!=t){var v=d.calculateToleranceFromGeometryForOpFromGeom(e,t,!0);v=d.adjustToleranceForTEClustering(v);t=c.unproject(t,v,this.m_progressTracker);this.putInGridCursors(a,t,e,!0,f,m,k,l,p)}}null!==r&&(h=new d.ListeningGeometryCursor,g=(new d.OperatorUnion).executeMany(h,
e,this.m_progressTracker,2));c=r}b.isRunningInGnomonic()?(r.project(q),b.needsSimplify()&&(t=d.calculateToleranceFromGeometryForOpFromGeom(null,q,!0),q=d.planarSimplify(q,t,!0,!0,-1,this.m_progressTracker,0,!1)),h.tick(E(q)),g.tock()):this.putInGridCursors(a,q,e,!0,f,m,k,l,p)}q=!1;for(t=0;6>t;t++)if(null!=p[t]){q=!0;break}if(q){var x=!1;r=[null,null,null,null,null,null];a&&(h=b.m_densified,b.m_densified=null,null!==h&&(b=new n.Transformation2D,b.scale(1/this.m_rpu,1/this.m_rpu),h.applyTransformation(b),
0<this.m_distance?this.putInGridCursors(a,h,e,!1,f,m,k,l,p):(this.processInGrid(a,h,!1,f,m,k,r),x=!0)));b=new d.ListeningGeometryCursor;q=(new d.OperatorUnion).executeMany(b,this.m_gcs,this.m_progressTracker,2);null!==g&&(t=g.next(),g=h=null,g=d.calculateToleranceFromGeometryForOpFromGeom(e,t,!0),g=d.adjustToleranceForTEClustering(g),t=c.unproject(t,g,this.m_progressTracker),this.putInGridCursors(a,t,e,!0,f,m,k,l,p));for(c=0;6>c;c++)null!=p[c]&&(g=p[c].next(),p[c]=null,l[c]=null,x&&null!==r[c]&&(g=
(new d.OperatorDifference).execute(r[c],g,e,this.m_progressTracker)),a=d.calculateToleranceFromGeometryForOpFromGeom(e,g,!0),a=d.adjustToleranceForTEClustering(a),g=k[c].unproject(g,a,this.m_progressTracker),g=(new d.OperatorSimplify).execute(g,this.m_gcs,!0,this.m_progressTracker),b.tick(E(g)),q.tock());e=q.next()}else k=!1,a&&(l=b.m_densified,b.m_densified=null,null!==l&&(p=new n.Transformation2D,p.scale(1/this.m_rpu,1/this.m_rpu),l.applyTransformation(p),r.project(l),p=d.calculateToleranceFromGeometryForOpFromGeom(null,
l,!0),l=d.planarSimplify(l,p,!1,!0,-1,this.m_progressTracker,0,!1),0<this.m_distance?(h.tick(E(l)),g.tock()):(x=l,k=!0))),l=g.next(),g=h=null,k&&(l=(new d.OperatorDifference).execute(x,l,e,this.m_progressTracker)),e=d.calculateToleranceFromGeometryForOpFromGeom(e,l,!0),e=d.adjustToleranceForTEClustering(e),e=c.unproject(l,e,this.m_progressTracker),e=(new d.OperatorSimplify).execute(e,this.m_gcs,!0,this.m_progressTracker);return e=(new d.OperatorProject).foldInto360RangeGeodetic(e,this.m_gcs,2)}putInGridCursors(a,
b,c,e,k,h,g,f,m){const l=[null,null,null,null,null,null];this.processInGrid(a,b,e,k,h,g,l);for(a=0;6>a;a++)null!==l[a]&&(null===f[a]&&(f[a]=new d.ListeningGeometryCursor,m[a]=(new d.OperatorUnion).executeMany(f[a],c,this.m_progressTracker,2)),f[a].tick(E(l[a])),m[a].tock())}processInGrid(a,b,c,e,k,h,g){a=this.insertGeodeticPointsAlongGrid(b,k,.01);for(let l=0;6>l;l++)if(!e[l]){var f=k[l].clone();f.inflateCoords(.01,.01);var m=d.getMergedExtentEnv2D(b,f);m=d.calculateToleranceFromGeometryForOp(null,
m,!1).total();f=d.clip$1(a,f,m,Number.NaN,this.m_progressTracker);if(null!==f&&!f.isEmpty()){f===a&&(f=f.clone());if(null===h[l]){m=new n.Point2D;3>l?m.setCoords(0,1):m.setCoords(0,-1);const p=new n.Point2D;p.setAdd(k[l].getCenter(),m);h[l]=new d.Gnomonic(this.m_gcs,p)}h[l].project(f);m=d.calculateToleranceFromGeometryForOpFromGeom(null,f,!0);f=d.planarSimplify(f,m,c,!0,-1,this.m_progressTracker,0,!1);g[l]=f}}}insertGeodeticPointsAlongGrid(a,b,c){var e=d.Envelope2D.construct(b[3].xmin,b[3].ymin,b[2].xmax,
b[2].ymax);e=d.foldInto360NoUnion(this.m_gcs,e,a,!0,this.m_progressTracker);a=new d.EditShape;e=a.addGeometry(e);d.insertGeodeticPointsEditShape(a,e,this.m_gcs,0,2,!0,b[0].xmax+c);d.insertGeodeticPointsEditShape(a,e,this.m_gcs,0,2,!0,b[1].xmax+c);d.insertGeodeticPointsEditShape(a,e,this.m_gcs,0,2,!1,b[1].ymin+c);0!==c&&(d.insertGeodeticPointsEditShape(a,e,this.m_gcs,0,2,!0,b[0].xmax-c),d.insertGeodeticPointsEditShape(a,e,this.m_gcs,0,2,!0,b[1].xmax-c),d.insertGeodeticPointsEditShape(a,e,this.m_gcs,
0,2,!1,b[1].ymin-c));return a.getGeometry(e)}initializeGrid(a,b){for(let c=0;6>c;c++)a[c]=!1;b[0].setCoords({xmin:-this.m_gcs180,ymin:0,xmax:-this.m_gcs60,ymax:this.m_gcs90});b[1].setCoords({xmin:-this.m_gcs60,ymin:0,xmax:this.m_gcs60,ymax:this.m_gcs90});b[2].setCoords({xmin:this.m_gcs60,ymin:0,xmax:this.m_gcs180,ymax:this.m_gcs90});b[3].setCoords({xmin:-this.m_gcs180,ymin:-this.m_gcs90,xmax:-this.m_gcs60,ymax:0});b[4].setCoords({xmin:-this.m_gcs60,ymin:-this.m_gcs90,xmax:this.m_gcs60,ymax:0});b[5].setCoords({xmin:this.m_gcs60,
ymin:-this.m_gcs90,xmax:this.m_gcs180,ymax:0})}checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(a,b,c,e,k,h){var g=a[0];const f=a.at(-1);var m=g.y>f.y?g.y:f.y,l=d.peMath.q(this.m_a,this.m_eSquared,g.y<f.y?g.y:f.y);m=d.peMath.q(this.m_a,this.m_eSquared,m);if(.001<this.m_q90-(l+b+this.m_absDistance)&&.001<this.m_q90+(m-b-this.m_absDistance))return!1;b=c-n.geometryHalfPi;c=e+n.geometryHalfPi;l=b-Math.PI;m=b+Math.PI;const p=c+Math.PI,q=[Number.NaN],r=[Number.NaN],t=[Number.NaN],v=[Number.NaN];e=!1;N(this.m_a,
this.m_eSquared,this.m_rpu,this.m_absDistance,g,b,l,f,c,q,r);N(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,f,p,c,g,l,t,v);c<q[0]&&q[0]<p?e=!0:c<r[0]&&r[0]<p&&(e=!0);e||(l<t[0]&&t[0]<b?e=!0:l<v[0]&&v[0]<b&&(e=!0));if(!e&&k)return!1;const x=[];for(let z=a.length-1;0<=z;z--)x.push(a[z]);h.setEmpty();h.addPathPoint2D(null,0,!0);a=I(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,this.m_curveType,a,b,c,k,0,h);a=D(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,f,c,p,this.m_cornerStep,
k,a,h,q[0],r[0]);a=I(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,this.m_curveType,x,p,m,k,a,h);a=D(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,g,l,b,this.m_cornerStep,k,a,h,t[0],v[0]);g=!1;k||(g=this.checkAndPrepForPole(h));return e||g}bufferPoint2D(a,b,c){c.setEmpty();c.addPathPoint2D(null,0,!0);D(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,a,-this.m_cornerStep,2*Math.PI,this.m_cornerStep,b,0,c);a=!1;b||(a=this.checkAndPrepForPole(c));return a}checkAndPrepForPole(a){const b=
this.checkAndPrepForPoleTouch(a);a=this.checkAndPrepForPoleWrap(a);return b||a}checkAndPrepForPoleTouch(a){const b=new d.Envelope2D;a.queryEnvelope(b);if(!d.PE_EQ(b.ymax,this.m_gcs90)&&!d.PE_EQ(b.ymin,-this.m_gcs90))return!1;this.prepPoleTouch(a);return!0}checkAndPrepForPoleWrap(a){const b=a.getXY(0),c=a.getXY(a.getPointCount()-1);return Math.abs(b.x-c.x)>this.m_gcs180?(this.prepSinglePoleWrap(a),!0):this.checkAndPrepForDoublePoleWrap(a)}checkAndPrepForDoublePoleWrap(a){return 0>a.calculateArea2D()?
(this.prepDoublePoleWrap(a),!0):!1}prepPoleTouch(a){const b=new d.Polygon;b.insertPath2D(-1,null,0,0,!0);const c=a.getPathStart(0);var e=a.getPathEnd(0);const k=e-c;let h=-1;for(h=c;h<e;h++){var g=a.getXY(h),f=d.PE_EQ(g.y,this.m_gcs90);g=d.PE_EQ(g.y,-this.m_gcs90);if(!f&&!g)break}var m=h;e=!1;f=Number.NaN;do{g=a.getXY(m);var l=d.PE_EQ(g.y,this.m_gcs90),p=d.PE_EQ(g.y,-this.m_gcs90);m=c+(m+1-c)%k;if(l||p){l=n.Point2D.construct(f,g.y);b.insertPoint2D(0,-1,l);l=a.getXY(m);p=d.PE_EQ(l.y,this.m_gcs90);
const q=d.PE_EQ(l.y,-this.m_gcs90);p||q||(l=n.Point2D.construct(l.x,g.y),e?b.setXY(b.getPointCount()-1,l):b.insertPoint2D(0,-1,l));e=!0}else b.insertPoint2D(0,-1,g),f=g.x,e=!1}while(m!==h);a.setEmpty();a.add(b,!1)}prepSinglePoleWrap(a){var b=new d.Polygon,c=new d.Polygon,e=new n.Transformation2D,k=a.getXY(a.getPathStart(0)),h=a.getXY(a.getPathEnd(0)-1);const g=this.m_gcs360,f=this.m_gcs180;var m=new d.Envelope2D;m.setCoords({xmin:-this.m_gcs180,ymin:-this.m_gcs90,xmax:this.m_gcs180,ymax:this.m_gcs90});
var l=new d.Envelope2D;a.queryEnvelope(l);l=Math.ceil(l.width()/g);k.x>h.x?(k=-g,h=this.m_gcs90):(k=g,h=-this.m_gcs90);e.setShiftCoords(k,0);b.addPath(a,0,!0);c.add(b,!1);const p=new d.Point;for(let q=0;q<l;q++)c.applyTransformation(e),c.getPointByVal(0,p),b.lineToPoint(p),b.addSegmentsFromPath(c,0,0,c.getSegmentCount()-1,!1);c=b.getXY(0);l=b.getXY(b.getPointCount()-1);c.y=h;l.y=h;b.lineTo(l);h=new n.Point2D;h.setCoordsPoint2D(l);for(h.x-=.5*k;Math.abs(h.x-c.x)>f;)b.lineTo(h),h.x-=.5*k;b.lineTo(c);
c=m.getCenterX();l=new d.Envelope2D;b.queryEnvelope(l);k=0;l=l.getCenter().x;l-c>f?k=-Math.ceil((l-c-f)/g):c-l>f&&(k=Math.ceil((c-l-f)/g));0!==k&&(e.setShiftCoords(k*g,0),b.applyTransformation(e));e=new d.EditShape;b=e.addGeometry(b);d.insertGeodeticPointsEditShape(e,b,this.m_gcs,0,2,!0,m.xmin);d.insertGeodeticPointsEditShape(e,b,this.m_gcs,0,2,!0,m.xmax);b=e.getGeometry(b);e=d.getMergedExtentEnv2D(b,m);e.inflateCoords(0,1);e=d.calculateToleranceFromGeometryForOp(null,e,!0).total();m=d.clip$1(b,m,
e,Number.NaN,this.m_progressTracker);a.setEmpty();a.add(m,!1)}prepDoublePoleWrap(a){var b=this.m_gcs360,c=this.m_gcs180;const e=new d.Envelope2D;e.setCoords({xmin:-this.m_gcs180,ymin:-this.m_gcs90,xmax:this.m_gcs180,ymax:this.m_gcs90});var k=e.getCenter().x,h=new d.Envelope2D;a.queryPathEnvelope(0,h);var g=0,f=h.getCenter().x;f-k>c?g=-Math.ceil((f-k-c)/b):k-f>c&&(g=Math.ceil((k-f-c)/b));0!==g&&(f=new n.Transformation2D,f.setShiftCoords(g*b,0),a.getImpl().applyTransformationToPath(f,0),a.queryPathEnvelope(0,
h),f=h.getCenter().x);g=new d.Envelope2D;e.containsExclusiveEnvelope(h)?(c=!1,g.setCoords({env2D:e})):(c=!0,g.setCoords({env2D:e}),g.xmin-=b,g.xmax+=b);h=a.createInstance();h.addPathPoint2D(null,0,!0);const m=new n.Point2D;m.setCoords(g.xmin,g.ymin);h.insertPoint2D(0,-1,m);m.setCoords(g.xmin,g.ymax);h.insertPoint2D(0,-1,m);m.setCoords(.5*(g.xmin+g.xmax),g.ymax);h.insertPoint2D(0,-1,m);m.setCoords(g.xmax,g.ymax);h.insertPoint2D(0,-1,m);m.setCoords(g.xmax,g.ymin);h.insertPoint2D(0,-1,m);m.setCoords(.5*
(g.xmin+g.xmax),g.ymin);h.insertPoint2D(0,-1,m);c?(h.addPath(a,0,!0),g=new n.Transformation2D,f<k?g.setShiftCoords(b,0):g.setShiftCoords(-b,0),a.getImpl().applyTransformationToPath(g,0),h.addPath(a,0,!0),b=new d.EditShape,k=b.addGeometry(h),d.insertGeodeticPointsEditShape(b,k,this.m_gcs,0,2,!0,e.xmin),d.insertGeodeticPointsEditShape(b,k,this.m_gcs,0,2,!0,e.xmax),h=b.getGeometry(k),b=d.getMergedExtentEnv2D(h,e),b.inflateCoords(0,1),b=d.calculateToleranceFromGeometryForOp(null,b,!0).total(),h=d.clip$1(h,
e,b,Number.NaN,this.m_progressTracker)):h.addPath(a,0,!0);a.setEmpty();a.add(h,!1)}setMinCornerStep(){const a={stack:[],error:void 0,hasError:!1};try{let c=Math.min(Math.PI*this.m_a-this.m_absDistance,this.m_absDistance);c=Math.min(c,.125*this.m_a*Math.PI);const e=new n.Point2D;e.setCoords(0,10*this.m_rpu);let k=45*this.m_rpu;var b=u.__addDisposableResource(a,new n.SimpleDisposableArray(new d.PeDoubleClass,new d.PeDoubleClass),!1);const h=u.__addDisposableResource(a,new n.SimpleDisposableArray(new d.PeDoubleClass,
new d.PeDoubleClass),!1),g=u.__addDisposableResource(a,new n.SimpleDisposableArray(new d.PeDoubleClass,new d.PeDoubleClass),!1),f=u.__addDisposableResource(a,new n.SimpleDisposableArray(new d.PeDoubleClass,new d.PeDoubleClass),!1),m=new n.Point2D,l=new n.Point2D,p=new n.Point2D,q=new n.Point2D;d.peLineType.geodesicCoordinate(this.m_a,this.m_eSquared,e.x,e.y,c,0,b.at(0),b.at(1));m.setCoords(b.at(0).val,b.at(1).val);d.peLineType.geodesicCoordinate(this.m_a,this.m_eSquared,e.x,e.y,c,k,h.at(0),h.at(1));
for(l.setCoords(h.at(0).val,h.at(1).val);;){b={stack:[],error:void 0,hasError:!1};try{d.peLineType.geodesicCoordinate(this.m_a,this.m_eSquared,e.x,e.y,c,.5*(0+k),g.at(0),g.at(1));p.setCoords(g.at(0).val,g.at(1).val);const r=u.__addDisposableResource(b,new d.PeDoubleClass,!1),t=u.__addDisposableResource(b,new d.PeDoubleClass,!1);d.peLineType.geodeticDistance(this.m_a,this.m_eSquared,m.x,m.y,l.x,l.y,r,t,null,2);d.peLineType.geodeticCoordinate(this.m_a,this.m_eSquared,m.x,m.y,.5*r.val,t.val,f.at(0),
f.at(1),2);q.setCoords(f.at(0).val,f.at(1).val);const v=u.__addDisposableResource(b,new d.PeDoubleClass,!1);d.peLineType.geodeticDistance(this.m_a,this.m_eSquared,p.x,p.y,q.x,q.y,v,null,null,2);if(v.val<=this.m_convergenceOffset)break;else k*=.9,d.peLineType.geodesicCoordinate(this.m_a,this.m_eSquared,e.x,e.y,c,k,h.at(0),h.at(1)),l.setCoords(h.at(0).val,h.at(1).val)}catch(r){b.error=r,b.hasError=!0}finally{u.__disposeResources(b)}}this.m_cornerStep=2*Math.PI/Math.ceil(2*Math.PI/(k-0))}catch(c){a.error=
c,a.hasError=!0}finally{u.__disposeResources(a)}}setMinSegmentStep(){const a={stack:[],error:void 0,hasError:!1};try{var b=Math.min(Math.PI*this.m_a-this.m_absDistance,this.m_absDistance);b=Math.min(b,.125*this.m_a*Math.PI);const k=new n.Point2D,h=new n.Point2D;k.setCoords(0,10*this.m_rpu);h.setCoords(10*this.m_rpu,10*this.m_rpu);var c=u.__addDisposableResource(a,new d.PeDoubleClass,!1),e=u.__addDisposableResource(a,new d.PeDoubleClass,!1);const g=u.__addDisposableResource(a,new d.PeDoubleClass,!1);
d.peLineType.geodeticDistance(this.m_a,this.m_eSquared,k.x,k.y,h.x,h.y,g,c,e,this.m_curveType);const f=u.__addDisposableResource(a,new n.SimpleDisposableArray(new d.PeDoubleClass,new d.PeDoubleClass),!1),m=u.__addDisposableResource(a,new n.SimpleDisposableArray(new d.PeDoubleClass,new d.PeDoubleClass),!1),l=new n.Point2D,p=u.__addDisposableResource(a,new d.PeDoubleClass,!1),q=u.__addDisposableResource(a,new n.SimpleDisposableArray(new d.PeDoubleClass,new d.PeDoubleClass),!1),r=u.__addDisposableResource(a,
new n.SimpleDisposableArray(new d.PeDoubleClass,new d.PeDoubleClass),!1),t=u.__addDisposableResource(a,new n.SimpleDisposableArray(new d.PeDoubleClass,new d.PeDoubleClass),!1),v=u.__addDisposableResource(a,new n.SimpleDisposableArray(new d.PeDoubleClass,new d.PeDoubleClass),!1),x=new n.Point2D,z=new n.Point2D,B=new n.Point2D,A=new n.Point2D;let y=1;const C=c.val,aa=e.val+.5*Math.PI,J=g.val;d.peLineType.geodesicCoordinate(this.m_a,this.m_eSquared,k.x,k.y,b,C-.5*Math.PI,q.at(0),q.at(1));x.setCoords(q.at(0).val,
q.at(1).val);d.peLineType.geodesicCoordinate(this.m_a,this.m_eSquared,h.x,h.y,b,aa,r.at(0),r.at(1));for(z.setCoords(r.at(0).val,r.at(1).val);;){c={stack:[],error:void 0,hasError:!1};try{d.peLineType.geodeticCoordinate(this.m_a,this.m_eSquared,k.x,k.y,.5*(0+y)*J,C,f.at(0),f.at(1),this.m_curveType);l.setCoords(f.at(0).val,f.at(1).val);d.peLineType.geodeticDistance(this.m_a,this.m_eSquared,k.x,k.y,l.x,l.y,null,null,p,this.m_curveType);d.peLineType.geodesicCoordinate(this.m_a,this.m_eSquared,l.x,l.y,
b,p.val+.5*Math.PI,t.at(0),t.at(1));B.setCoords(t.at(0).val,t.at(1).val);const F=u.__addDisposableResource(c,new d.PeDoubleClass,!1),S=u.__addDisposableResource(c,new d.PeDoubleClass,!1);d.peLineType.geodeticDistance(this.m_a,this.m_eSquared,x.x,x.y,z.x,z.y,F,S,null,2);d.peLineType.geodeticCoordinate(this.m_a,this.m_eSquared,x.x,x.y,.5*F.val,S.val,v.at(0),v.at(1),2);A.setCoords(v.at(0).val,v.at(1).val);const T=u.__addDisposableResource(c,new d.PeDoubleClass,!1);d.peLineType.geodeticDistance(this.m_a,
this.m_eSquared,B.x,B.y,A.x,A.y,T,null,null,2);if(T.val<=this.m_convergenceOffset)break;else{e={stack:[],error:void 0,hasError:!1};try{y*=.9;d.peLineType.geodeticCoordinate(this.m_a,this.m_eSquared,k.x,k.y,y*J,C,m.at(0),m.at(1),this.m_curveType);h.setCoords(m.at(0).val,m.at(1).val);const G=u.__addDisposableResource(e,new d.PeDoubleClass,!1);d.peLineType.geodeticDistance(this.m_a,this.m_eSquared,k.x,k.y,h.x,h.y,null,null,G,this.m_curveType);d.peLineType.geodesicCoordinate(this.m_a,this.m_eSquared,
h.x,h.y,b,G.val+.5*Math.PI,r.at(0),r.at(1));z.setCoords(r.at(0).val,r.at(1).val)}catch(G){e.error=G,e.hasError=!0}finally{u.__disposeResources(e)}}}catch(F){c.error=F,c.hasError=!0}finally{u.__disposeResources(c)}}b=y*J;1E5<b&&(b=1E5);this.m_segmentStep=b}catch(k){a.error=k,a.hasError=!0}finally{u.__disposeResources(a)}}setConvergenceOffset(){let a;a=5E4<this.m_absDistance?100:1E4<this.m_absDistance?10:1;500>this.m_absDistance/a&&(a=this.m_absDistance/500);.01>a&&(a=.01);this.m_convergenceOffset=
a}}class U{constructor(a){this.m_bNeedsSimplify=this.m_bRunningInGnomonic=!1;this.m_gnomonic=null;this.m_gnomonicCenterRad=new n.Point2D;this.m_minGnomonicRadius=Number.NaN;this.m_progressTracker=a}isRunningInGnomonic(){return this.m_bRunningInGnomonic}needsSimplify(){return this.m_bNeedsSimplify}getGnomonic(){return this.m_gnomonic}}class R extends U{constructor(a,b,c){super(a.m_progressTracker);this.m_segIter=null;this.m_bNextSegmentCannotJoin=!1;this.m_currentDensifiedDelta=[0];this.m_lastAzimuth=
this.m_currentBufferedDelta=0;this.m_startAzimuth=[0];this.m_endAzimuth=[0];this.m_debugCounter=this.m_numWinds=0;this.m_bufferHelper=new d.Polygon;this.m_densifiedPoints=[];this.m_bufferer=a;this.m_multiPath=b;this.m_densified=c;this.m_bNeedsSimplify=!0;a=new d.Envelope2D;this.m_multiPath.queryEnvelope(a);a=a.getCenter();b=a.clone();b.scale(this.m_bufferer.m_rpu);this.m_gnomonic=new d.Gnomonic(this.m_bufferer.m_gcs,a);this.m_gnomonicCenterRad=b.clone();this.m_minGnomonicRadius=d.calculateTightRadiusInMeters(this.m_bufferer.m_a,
this.m_bufferer.m_eSquared,b,75/180*Math.PI)}next(){var a;if(this.m_bNextSegmentCannotJoin)return this.m_bNextSegmentCannotJoin=!1,this.m_segIter.nextSegment(),a=this.m_bufferHelper.clone();if(null===this.m_segIter){this.m_segIter=this.m_multiPath.getImpl().querySegmentIterator();if(!this.m_segIter.nextPath())return null;null!==this.m_densified&&this.m_densified.addPathPoint2D(null,0,!0)}if(!this.m_segIter.hasNextSegment())if(this.m_segIter.nextPath())null!=this.m_densified&&this.m_densified.addPathPoint2D(null,
0,!0);else return null;a=null;this.m_currentBufferedDelta=0;this.m_currentDensifiedDelta=[0];this.m_numWinds=0;this.m_lastAzimuth=Number.NaN;this.m_bNextSegmentCannotJoin=!1;let b=this.m_densifiedPoints.length=0;const c=new n.Point2D,e=new n.Point2D;for(;this.m_segIter.hasNextSegment()&&16>this.m_numWinds;){var k=this.m_segIter.nextSegment();c.setCoordsPoint2D(k.getStartXY());e.setCoordsPoint2D(k.getEndXY());c.scale(this.m_bufferer.m_rpu);e.scale(this.m_bufferer.m_rpu);if(d.checkStartForPoleTouch(c,
e))c.x=e.x;else if(d.checkEndForPoleTouch(c,e))e.x=c.x;else{var h=-1,g=-1;k=this.m_segIter.getPathIndex();var f=this.m_multiPath.getPathStart(k),m=this.m_multiPath.getPathEnd(k);h=this.m_segIter.getStartPointIndex();g=this.m_segIter.getEndPointIndex();--h;g+=1;h<f&&(h=this.m_multiPath.isClosedPath(k)?m-1:-1);g>m-1&&(g=this.m_multiPath.isClosedPath(k)?f:-1);-1!==h&&(k=this.m_multiPath.getXY(h),k.scale(this.m_bufferer.m_rpu),d.checkEndForPoleTouch(k,c)&&(c.x=k.x));-1!==g&&(k=this.m_multiPath.getXY(g),
k.scale(this.m_bufferer.m_rpu),d.checkStartForPoleTouch(e,k)&&(e.x=k.x))}this.m_densifiedPoints.length=0;k=d.geodeticDensifySegment(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_curveType,c,e,this.m_bufferer.m_segmentStep,Number.NaN,this.m_bufferer.m_radTolerance,this.m_startAzimuth,this.m_endAzimuth,this.m_densifiedPoints,this.m_currentDensifiedDelta);if(0===b)this.m_bRunningInGnomonic=this.isSegmentBufferInCurrentGnomonic(this.m_densifiedPoints),this.m_bRunningInGnomonic||(this.m_bRunningInGnomonic=
this.tryUpdateGnomonic(this.m_densifiedPoints));else if(this.m_bRunningInGnomonic){if(!this.isSegmentBufferInCurrentGnomonic(this.m_densifiedPoints)){this.m_segIter.previousSegment();this.m_segIter.previousSegment();this.m_segIter.nextSegment();break}}else if(P(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_densifiedPoints,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,null,null,null)){this.m_segIter.previousSegment();this.m_segIter.previousSegment();
this.m_segIter.nextSegment();break}0===k||d.checkForWithinPole(c,e)?(this.m_bufferHelper.setEmpty(),this.m_bufferer.bufferPoint2D(c,this.m_bRunningInGnomonic,this.m_bufferHelper),this.m_bNextSegmentCannotJoin=!0):(this.m_bufferHelper.setEmpty(),this.m_bNextSegmentCannotJoin=this.checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(k,this.m_bufferHelper));if(this.m_bNextSegmentCannotJoin){this.m_segIter.previousSegment();this.m_segIter.hasPreviousSegment()?(this.m_segIter.previousSegment(),this.m_segIter.nextSegment()):
this.m_segIter.resetToFirstSegment();null!=this.m_densified&&this.m_densified.insertPointsFromPoints(this.m_densified.getPathCount()-1,-1,this.m_densifiedPoints,0,this.m_densifiedPoints.length-1,!0);break}null!=this.m_densified&&this.m_densified.insertPointsFromPoints(this.m_densified.getPathCount()-1,-1,this.m_densifiedPoints,0,this.m_densifiedPoints.length-1,!0);null===a&&(a=new d.Polygon,a.addPathPoint2D(null,0,!0));this.addJoinAndBufferLeftSide(a);b++}this.m_currentDensifiedDelta=[0];if(0<b){k=
this.m_segIter.getStartPointIndex();for(f=this.m_segIter.getPathIndex();0<b;){this.m_segIter.previousSegment();c.setCoordsPoint2D(this.m_multiPath.getXY(this.m_segIter.getStartPointIndex()));e.setCoordsPoint2D(this.m_multiPath.getXY(this.m_segIter.getEndPointIndex()));c.scale(this.m_bufferer.m_rpu);e.scale(this.m_bufferer.m_rpu);if(this.m_bRunningInGnomonic)if(d.checkStartForPoleTouch(c,e))c.x=e.x;else if(d.checkEndForPoleTouch(c,e))e.x=c.x;else{var l=-1,p=-1;m=this.m_segIter.getPathIndex();h=this.m_multiPath.getPathStart(m);
g=this.m_multiPath.getPathEnd(m);l=this.m_segIter.getStartPointIndex();p=this.m_segIter.getEndPointIndex();--l;p+=1;l<h&&(l=this.m_multiPath.isClosedPath(m)?g-1:-1);p>g-1&&(p=this.m_multiPath.isClosedPath(m)?h:-1);-1!==l&&(m=this.m_multiPath.getXY(l),m.scale(this.m_bufferer.m_rpu),d.checkEndForPoleTouch(m,c)&&(c.x=m.x));-1!==p&&(m=this.m_multiPath.getXY(p),m.scale(this.m_bufferer.m_rpu),d.checkStartForPoleTouch(e,m)&&(e.x=m.x))}this.m_densifiedPoints.length=0;d.geodeticDensifySegment(this.m_bufferer.m_a,
this.m_bufferer.m_eSquared,this.m_bufferer.m_curveType,e,c,this.m_bufferer.m_segmentStep,Number.NaN,this.m_bufferer.m_radTolerance,this.m_startAzimuth,this.m_endAzimuth,this.m_densifiedPoints,this.m_currentDensifiedDelta);this.addJoinAndBufferLeftSide(a);b--}c.setCoordsPoint2D(this.m_multiPath.getXY(this.m_segIter.getStartPointIndex()));c.scale(this.m_bufferer.m_rpu);this.m_currentBufferedDelta=D(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_bufferer.m_absDistance,c,
this.m_lastAzimuth+.5*Math.PI,this.m_lastAzimuth+1.5*Math.PI,this.m_bufferer.m_cornerStep,this.m_bRunningInGnomonic,this.m_currentBufferedDelta,a);this.m_segIter.resetToVertex(k,f);this.m_segIter.nextSegment();return a}this.m_bNextSegmentCannotJoin=!1;this.m_segIter.nextSegment();return a=this.m_bufferHelper.clone()}isSegmentBufferInCurrentGnomonic(a){return null===this.m_gnomonic?!1:O(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,a,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,
this.m_gnomonicCenterRad,this.m_minGnomonicRadius)}tryUpdateGnomonic(a){const b=new n.Point2D,c=new n.Point2D,e=[0];if(!P(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,a,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,b,c,e))return this.m_gnomonic=null,!1;this.m_gnomonicCenterRad.setCoordsPoint2D(c);this.m_minGnomonicRadius=e[0];this.m_gnomonic=new d.Gnomonic(this.m_bufferer.m_gcs,b);return!0}checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(a,b){return this.m_bufferer.checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(this.m_densifiedPoints,
a,this.m_startAzimuth[0],this.m_endAzimuth[0],this.m_bRunningInGnomonic,b)}addJoinAndBufferLeftSide(a){var b=this.m_densifiedPoints[0],c=Number.NaN;let e=this.m_startAzimuth[0]-n.geometryHalfPi;const k=this.m_endAzimuth[0]+n.geometryHalfPi;let h=!1;if(!Number.isNaN(this.m_lastAzimuth)){this.m_lastAzimuth>=this.m_startAzimuth[0]?(c=this.m_lastAzimuth+n.geometryHalfPi,e=c+Math.PI-(this.m_lastAzimuth-this.m_startAzimuth[0])):(c=this.m_lastAzimuth+n.geometryHalfPi,e=c+Math.PI-(n.geometry2Pi-(this.m_startAzimuth[0]-
this.m_lastAzimuth)));h=this.m_lastAzimuth>=this.m_startAzimuth[0]&&this.m_lastAzimuth-this.m_startAzimuth[0]<=Math.PI?!1:this.m_lastAzimuth<this.m_startAzimuth[0]&&this.m_startAzimuth[0]-this.m_lastAzimuth>=Math.PI?!1:!0;let g=!1;Math.abs(e-c)<=.5*this.m_bufferer.m_cornerStep&&(h||(g=!0));g?(a.removePointFromPath(0,a.getPointCount()-1),this.m_bRunningInGnomonic||(b=new n.Point2D,b.setCoordsPoint2D(a.getXY(a.getPointCount()-1)),b.scale(this.m_bufferer.m_rpu),b.x-this.m_currentBufferedDelta<-Math.PI?
this.m_currentBufferedDelta-=n.geometry2Pi:b.x-this.m_currentBufferedDelta>Math.PI&&(this.m_currentBufferedDelta+=n.geometry2Pi)),e=.5*(e+c)):h?(c=new n.Point2D,c.setCoordsPoint2D(b),c.scale(1/this.m_bufferer.m_rpu),a.insertPoint2D(0,-1,c)):D(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_bufferer.m_absDistance,this.m_densifiedPoints[0],c,e,this.m_bufferer.m_cornerStep,this.m_bRunningInGnomonic,this.m_currentBufferedDelta,a)}this.m_startAzimuth[0]!==this.m_lastAzimuth&&
this.m_numWinds++;I(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_bufferer.m_absDistance,this.m_bufferer.m_curveType,this.m_densifiedPoints,e,k,this.m_bRunningInGnomonic,this.m_currentBufferedDelta,a);this.m_lastAzimuth=this.m_endAzimuth[0]}}class Z extends U{constructor(a,b){super(a.m_progressTracker);this.m_pointIndex=-1;this.m_bufferer=a;this.m_multiPoint=b;this.m_bNeedsSimplify=!1;a=new d.Envelope2D;this.m_multiPoint.queryEnvelope(a);a=a.getCenter();b=a.clone();b.scale(this.m_bufferer.m_rpu);
this.m_gnomonic=new d.Gnomonic(this.m_bufferer.m_gcs,a);this.m_gnomonicCenterRad=b.clone();this.m_minGnomonicRadius=d.calculateTightRadiusInMeters(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,b,75/180*Math.PI)}next(){this.m_bNeedsSimplify=!1;if(++this.m_pointIndex===this.m_multiPoint.getPointCount())return null;const a=this.m_multiPoint.getXY(this.m_pointIndex);a.scale(this.m_bufferer.m_rpu);this.m_bRunningInGnomonic=this.isPointBufferInCurrentGnomonic(a);this.m_bRunningInGnomonic||(this.m_bRunningInGnomonic=
this.tryUpdateGnomonic(a));const b=new d.Polygon;this.m_bNeedsSimplify=this.m_bufferer.bufferPoint2D(a,this.m_bRunningInGnomonic,b);return b}isPointBufferInCurrentGnomonic(a){return null===this.m_gnomonic?!1:Q(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,a,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,this.m_gnomonicCenterRad,this.m_minGnomonicRadius)}tryUpdateGnomonic(a){const b=new n.Point2D,c=new n.Point2D,e=[0];{var k=this.m_bufferer.m_a,h=this.m_bufferer.m_eSquared,
g=this.m_bufferer.m_rpu,f=this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio;const m=d.calculateTightRadiusInMeters(k,h,a,75/180*Math.PI);Q(k,h,a,f,a,m)?(null!==b&&(b.setCoordsPoint2D(a),b.scale(1/g)),null!==c&&c.setCoordsPoint2D(a),null!==e&&(e[0]=m),a=!0):a=!1}if(!a)return this.m_gnomonic=null,!1;this.m_gnomonicCenterRad.setCoordsPoint2D(c);this.m_minGnomonicRadius=e[0];this.m_gnomonic=new d.Gnomonic(this.m_bufferer.m_gcs,b);return!0}}class ba{getOperatorType(){return 10110}supportsCurves(){return!0}accelerateGeometry(a,
b,c){return!1}canAccelerateGeometry(a){return!1}executeMany(a,b,c,e,k,h,g,f){return g?(a=new V(a,b,c,e,k,!1,h,f),(new d.OperatorUnion).executeMany(a,b,f)):new V(a,b,c,e,k,!1,h,f)}execute(a,b,c,e,k,h,g){a=new L.SimpleGeometryCursor([a]);(b=this.executeMany(a,b,c,[e],k,!1,h,g).next())||w.throwInternalErrorException("geodesic buffer null output");return b}}class V extends L.GeometryCursor{constructor(a,b,c,e,k,h,g,f){super();this.m_currentUnionEnvelope2D=new d.Envelope2D;this.m_dindex=this.m_index=-1;
this.m_progressTracker=f;h&&w.throwNotImplementedException("");b||w.throwInvalidArgumentException("");0===b.getCoordinateSystemType()&&w.throwInvalidArgumentException("");this.m_inputGeoms=a;this.m_spatialReference=b;this.m_curveType=c;this.m_distances=e;this.m_convergenceOffset=k;this.m_bOutlineOnly=h;this.m_bUnion=g}next(){let a;for(;a=this.m_inputGeoms.next();)return w.throwIfMesh(a),this.m_index=this.m_inputGeoms.getGeometryID(),this.m_dindex+1<this.m_distances.length&&this.m_dindex++,this.geodesicBuffer(a,
this.m_distances[this.m_dindex]);return null}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}geodesicBuffer(a,b){a:{var c=this.m_spatialReference;var e=this.m_curveType,k=this.m_convergenceOffset,h=this.m_progressTracker;b<Number.MAX_VALUE&&b>-Number.MAX_VALUE||w.throwInvalidArgumentException("Geodesic_bufferer.buffer - bad distance");w.throwIfMesh(a);a=W.clean(a);var g=a.getGeometryType();if(w.isMultiVertex(g)){var f=a.getPointCount();if(8E6<Math.abs(b)&&(50<f||g!==w.GeometryType.enumMultiPoint&&
4===e&&2<f)){g=0<b?1:-1;f=b;let m=1;do m++,f=(Math.abs(f)-7E6)*g;while(8E6<Math.abs(f));f=b;for(b=0;b<m-1;b++)a=H(a,c,e,7E6*g,k,m,h),f=(Math.abs(f)-7E6)*g;c=a=H(a,c,e,f,k,m,h);break a}}c=H(a,c,e,b,k,1,h)}return c}}K.OperatorGeodesicBuffer=ba;Object.defineProperty(K,Symbol.toStringTag,{value:"Module"})});