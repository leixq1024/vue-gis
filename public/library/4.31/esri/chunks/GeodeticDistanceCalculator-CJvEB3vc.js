// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.31/esri/copyright.txt for details.
//>>built
define("exports ./tslib.es6 ./Geometry ./QuadraticBezier ./Transformation2D ./Distance2DCalculator-BX0Ep7eP ./OperatorShapePreservingDensify".split(" "),function(I,t,l,g,p,H,R){function J(a,b){let c=0,d;d=a.xmin-b.xmax;d>c&&(c=d);d=b.xmin-a.xmax;d>c&&(c=d);return c}function K(a){return{outPoint:void 0===a?new p.Point2D:a.clone()}}function y(){return new g.Envelope2D}class S{[Symbol.dispose](){this.m_peR1.destroy();this.m_peR2.destroy();this.m_peR3.destroy();this.m_peR3=this.m_peR2=this.m_peR1=null}constructor(a,
b,c){this.m_peR1=new g.PeDoubleClass;this.m_peR2=new g.PeDoubleClass;this.m_peR3=new g.PeDoubleClass;void 0!==a?this.reset(a,b,c):this.reset(1,0,1)}reset(a,b,c){this.m_a=a;this.m_e2=b;this.m_b=this.m_a*Math.sqrt(1-this.m_e2);this.m_unitToDegree=c;this.m_unitToRad=.017453292519943295*c;this.m_u180=180/this.m_unitToDegree;this.m_u360=360/this.m_unitToDegree}calculateBbox(a,b,c,d){var e=this.m_peR1,h=this.m_peR2;g.peLineType.geodeticDistance(this.m_a,this.m_e2,a*this.m_unitToRad,b*this.m_unitToRad,c*
this.m_unitToRad,d*this.m_unitToRad,this.m_peR3,e,h,0);var f=Math.cos(e.val);h=Math.cos(h.val+3.141592653589793);var k=g.peMath.phiToEta(this.m_e2,b*this.m_unitToRad);k=Math.sin(e.val)*Math.cos(k);e=b;0>f*h&&(e=g.peMath.etaToPhi(this.m_e2,Math.acos(Math.abs(k))*(0>f?-1:1))/this.m_unitToRad);c=p.fmod((c-a)*this.m_unitToRad,2*Math.PI);Math.abs(c)>Math.PI&&(c=0<c?c-2*Math.PI:c+2*Math.PI);c/=this.m_unitToRad;c=a+c;f=new g.Envelope2D;f.xmin=Math.min(a,c);f.xmax=Math.max(a,c);f.ymin=Math.min(b,d);f.ymin=
Math.min(f.ymin,e);f.ymax=Math.max(b,d);f.ymax=Math.max(f.ymax,e);return f}minDistanceGeodesic(a,b){const c=b.xmin===b.xmax&&b.ymin===b.ymax;if(a.xmin===a.xmax&&a.ymin===a.ymax&&c)return this.lowerDistanceGeodetic_(a.xmin,a.ymin,b.xmin,b.ymin);b=this.normalizeGeodesic_(b,a);return b.xmax<a.xmin||b.xmin>a.xmax||b.ymax<a.ymin||b.ymin>a.ymax?a.ymin>=b.ymax?this.minDistanceGeodesicUpDown_(a,b):b.ymin>=a.ymax?this.minDistanceGeodesicUpDown_(b,a):a.xmin>b.xmax?this.minDistanceGeodesicLeftRight_(b,a):this.minDistanceGeodesicLeftRight_(a,
b):0}sqrMaxMinDistanceGeodesic(a,b){l.geometryReleaseAssert(0);return 0}maxDistanceGeodesic(a,b){l.geometryReleaseAssert(0);return 0}sqrMinDistance(a,b){l.geometryReleaseAssert(0);return 0}sqrMaxDistance(a,b){l.geometryReleaseAssert(0);return 0}sqrMaxMinDistance(a,b){l.geometryReleaseAssert(0);return 0}calculateMaxDim(a){l.geometryReleaseAssert(0);return 0}lowerDistanceGeodesic(a,b,c,d){l.geometryReleaseAssert(0);return 0}upperDistanceGeodesic(a,b,c,d){l.geometryReleaseAssert(0);return 0}normalizeGeodesic_(a,
b){const c=a.clone(),d=a.clone();let e=J(c,b);if(0===e)return c;for(;d.xmax>b.xmin;){d.xmin-=this.m_u360;d.xmax-=this.m_u360;const h=J(d,b);if(h<e&&(c.assign(d),e=h,0===e))return c}for(d.assign(a);d.xmin<b.xmax&&!(d.xmin+=this.m_u360,d.xmax+=this.m_u360,a=J(d,b),a<e&&(c.assign(d),e=a,0===e)););return c}lowerDistanceGeodetic_(a,b,c,d){const e=this.m_peR1,h=this.m_b*this.m_b/this.m_a;b=g.peMath.phiToPhig(this.m_e2,this.m_unitToRad*b);d=g.peMath.phiToPhig(this.m_e2,this.m_unitToRad*d);g.peLineType.geodeticDistance(h,
0,this.m_unitToRad*a,b,this.m_unitToRad*c,d,e,null,null,0);return e.val}upperDistanceGeodetic_(a,b,c,d){l.geometryReleaseAssert(0);return 0}minDistanceGeodesicUpDown_(a,b){if(b.xmin<=a.xmin?b.xmax>=a.xmin:a.xmax>=b.xmin)return this.lowerDistanceGeodetic_(0,a.ymin,0,b.ymax);if(b.xmin>a.xmax){var c=this.lowerDistanceGeodeticSegMeridional_(a.xmax,a.ymin,a.ymax,b.xmin,b.ymin,b.ymax);if(b.xmax-a.xmin<this.m_u180)return c;a=this.lowerDistanceGeodeticSegMeridional_(a.xmin,a.ymin,a.ymax,b.xmax,b.ymin,b.ymax);
return Math.min(c,a)}c=this.lowerDistanceGeodeticSegMeridional_(a.xmin,a.ymin,a.ymax,b.xmax,b.ymin,b.ymax);if(a.xmax-b.xmin<this.m_u180)return c;a=this.lowerDistanceGeodeticSegMeridional_(a.xmax,a.ymin,a.ymax,b.xmin,b.ymin,b.ymax);return Math.min(c,a)}minDistanceGeodesicLeftRight_(a,b){let c=Math.abs(a.xmax-b.xmin);for(;c>this.m_u180;)c-=this.m_u360;let d=Math.abs(a.xmin-b.xmax);for(;d>this.m_u180;)d-=this.m_u360;return Math.abs(c)<=Math.abs(d)?this.minDistanceGeodesicLeftRightNormalized_(a,b):this.minDistanceGeodesicLeftRightNormalized_(b,
a)}minDistanceGeodesicLeftRightNormalized_(a,b){let c,d;c=this.lowerDistanceGeodetic_(a.xmax,a.ymin,b.xmin,b.ymin);a.ymin>=b.ymin&&a.ymin<=b.ymax&&(d=this.lowerDistanceGeodeticPtMeridional_(a.xmax,a.ymin,b.xmin,b.ymin,b.ymax),c=Math.min(c,d));b.ymin>=a.ymin&&b.ymin<=a.ymax&&(d=this.lowerDistanceGeodeticPtMeridional_(b.xmin,b.ymin,a.xmax,a.ymin,a.ymax),c=Math.min(c,d));d=this.lowerDistanceGeodetic_(a.xmax,a.ymax,b.xmin,b.ymax);c=Math.min(c,d);a.ymax>=b.ymin&&a.ymax<=b.ymax&&(d=this.lowerDistanceGeodeticPtMeridional_(a.xmax,
a.ymax,b.xmin,b.ymin,b.ymax),c=Math.min(c,d));b.ymax>=a.ymin&&b.ymax<=a.ymax&&(d=this.lowerDistanceGeodeticPtMeridional_(b.xmin,b.ymax,a.xmax,a.ymin,a.ymax),c=Math.min(c,d));return c}normalizeDistance_(a){l.geometryReleaseAssert(0);return 0}lowerDistanceGeodeticSegMeridional_(a,b,c,d,e,h){let f=this.lowerDistanceGeodeticPtMeridional_(a,b,d,e,h);const k=this.lowerDistanceGeodeticPtMeridional_(a,c,d,e,h);e=this.lowerDistanceGeodeticPtMeridional_(d,e,a,b,c);a=this.lowerDistanceGeodeticPtMeridional_(d,
h,a,b,c);f=Math.min(f,k);e=Math.min(e,a);return Math.min(f,e)}minDistanceGeodesicPointBox_(a,b,c){l.geometryReleaseAssert(0);return 0}lowerDistanceGeodeticPtMeridional_(a,b,c,d,e){const h=this.m_b*this.m_b/this.m_a;b=g.peMath.phiToPhig(this.m_e2,this.m_unitToRad*b);var f=g.peMath.phiToPhig(this.m_e2,this.m_unitToRad*d),k=g.peMath.phiToPhig(this.m_e2,this.m_unitToRad*e);e=this.m_peR1;d=this.m_peR2;g.peLineType.geodeticDistance(h,0,this.m_unitToRad*c,f,this.m_unitToRad*a,b,e,null,null,0);g.peLineType.geodeticDistance(h,
0,this.m_unitToRad*c,k,this.m_unitToRad*a,b,d,null,null,0);var n=g.curvToCart(1,0,new p.Point2D(this.m_unitToRad*a,b));f=g.curvToCart(1,0,new p.Point2D(this.m_unitToRad*c,f));c=g.curvToCart(1,0,new p.Point2D(this.m_unitToRad*c,k));k=new g.Point3D;k.setCrossProductVector(f,c);var m=f.dotProduct(c);if(1.568E-10>k.length())return 0<=m?Math.min(e.val,d.val):0;k=k.getUnitVector();m=new g.Point3D;m.setCrossProductVector(k,n);if(1.568E-10>m.length())return Math.min(e.val,d.val)-1E-5*h;m=m.getUnitVector();
n=n.sub(k.mul(n.dotProduct(k)));m=new g.Point3D;m.setCrossProductVector(f,n);const q=new g.Point3D;q.setCrossProductVector(n,c);let r=0<k.dotProduct(m)&&0<k.dotProduct(q);r||(n.negateThis(),m.setCrossProductVector(f,n),q.setCrossProductVector(n,c),r=0<k.dotProduct(m)&&0<k.dotProduct(q));return r?(n=n.getUnitVector(),f=g.cartToCurv(1,0,n),c=this.m_peR3,g.peLineType.geodeticDistance(h,0,this.m_unitToRad*a,b,f.x,f.y,c,null,null,0),Math.min(Math.min(e.val,d.val),c.val)):Math.min(e.val,d.val)}fixAngle(a){l.geometryReleaseAssert(0);
return 0}moveCloser(a,b){l.geometryReleaseAssert(0);return 0}}class L{}class M{constructor(a,b,c,d,e=0,h=4){this.m_ptDistFrom=new p.Point2D;this.m_segStartPt=new p.Point2D;this.m_segEndPt=new p.Point2D;this.m_geodeticLength=new g.PeDoubleClass;this.m_az12=new g.PeDoubleClass;this.m_minGeodeticDist=new g.PeDoubleClass;this.m_segStartPt3d=new g.Point3D;this.m_segEndPt3d=new g.Point3D;this.m_sr=d;this.m_distCurveType=e;this.m_segCurveType=h;this.m_inputGCS=this.m_sr.getGCS();this.m_rpu=this.m_inputGCS.getUnit().getUnitToBaseFactor();
this.m_bIsPannablePcs=2===this.m_sr.getCoordinateSystemType()&&this.m_sr.isPannable();d=g.makeSpheroidData();this.m_inputGCS.querySpheroidData(d);this.m_a=d.majorSemiAxis;this.m_eSquared=d.e2;this.setPointDistFrom(a);this.setSegmentEndPoints(b,c)}setSegmentEndPoints(a,b){this.m_segStartPt.assign(a);this.m_segEndPt.assign(b);this.m_bIsPannablePcs||(this.m_segStartPt.mulThis(this.m_rpu),this.m_segEndPt.mulThis(this.m_rpu));2===this.m_segCurveType&&(this.m_segStartPt3d.assign(g.curvToCart(this.m_a,this.m_eSquared,
this.m_segStartPt)),this.m_segEndPt3d.assign(g.curvToCart(this.m_a,this.m_eSquared,this.m_segEndPt)));this.calculateAndUpdateSegmentLength()}setPointDistFrom(a){this.m_ptDistFrom.assign(a);this.m_ptDistFrom.scale(this.m_rpu)}setSegmentCurveType(a){this.m_segCurveType=a}setDistanceCurveType(a){this.m_distCurveType=a}makeFunctor(){return a=>{let b;switch(this.m_segCurveType){case 0:case 1:case 3:const c={stack:[],error:void 0,hasError:!1};try{const d=t.__addDisposableResource(c,new g.PeDoubleClass,
!1),e=t.__addDisposableResource(c,new g.PeDoubleClass,!1);g.peLineType.geodeticCoordinate(this.m_a,this.m_eSquared,this.m_segStartPt.x,this.m_segStartPt.y,this.m_geodeticLength.val*a,this.m_az12.val,d,e,this.m_segCurveType);b=new p.Point2D(d.val,e.val);break}catch(d){c.error=d,c.hasError=!0}finally{t.__disposeResources(c)}case 2:a=g.Point3D.lerp(this.m_segStartPt3d,this.m_segEndPt3d,a);b=g.cartToCurv(this.m_a,this.m_eSquared,a);break;case 4:b=p.Point2D.lerp(this.m_segStartPt,this.m_segEndPt,a);this.m_bIsPannablePcs&&
(g.PEProjToGeogCenterPoint2D(this.m_sr,0,[b],1),b.mulThis(this.m_rpu));break;default:l.throwInternalErrorException("Invalid curve type")}g.peLineType.geodeticDistance(this.m_a,this.m_eSquared,this.m_ptDistFrom.x,this.m_ptDistFrom.y,b.x,b.y,this.m_minGeodeticDist,null,null,this.m_distCurveType);return this.m_minGeodeticDist.val}}calculateAndUpdateSegmentLength(){switch(this.m_segCurveType){case 0:case 2:case 1:case 3:g.peLineType.geodeticDistance(this.m_a,this.m_eSquared,this.m_segStartPt.x,this.m_segStartPt.y,
this.m_segEndPt.x,this.m_segEndPt.y,this.m_geodeticLength,this.m_az12,null,this.m_segCurveType);break;case 4:this.m_geodeticLength.val=p.Point2D.distance(this.m_segStartPt,this.m_segEndPt);break;default:l.throwInternalErrorException("Invalid curve type")}}[Symbol.dispose](){this.m_geodeticLength[Symbol.dispose]();this.m_az12[Symbol.dispose]();this.m_minGeodeticDist[Symbol.dispose]()}}class T{[Symbol.dispose](){this.m_envHelper[Symbol.dispose]()}constructor(a,b,c,d,e){this.m_boxGeomA=y();this.m_boxGeomB=
y();this.m_envGeomA=new g.Envelope2D;this.m_envGeomB=new g.Envelope2D;this.m_progressCounter=0;this.m_transformPCS2GCS=null;this.m_segmentBoxesA=new Map;this.m_segmentBoxesB=new Map;this.m_boundaryPtsA=[];this.m_boundaryPtsB=[];this.m_scaleToRadians=new p.Transformation2D;this.m_scaleToDegrees=new p.Transformation2D;this.m_inputSR=a;this.m_distCurveType=b;this.m_progressTracker=c;this.m_maxDistance=d;this.m_maxDeviation=e;this.m_inputGCS=a.getGCS();this.m_peGeogcs=this.m_inputGCS.getPECoordSys();
this.m_tolerance=0;a=g.makeSpheroidData();this.m_inputGCS.querySpheroidData(a);this.m_a=a.majorSemiAxis;this.m_eSquared=a.e2;this.m_rpu=this.m_inputGCS.getUnit().getUnitToBaseFactor();this.m_envHelper=new S(this.m_a,this.m_eSquared,1);4===this.m_distCurveType&&(this.m_distCurveType=0);this.m_boxGeomA.setEmpty();this.m_boxGeomB.setEmpty();this.m_envGeomA.setEmpty();this.m_envGeomB.setEmpty();this.m_bIsPannablePcs=2===this.m_inputSR.getCoordinateSystemType()&&this.m_inputSR.isPannable()}progress(a){}calculate(a,
b,c,d){const e=K(),h=K();a.queryEnvelope(this.m_envGeomA);b.queryEnvelope(this.m_envGeomB);if(this.checkGeometriesIntersect(a,b,e,h))return c&&c.outPoint.assign(e.outPoint),d&&d.outPoint.assign(h.outPoint),0;a=this.prepareGeometry(a);if(a.isEmpty())return Number.NaN;b=this.prepareGeometry(b);if(b.isEmpty())return Number.NaN;this.m_tolerance=this.computeTolerance(a,b);b=this._ExecuteBruteForce(a,b,e,h);if(b>=this.m_maxDistance)return Number.NaN;c&&(this.prepareOutput(e),c.outPoint.assign(e.outPoint));
d&&(this.prepareOutput(h),d.outPoint.assign(h.outPoint));return b}createDistanceFunctor(a,b,c){a=new M(a,b,c,this.m_inputSR,this.m_distCurveType);if(this.m_bIsPannablePcs||1===this.m_inputSR.getCoordinateSystemType())return a;a.setSegmentCurveType(2);return a}_NormalizeAndProject(a){this.m_inputSR.isPannable()&&(a=(new g.OperatorProject).foldInto360Range(a,this.m_inputSR));if(2===this.m_inputSR.getCoordinateSystemType()){const b=g.createEx(this.m_inputSR,this.m_inputGCS,null);a=(new g.OperatorProject).execute(a,
b,this.m_progressTracker)}return a}_ExecuteBruteForce(a,b,c,d){switch(a.getGeometryType()){case l.GeometryType.enumPoint:return this.calculateDistanceGeodeticPointGeometry(a,b,c,d);case l.GeometryType.enumMultiPoint:return this.calculateDistanceGeodeticMultipointGeometry(a,b,c,d);case l.GeometryType.enumPolyline:case l.GeometryType.enumPolygon:case l.GeometryType.enumEnvelope:return this.calculateDistanceGeodeticMultipathGeometry(a,b,c,d);default:l.throwInvalidArgumentException("")}}calculateDistanceGeodeticPointGeometry(a,
b,c,d){switch(b.getGeometryType()){case l.GeometryType.enumPoint:return this.calculateDistanceGeodeticPointPoint(a,b,c,d);case l.GeometryType.enumMultiPoint:return this.calculateDistanceGeodeticPointMultipoint(a,b,c,d);case l.GeometryType.enumPolyline:case l.GeometryType.enumPolygon:return this.calculateDistanceGeodeticPointMultipath(a,b,c,d);default:l.throwInvalidArgumentException("")}}calculateDistanceGeodeticPointPoint(a,b,c,d){const e={stack:[],error:void 0,hasError:!1};try{const h=a.getXY();
h.scale(this.m_rpu);const f=b.getXY();f.scale(this.m_rpu);c.outPoint.assign(h);d.outPoint.assign(f);const k=t.__addDisposableResource(e,new g.PeDoubleClass,!1);g.peLineType.geodeticDistance(this.m_a,this.m_eSquared,h.x,h.y,f.x,f.y,k,null,null,this.m_distCurveType);return k.val}catch(h){e.error=h,e.hasError=!0}finally{t.__disposeResources(e)}}calculateDistanceGeodeticPointMultipoint(a,b,c,d){const e={stack:[],error:void 0,hasError:!1};try{this.computeEnvelopesAndBoxes(a,b);const h=this.estimateMinimumDistance(c,
d);let f=h<this.m_maxDistance?h:this.m_maxDistance;const k=a.getXY();k.scale(this.m_rpu);c.outPoint.assign(k);const n=g.curvToCart(this.m_a,this.m_eSquared,k),m=new p.Point2D,q=b.getImpl(),r=t.__addDisposableResource(e,new g.PeDoubleClass,!1),v=q.getPointCount();for(a=0;a<v;++a){q.queryXY(a,m);m.scale(this.m_rpu);const x=g.curvToCart(this.m_a,this.m_eSquared,m);if(!(g.Point3D.distance(n,x)>f||this.m_envHelper.minDistanceGeodesic(this.m_boxGeomA,this.m_boxGeomB)>f)&&(g.peLineType.geodeticDistance(this.m_a,
this.m_eSquared,k.x,k.y,m.x,m.y,r,null,null,this.m_distCurveType),r.val<f&&(f=r.val,d.outPoint=m,0===f)))return f}return f===this.m_maxDistance?Number.POSITIVE_INFINITY:f}catch(h){e.error=h,e.hasError=!0}finally{t.__disposeResources(e)}}calculateDistanceGeodeticPointMultipath(a,b,c,d){const e={stack:[],error:void 0,hasError:!1};try{const h=new p.Point2D,f=new p.Point2D;h.assign(a.getXY());f.assign(a.getXY());c.outPoint.assign(f.mul(this.m_rpu));this.m_bIsPannablePcs&&g.PEGeogToProj(this.m_inputSR,
[h],1,!1);this.computeEnvelopesAndBoxes(a,b);const k=this.estimateMinimumDistance(c,d);let n=k<this.m_maxDistance?k:this.m_maxDistance;const m=b.getImpl(),q=new p.Point2D(0,0),r=new p.Point2D(0,0);c=[1];const v=this.canUseSpatialTree(a,b),x=new L;v&&this.buildSpatialTree(x,b);const D=y();D.setCoords({xmin:f.x,ymin:f.y,xmax:f.x,ymax:f.y});const B=t.__addDisposableResource(e,this.createDistanceFunctor(f,q,r),!1),z=m.querySegmentIterator();z.stripAttributes();if(v)l.geometryReleaseAssert(0);else for(;z.nextPath();)for(;z.hasNextSegment();){const A=
z.nextSegment(),E=this.findOrComputeBoxSegment(z.getStartPointIndex(),A,this.m_segmentBoxesB);if(this.m_envHelper.minDistanceGeodesic(D,E)>n)continue;const w=this.calculateDistanceGeodeticPointSegment(h,f,A,c,B);if(w.second<n&&(this.updateOutputSegment(d,A,w.first),n=w.second,0===n))return 0}return n===this.m_maxDistance?Number.POSITIVE_INFINITY:n}catch(h){e.error=h,e.hasError=!0}finally{t.__disposeResources(e)}}calculateDistanceGeodeticMultipointGeometry(a,b,c,d){switch(b.getGeometryType()){case l.GeometryType.enumPoint:return this.calculateDistanceGeodeticPointMultipoint(b,
a,d,c);case l.GeometryType.enumMultiPoint:return this.calculateDistanceGeodeticMultipointMultipoint(a,b,c,d);case l.GeometryType.enumPolyline:case l.GeometryType.enumPolygon:case l.GeometryType.enumEnvelope:return this.calculateDistanceGeodeticMultipointMultipath(a,b,c,d);default:l.throwInvalidArgumentException("")}}calculateDistanceGeodeticMultipointMultipoint(a,b,c,d){const e={stack:[],error:void 0,hasError:!1};try{const h=t.__addDisposableResource(e,new g.PeDoubleClass,!1);this.computeEnvelopesAndBoxes(a,
b);const f=this.estimateMinimumDistance(c,d);let k=f<this.m_maxDistance?f:this.m_maxDistance;const n=new p.Point2D,m=new p.Point2D,q=a.getImpl(),r=b.getImpl(),v=y(),x=q.getPointCount(),D=r.getPointCount();for(a=0;a<x;++a){n.assign(q.getXY(a));v.setCoords({xmin:n.x,ymin:n.y,xmax:n.x,ymax:n.y});if(this.m_envHelper.minDistanceGeodesic(v,this.m_boxGeomB)>k)continue;n.scale(this.m_rpu);const B=g.curvToCart(this.m_a,this.m_eSquared,n);for(b=0;b<D;++b){m.assign(r.getXY(b));m.scale(this.m_rpu);const z=g.curvToCart(this.m_a,
this.m_eSquared,m);if(!(g.Point3D.distance(B,z)>=k)&&(g.peLineType.geodeticDistance(this.m_a,this.m_eSquared,n.x,n.y,m.x,m.y,h,null,null,this.m_distCurveType),h.val<k&&(c.outPoint.assign(n),d.outPoint.assign(m),k=h.val,0===k)))return k}}return k===this.m_maxDistance?Number.POSITIVE_INFINITY:k}catch(h){e.error=h,e.hasError=!0}finally{t.__disposeResources(e)}}calculateDistanceGeodeticMultipointMultipath(a,b,c,d){const e={stack:[],error:void 0,hasError:!1};try{const f=b.getImpl().querySegmentIterator();
f.stripAttributes();this.computeEnvelopesAndBoxes(a,b);var h=this.estimateMinimumDistance(c,d);let k=h<this.m_maxDistance?h:this.m_maxDistance;const n=new p.Point2D,m=new p.Point2D(0,0),q=new p.Point2D(0,0),r=new p.Point2D(0,0);h=[0];const v=y(),x=t.__addDisposableResource(e,this.createDistanceFunctor(m,q,r),!1),D=new L,B=this.canUseSpatialTree(a,b);B&&this.buildSpatialTree(D,b);const z=a.getPointCount();for(b=0;b<z;++b)if(n.assign(a.getXY(b)),m.assign(a.getXY(b)),this.m_bIsPannablePcs&&g.PEGeogToProj(this.m_inputSR,
[n],1,!1),v.setCoords({xmin:m.x,ymin:m.y,xmax:m.x,ymax:m.y}),!(this.m_envHelper.minDistanceGeodesic(v,this.m_boxGeomB)>k))if(x.setPointDistFrom(m),B)l.geometryReleaseAssert(0);else{for(;f.nextPath();)for(;f.hasNextSegment();){const A=f.nextSegment();if(this.m_envHelper.minDistanceGeodesic(v,this.findOrComputeBoxSegment(f.getStartPointIndex(),A,this.m_segmentBoxesB))>k)continue;const E=this.calculateDistanceGeodeticPointSegment(n,m,A,h,x);if(E.second<k&&(c.outPoint.assign(m.mul(this.m_rpu)),this.updateOutputSegment(d,
A,E.first),k=E.second,0===k))return 0}f.resetToFirstPath()}return k===this.m_maxDistance?Number.POSITIVE_INFINITY:k}catch(f){e.error=f,e.hasError=!0}finally{t.__disposeResources(e)}}calculateDistanceGeodeticMultipathGeometry(a,b,c,d){switch(b.getGeometryType()){case l.GeometryType.enumPoint:return this.calculateDistanceGeodeticPointMultipath(b,a,d,c);case l.GeometryType.enumMultiPoint:return this.calculateDistanceGeodeticMultipointMultipath(b,a,d,c);case l.GeometryType.enumPolyline:case l.GeometryType.enumPolygon:case l.GeometryType.enumEnvelope:return this.calculateDistanceGeodeticMultipathMultipath(a,
b,c,d);default:l.throwInvalidArgumentException("")}}calculateDistanceGeodeticMultipathMultipath(a,b,c,d){a=[a];const e=[b];b=this.swapGeometries(a,e);const h=a[0],f=e[0];this.computeEnvelopesAndBoxes(a[0],e[0]);a=this.estimateMinimumDistance(c,d);a=this.calculateDistanceGeodeticMultipathMultipath_(h,f,c,d,a);b&&(d.outPoint=p.swap(c.outPoint,c.outPoint=d.outPoint));return a}calculateDistanceGeodeticMultipathMultipath_(a,b,c,d,e=Number.MAX_VALUE){const h={stack:[],error:void 0,hasError:!1};try{const f=
new p.Point2D(0,0),k=new p.Point2D,n=new p.Point2D(0,0),m=new p.Point2D,q=new p.Point2D(0,0),r=new p.Point2D,v=new p.Point2D,x=new p.Point2D,D=[new p.Point2D],B=[0],z=[0],A=y(),E=y(),w=t.__addDisposableResource(h,this.createDistanceFunctor(q,f,n),!1),U=new L,N=this.canUseSpatialTree(a,b);N&&this.buildSpatialTree(U,b);const G=b.querySegmentIterator();G.stripAttributes();const O=new g.SegmentBuffer,P=H.shuffleMultipathSegments(a);for(b=0;b<P.length;++b){const Q=P[b];a.getSegmentBuffer(Q,O,!0);const C=
O.get();A.assign(this.findOrComputeBoxSegment(Q,C,this.m_segmentBoxesA));if(N)l.geometryReleaseAssert(0);else if(q.assign(C.getStartXY()),r.assign(C.getStartXY()),v.assign(C.getEndXY()),x.assign(C.getEndXY()),this.m_bIsPannablePcs&&(g.PEProjToGeogCenterPoint2D(this.m_inputSR,0,[r],1),g.PEProjToGeogCenterPoint2D(this.m_inputSR,0,[x],1)),!(this.m_envHelper.minDistanceGeodesic(A,this.m_boxGeomB)>e)){for(;G.nextPath();){for(;G.hasNextSegment();){const F=G.nextSegment();f.assign(F.getStartXY());k.assign(F.getStartXY());
n.assign(F.getEndXY());m.assign(F.getEndXY());if(C.intersect(F,D,B,z,this.m_tolerance))return this.updateOutputSegment(c,C,B[0]),this.updateOutputSegment(d,F,z[0]),0;this.m_bIsPannablePcs&&(g.PEProjToGeogCenterPoint2D(this.m_inputSR,0,[k],1),g.PEProjToGeogCenterPoint2D(this.m_inputSR,0,[m],1));E.assign(this.findOrComputeBoxPoint(G.getStartPointIndex(),k,m,this.m_segmentBoxesB));if(this.m_envHelper.minDistanceGeodesic(A,E)>e)continue;w.setSegmentEndPoints(f,n);w.setPointDistFrom(r);let u=g.brentMinimization(w.makeFunctor(),
0,1,1E-10);if(u.second<e&&(c.outPoint.assign(r.mul(this.m_rpu)),this.updateOutputSegment(d,F,u.first),e=u.second,0===e))break;w.setPointDistFrom(x);u=g.brentMinimization(w.makeFunctor(),0,1,1E-10);if(u.second<e&&(c.outPoint.assign(x.mul(this.m_rpu)),this.updateOutputSegment(d,F,u.first),e=u.second,0===e))break;w.setSegmentEndPoints(q,v);w.setPointDistFrom(k);u=g.brentMinimization(w.makeFunctor(),0,1,1E-10);if(u.second<e&&(this.updateOutputSegment(c,C,u.first),d.outPoint.assign(k.mul(this.m_rpu)),
e=u.second,0===e))break;w.setPointDistFrom(m);u=g.brentMinimization(w.makeFunctor(),0,1,1E-10);if(u.second<e&&(this.updateOutputSegment(c,C,u.first),d.outPoint.assign(m.mul(this.m_rpu)),e=u.second,0===e))break}if(0===e)return 0}G.resetToFirstPath()}}return e===this.m_maxDistance?Number.POSITIVE_INFINITY:e}catch(f){h.error=f,h.hasError=!0}finally{t.__disposeResources(h)}}calculateDistanceGeodeticPointSegment(a,b,c,d,e){const h=c.getStartXY(),f=c.getEndXY();if(c.intersectPoint(a,d,this.m_tolerance))return p.makePair(d[0],
0);e.setPointDistFrom(b);e.setSegmentEndPoints(h,f);return g.brentMinimization(e.makeFunctor(),0,1,1E-10)}prepareGeometry(a){let b=a.clone();a=a.getGeometryType();if(a===l.GeometryType.enumPoint||a===l.GeometryType.enumMultiPoint)return this._NormalizeAndProject(b);a===l.GeometryType.enumEnvelope&&(b=this.envelopeToPolygon(b));if(this.m_inputSR.isPannable())return this.prepareGeometryPannable(b,4);if(2===this.m_inputSR.getCoordinateSystemType()){b=g.processWithPCSHorizon(b,this.m_inputSR,0,null);
if(b.isEmpty())return b;b=(new R.OperatorShapePreservingDensify).execute(b,this.m_inputSR,5E4,this.m_maxDeviation/2,0,null);a=this.m_inputSR.getSRToGCSTransform();return(new g.OperatorProject).execute(b,a,this.m_progressTracker)}a=new g.Envelope2D;b.queryLooseEnvelope(a);const c=this.m_inputSR.getPannableExtent();if(a.ymin<c.ymin||a.ymax>c.ymax){const d=new g.Envelope2D(a.xmin-1,c.ymin,a.xmax+1,c.ymax);b=(new g.OperatorClip).execute(b,d,this.m_inputSR,this.m_progressTracker);if(b.isEmpty())return b}a.width()>
2*c.width()&&(b=g.foldGeometry(b,-2*c.width(),2*c.width(),this.m_inputSR,!0,0,!0,this.m_progressTracker));return b}prepareGeometryPannable(a,b){const c=new g.Envelope2D;a.queryEnvelope(c);var d=this.m_inputSR.getPannableExtent();if(d.containsEnvelope(c))return a;const e=new p.Envelope1D;d.queryIntervalX(e);d=new p.Envelope1D;c.queryIntervalX(d);return a=e.contains(d)?g.clipGeometryFromTopAndBottom(a,this.m_inputSR):(new g.OperatorProject).foldInto360RangeGeodetic(a,this.m_inputSR,b)}prepareOutput(a){a.outPoint.scale(1/
this.m_rpu);2===this.m_inputSR.getCoordinateSystemType()&&g.PEGeogToProj(this.m_inputSR,[a.outPoint],1,!1)}updateOutputSegment(a,b,c){b.queryCoord2D(c,a.outPoint);this.m_bIsPannablePcs&&g.PEProjToGeogCenterPoint2D(this.m_inputSR,0,[a.outPoint],1);a.outPoint.mulThis(this.m_rpu)}computeTolerance(a,b){a.queryEnvelope(this.m_envGeomA);b.queryEnvelope(this.m_envGeomB);a=new g.Envelope2D(this.m_envGeomA);a.mergeEnvelope2D(this.m_envGeomB);return g.calculateToleranceFromGeometryForRel(null,a)}envelopeToPolygon(a){const b=
new g.Polygon;b.addEnvelope(a,!1);return b}computeEnvelopesAndBoxes(a,b){a.queryEnvelope(this.m_envGeomA);b.queryEnvelope(this.m_envGeomB);this.m_boxGeomA=this.computeBoxGeometry(a,this.m_boundaryPtsA,this.m_segmentBoxesA);this.m_boxGeomB=this.computeBoxGeometry(b,this.m_boundaryPtsB,this.m_segmentBoxesB)}computeBoxGeometry(a,b,c){switch(a.getGeometryType()){case l.GeometryType.enumPoint:return this.computeBoxPoint(a,b);case l.GeometryType.enumMultiPoint:return this.computeBoxMultiPoint(a,b);case l.GeometryType.enumPolyline:case l.GeometryType.enumPolygon:return this.computeBoxMultiPath(a,
b,c);default:l.throwInternalErrorException("Invalid geometry type")}}computeBoxPoint(a,b){a=a.getXY();b.length=1;b[0]=a.mul(this.m_rpu);b=y();b.setCoords({xmin:a.x,ymin:a.y,xmax:a.x,ymax:a.y});return b}computeBoxSegment(a){l.geometryReleaseAssert(0);return{}}computeBoxMultiPoint(a,b){var c=!0;for(var d=0;d<a.getPointCount();++d){const e=a.getXY(d);if(c){b.length=4;for(c=0;c<b.length;++c)b[c]=e.clone();c=!1}e.x<b[0].x&&b[0].assign(e);e.y>b[1].y&&b[1].assign(e);e.x>b[2].x&&b[2].assign(e);e.y<b[3].y&&
b[3].assign(e)}for(d=0;d<b.length;++d)b[d].mulThis(this.m_rpu);b=y();a.queryEnvelope(b);return b}computeBoxMultiPath(a,b,c){var d=!0;const e=y();e.setEmpty();a=a.querySegmentIterator();for(a.stripAttributes();a.nextPath();)for(;a.hasNextSegment();){var h=a.nextSegment(),f=h.getStartXY();h=h.getEndXY();this.m_bIsPannablePcs&&(g.PEProjToGeogCenterPoint2D(this.m_inputSR,0,[f],1),g.PEProjToGeogCenterPoint2D(this.m_inputSR,0,[h],1));if(d){b.length=4;for(d=0;d<b.length;++d)b[d]=f.clone();d=!1}f.x<b[0].x&&
b[0].assign(f);f.y>b[1].y&&b[1].assign(f);f.x>b[2].x&&b[2].assign(f);f.y<b[3].y&&b[3].assign(f);h.x<b[0].x&&b[0].assign(h);h.y>b[1].y&&b[1].assign(h);h.x>b[2].x&&b[2].assign(h);h.y<b[3].y&&b[3].assign(h);f=this.findOrComputeBoxPoint(a.getStartPointIndex(),f,h,c);e.mergeEnvelope2D(f)}for(c=0;c<b.length;++c)b[c].mulThis(this.m_rpu);return e}findOrComputeBoxSegment(a,b,c){if(!c.has(a)){var d=y();b.queryEnvelope(d);this.m_bIsPannablePcs&&(b=p.Point2D.construct(d.xmin,d.ymin),d=p.Point2D.construct(d.xmax,
d.ymax),g.PEProjToGeogCenterPoint2D(this.m_inputSR,0,[b],1),g.PEProjToGeogCenterPoint2D(this.m_inputSR,0,[d],1),d=this.m_envHelper.calculateBbox(b.x,b.y,d.x,d.y));c.set(a,d);return d}return c.get(a)}findOrComputeBoxPoint(a,b,c,d){if(!d.has(a)){let e=y();e.setCoords({xmin:b.x,ymin:b.y,xmax:c.x,ymax:c.y});this.m_bIsPannablePcs&&(e=this.m_envHelper.calculateBbox(e.xmin,e.ymin,e.xmax,e.ymax));d.set(a,e);return e}return d.get(a)}checkPointInPolygon(a,b){l.geometryReleaseAssert(0);return!1}estimateMinimumDistance(a,
b){const c={stack:[],error:void 0,hasError:!1};try{var d=m=>g.curvToCart(this.m_a,this.m_eSquared,m);const e=this.m_boundaryPtsA.map(d),h=this.m_boundaryPtsB.map(d);let f=Number.MAX_VALUE,k=d=0;for(let m=0;m<e.length;++m)for(let q=0;q<h.length;++q){const r=g.Point3D.distance(e[m],h[q]);r<f&&(f=r,d=m,k=q)}a.outPoint.assign(this.m_boundaryPtsA[d]);b.outPoint.assign(this.m_boundaryPtsB[k]);const n=t.__addDisposableResource(c,new g.PeDoubleClass,!1);g.peLineType.geodeticDistance(this.m_a,this.m_eSquared,
this.m_boundaryPtsA[d].x,this.m_boundaryPtsA[d].y,this.m_boundaryPtsB[k].x,this.m_boundaryPtsB[k].y,n,null,null,this.m_distCurveType);return n.val}catch(e){c.error=e,c.hasError=!0}finally{t.__disposeResources(c)}}swapGeometries(a,b){const c=l.vertexCount(a[0]),d=l.vertexCount(b[0]);return c>d?(b[0]=p.swap(a[0],a[0]=b[0]),this.m_envGeomB=p.swap(this.m_envGeomA,this.m_envGeomA=this.m_envGeomB),!0):!1}canUseSpatialTree(a,b){return!1}checkGeometriesIntersect(a,b,c,d){var e=a.getGeometryType(),h=b.getGeometryType();
if(this.m_envGeomA.isIntersecting(this.m_envGeomB)){if(e===l.GeometryType.enumPoint&&2===b.getDimension()){var f=[0],k=[a.getXY()];g.testPointsInArea2D(b,k,1,this.m_tolerance,f);if(0!==f[0])return c.outPoint.assign(k[0]),d.outPoint.assign(k[0]),!0}else if(h===l.GeometryType.enumPoint&&2===a.getDimension()&&(f=[2],k=[b.getXY()],g.testPointsInArea2D(a,k,1,this.m_tolerance,f),0!==f[0]))return c.outPoint.assign(k[0]),d.outPoint.assign(k[0]),!0;if(e===l.GeometryType.enumMultiPoint&&2===b.getDimension())return this.multipointIntersectsArea(a,
b,c,d);if(h===l.GeometryType.enumMultiPoint&&2===a.getDimension())return this.multipointIntersectsArea(b,a,d,c);f=a;k=b;e===l.GeometryType.enumEnvelope&&(f=e=this.envelopeToPolygon(a),e=l.GeometryType.enumPolygon);h===l.GeometryType.enumEnvelope&&(k=b=this.envelopeToPolygon(b),h=l.GeometryType.enumPolygon);if(l.isMultiPath(e)&&l.isMultiPath(h)&&(b=f.querySegmentIterator(),e=k.querySegmentIterator(),h=H.makeOutput(),a=H.makeOutput(),H.weakIntersectionTest(f,k,b,e,h,a)))return c.outPoint.assign(h.outPoint),
d.outPoint.assign(h.outPoint),!0}return!1}multipointIntersectsArea(a,b,c,d){const e=a.getPointCount();for(let h=0;h<e;++h){const f=[2],k=a.getXY(h);g.testPointsInArea2D(b,[k],1,this.m_tolerance,f);if(0!==f[0])return c.outPoint.assign(k),d.outPoint.assign(k),!0}return!1}getNearestNeighbourVisitor(a,b,c,d,e,h,f){l.geometryReleaseAssert(0);return{}}buildSpatialTree(a,b){l.geometryReleaseAssert(0)}}I.GeodeticDistanceCalculator=T;I.GeodeticDistanceFunctor=M;I.makeOutput=K});