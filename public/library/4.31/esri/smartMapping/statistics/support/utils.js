// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.31/esri/copyright.txt for details.
//>>built
define("exports ../../../geometry ../../../core/Error ../../../core/screenUtils ../../../core/timeUtils ../../../geometry/SpatialReference ../../../geometry/support/quantizationUtils ../../../geometry/support/spatialReferenceUtils ../../../layers/support/fieldUtils ../../../renderers/support/heatmapUtils ../../support/utils ../../../statistics/utils ../../../support/arcadeOnDemand ../../../geometry/Point".split(" "),function(m,U,v,L,C,M,N,G,D,H,O,z,P,Q){function I(a){a=R.exec(a);if(!a)return null;
const {hh:b,mm:c,ss:d,ms:f}=a.groups;return Number(b)*C.millisecondsPerTimeUnit.hours+Number(c)*C.millisecondsPerTimeUnit.minutes+Number(d)*C.millisecondsPerTimeUnit.seconds+Number(f||0)}function J(a,b){a=null!=a?a:"";null!=b&&b&&(a=a?"("+a+") AND ("+b+")":b);return a}function S(a){const b=a.layer;return a.fields.filter(c=>!b.getField(c))}function T(a){const b=a.layer;return a.fields.filter(c=>{c=b.getFieldUsageInfo(c);return!c||!c.supportsStatistics})}let t=null;const R=/^(?<hh>([0-1][0-9])|([2][0-3])):(?<mm>[0-5][0-9])(:(?<ss>[0-5][0-9]))?([.](?<ms>\d+))?$/;
m.calculateHeatmapStats=function(a,b=18,c,d,f){const q=new Float64Array(d*f);b=Math.round(L.pt2px(b));let n=Number.POSITIVE_INFINITY,h=Number.NEGATIVE_INFINITY;c=H.createValueFunction(c);for(const {geometry:k,attributes:r}of a){const {x:p,y}=k;a=Math.max(0,p-b);var l=Math.max(0,y-b);const E=Math.min(f,y+b),F=Math.min(d,p+b),A=+c(r);for(;l<E;l++)for(let w=a;w<F;w++){var e=l*d+w;const B=H.evaluateDensityKernel(w-p,l-y,b)*A;e=q[e]+=B;n=Math.min(n,e);h=Math.max(h,e)}}return{min:n,max:h}};m.getDataValues=
async function(a,b,c=!0){if(!b)return[];const {field:d,field2:f,field3:q,fieldDelimiter:n,fieldInfos:h,timeZone:l}=a;var e=d&&h?.find(x=>x.name.toLowerCase()===d.toLowerCase());const k=e?D.isTimeOnlyField(e):!1,r=e?O.isAnyDateField(e):!1,p=a.valueExpression,y=a.normalizationType,E=a.normalizationField,F=a.normalizationTotal,A=[];e=a.viewInfoParams;let w=null,B=null;if(p){if(!t){const {arcadeUtils:x}=await P.loadArcade();t=x}t.hasGeometryOperations(p)&&await t.enableGeometryOperations();w=t.createFunction(p);
B=e?t.getViewInfo({viewingMode:e.viewingMode,scale:e.scale,spatialReference:new M(e.spatialReference)}):null}a=a.fieldInfos;const K=b[0]&&"declaredClass"in b[0]&&"esri.Graphic"===b[0].declaredClass||!a?null:{fields:a};b.forEach(x=>{var u=x.attributes;if(p){var g=t.createExecContext(K?{...x,layer:K}:x,B,l);g=t.executeFunction(w,g)}else u&&(g=u[d],f?(g=`${z.processNullValue(g)}${n}${z.processNullValue(u[f])}`,q&&(g=`${g}${n}${z.processNullValue(u[q])}`)):"string"===typeof g&&c&&(r?g=g?(new Date(g)).getTime():
null:k&&(g=g?I(g):null)));y&&"number"===typeof g&&isFinite(g)&&(u=u&&parseFloat(u[E]),g=z.getNormalizedValue(g,y,u,F));A.push(g)});return A};m.getRangeExpr=function(a,b,c){b=null!=b?a+" \x3e\x3d "+b:"";a=null!=c?a+" \x3c\x3d "+c:"";c="";return(c=b&&a?J(b,a):b||a)?"("+c+")":""};m.getSQLFilterForNormalization=function(a){const b=a.field,c=a.normalizationType;a=a.normalizationField;let d;if("field"===c)d="(NOT "+a+" \x3d 0)";else if("log"===c||"natural-log"===c||"square-root"===c)d=`(${b} > 0)`;return d};
m.getSumOfAttributesExpr=function(a,b,c){const d=[],f=[],q=[],n=[],h=[];a.forEach((e,k)=>{const r=e.field?"field":"expression",p=e.field||e.valueExpression;e.field?(h.push(p),f.push(`var ${r}${k} = Number($feature["${p}"]);`)):(d.push(`function getValueForExpr${k}() {\n  ${p} \n}`),f.push(`var ${r}${k} = Number(getValueForExpr${k}());`));c||q.push(`${r}${k} = IIf(${r}${k} < 0, 0, ${r}${k});`);n.push(`${r}${k}`)});a=d.length?null:h.reduce((e,k)=>`${e} + ${k}`);let l=null;b||c?b?c||a&&(l=`(( ${a} ) >= 0)`):
a&&(l=`(( ${a} ) <> 0)`):a&&(l=`(( ${a} ) > 0)`);return{valueExpression:[d.length?d.join("\n"):"",f.join("\n"),q.join("\n"),`var total = ${n.join(" + ")};`,"return total;"].filter(Boolean).join("\n\n"),sqlExpression:a,sqlWhere:l}};m.mergeWhereClauses=J;m.quantizeFeatures=function(a,b,c,d){const f=G.isWrappable(c)?G.getInfo(c):null,q=f?Math.round((f.valid[1]-f.valid[0])/b.scale[0]):null;return a.map(n=>{const h=new Q(n.geometry);N.quantizePoint(b,h,h);if(f){var l=q??0,e=d[0];0>h.x?h.x+=l:h.x>e&&(h.x-=
l)}n.geometry=h;return n})};m.timeOnlyToMilliseconds=I;m.verifyBasicFieldValidity=function(a,b,c){const d=S({layer:a,fields:b});if(d.length)return new v(c,"Unknown fields: "+d.join(", ")+". You can only use fields defined in the layer schema");a=T({layer:a,fields:b});if(a.length)return new v(c,"Unsupported fields: "+a.join(", ")+". You can only use fields that can be fetched i.e. AdapterFieldUsageInfo.supportsStatistics must be true")};m.verifyFieldType=function(a,b,c,d){let f;b?b.name!==a.objectIdField&&
d.includes(b.type)||(f=new v(c,"'field' should be one of these types: "+d.join(","))):f=new v(c,"'field' is not defined in the layer schema");return f};m.verifyFilterValidity=function(a,b){if(a&&"intersects"!==a.spatialRelationship)return new v(b,"Only 'intersects' spatialRelationship is supported for featureFilter")};m.verifyNumericField=function(a,b,c){let d;b?b.name!==a.objectIdField&&D.isNumericField(b)||(d=new v(c,"'field' should be one of these numeric types: "+D.numericTypes.join(","))):d=
new v(c,"'field' is not defined in the layer schema");return d};Object.defineProperty(m,Symbol.toStringTag,{value:"Module"})});