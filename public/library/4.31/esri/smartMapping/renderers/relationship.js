// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.31/esri/copyright.txt for details.
//>>built
define("exports ../../core/colorUtils ../../core/Error ../../core/lang ../../intl/messages ../../renderers/support/AuthoringInfo ../../renderers/support/AuthoringInfoClassBreakInfo ../../renderers/support/AuthoringInfoFieldInfo ../heuristics/outline ../heuristics/sizeRange ./type ./support/regenerateUtils ./support/utils ../support/binningUtils ../support/adapters/support/layerUtils ../symbology/relationship ../../symbols/support/utils".split(" "),function(z,L,l,M,N,F,A,B,O,P,Q,r,v,R,C,D,S){async function G(a){if(!(a?.layer&&
a.view&&a.field1&&a.field2))throw new l("relationship-renderer:missing-parameters","'layer', 'view', 'field1' and 'field2' parameters are required");a.forBinning&&R.verifyBinningParams(a,"relationship-renderer");const b={...a,layer:a.layer,field1:a.field1,field2:a.field2};b.symbolType??(b.symbolType="2d");b.defaultSymbolEnabled??(b.defaultSymbolEnabled=!0);b.classificationMethod??(b.classificationMethod="quantile");b.numClasses??(b.numClasses=3);b.focus??(b.focus=null);if(!T.has(b.classificationMethod))throw new l("relationship-renderer:invalid-parameters",
`classification method ${b.classificationMethod} is not supported`);if(2>b.numClasses||4<b.numClasses)throw new l("relationship-renderer:invalid-parameters","'numClasses' must be 2, 3 or 4");if(a.focus&&!U.has(a.focus))throw new l("relationship-renderer:invalid-parameters","'focus' must be 'HH', 'HL', 'LH', 'LL' or null");var c=a.forBinning?C.binningCapableLayerTypes:C.featureCapableLayerTypes;a=C.createLayerAdapter(b.layer,c,a.forBinning);if(!a)throw new l("relationship-renderer:invalid-parameters",
"'layer' must be one of these types: "+C.getLayerTypeLabels(c).join(", "));await a.load(null!=b.signal?{signal:b.signal}:null);c=a.geometryType;const d=b.symbolType.includes("3d");b.outlineOptimizationEnabled="polygon"===c?b.outlineOptimizationEnabled:!1;b.sizeOptimizationEnabled="point"===c||"multipoint"===c||"polyline"===c?b.sizeOptimizationEnabled:!1;if("mesh"===c)b.symbolType="3d-volumetric",b.colorMixMode=b.colorMixMode||"replace",b.edgesType=b.edgesType||"none";else{if("3d-volumetric-uniform"===
b.symbolType&&"point"!==c)throw new l("relationship-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(d&&"polygon"===c)throw new l("relationship-renderer:not-supported","3d symbols are not supported for polygon layers");if(b.symbolType.includes("3d-volumetric")&&(!b.view||"3d"!==b.view.type))throw new l("relationship-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'");
}const {field1:e,field2:f}=b;c=[e.field,f.field];e.normalizationField&&c.push(e.normalizationField);f.normalizationField&&c.push(f.normalizationField);if(c=v.verifyBasicFieldValidity(a,c,"relationship-renderer:invalid-parameters"))throw c;return{...b,layer:a}}async function V(a){await r.processRegenerateParams(a,"regenerate-relationship-renderer");const b=await r.getRendererToUpdate(a);var c=r.getStyleType(b);if(!c||!["relationship","relationship-size"].includes(c))throw new l("regenerate-relationship-renderer:invalid-parameters",
"Renderer is invalid");const {layer:d,forBinning:e,filter:f,view:g,signal:h}=a;c=r.hasOutlineVV(b);const k=r.hasScaleDependentSizeVV(b),{field1:m,field2:n,classificationMethod:p,focus:q,numClasses:u}=b.authoringInfo;c=await G({layer:d,field1:{field:m.field,normalizationField:m.normalizationField,label:m.label},field2:{field:n.field,normalizationField:n.normalizationField,label:n.label},classificationMethod:p,numClasses:u,focus:q,outlineOptimizationEnabled:c,sizeOptimizationEnabled:k,forBinning:e,
filter:f,view:g,signal:h});return{...a,creatorParameters:c,renderer:b}}async function W(a){if(!a?.renderer||!a.numClasses)throw new l("update-relationship-renderer:missing-parameters","'renderer' and 'numClasses' parameters are required");const {field1:b,field2:c,renderer:d,numClasses:e,colors:f}=a,g=e**2;if((b||c)&&!(b&&c&&b.field&&c.field))throw new l("update-relationship-renderer:missing-parameters","'field1' and 'field2' parameters are required");if(b&&!b.classBreakInfos||c&&!c.classBreakInfos)throw new l("update-relationship-renderer:missing-parameters",
"'field1.classBreakInfos' and 'field2.classBreakInfos' are required");if(!d.authoringInfo)throw new l("update-relationship-renderer:missing-parameters","'renderer.authoringInfo' is required");if(d.uniqueValueInfos?.length!==g)throw new l("update-relationship-renderer:invalid-parameters",`Renderer must have ${g} unique value infos to support ${e} classes`);if(f&&f.length!==g)throw new l("update-relationship-renderer:invalid-parameters",`The scheme must have ${g} colors`);return a}async function X(a){let b=
a.relationshipScheme,c=null;var d=null;d=await v.getBasemapInfo(a.basemap,a.view);c=null!=d.basemapId?d.basemapId:null;d=null!=d.basemapTheme?d.basemapTheme:null;if(b)return{scheme:D.cloneScheme(b),basemapId:c,basemapTheme:d};if(a=D.getSchemes({basemapTheme:d,geometryType:a.geometryType,theme:a.theme,worldScale:a.worldScale,view:a.view}))b=a.primaryScheme,c=a.basemapId,d=a.basemapTheme;return{scheme:b,basemapId:c,basemapTheme:d}}function H(a,b){a=M.clone(Y[a]);return D.flatten2DArray(a,b)}function Z(a,
b){return H(a,b).map(c=>({value:c,count:0}))}function I(a,b,c,d){const {field:e,normalizationField:f}=a,{field:g,normalizationField:h}=b;a=c.map(k=>[k.minValue,k.maxValue]);d=d.map(k=>[k.minValue,k.maxValue]);b=aa[a.length];return`\n  var field1 = $feature['${e}'];\n  var field2 = $feature['${g}'];\n  var hasNormField1 = ${f?"true":"false"};\n  var hasNormField2 = ${h?"true":"false"};\n  var normField1 = ${f?`$feature['${f}']`:"null"};\n  var normField2 = ${h?`$feature['${h}']`:"null"};\n\n  if (\n    IsEmpty(field1) ||\n    IsEmpty(field2) ||\n    (hasNormField1 && (IsEmpty(normField1) || normField1 == 0)) ||\n    (hasNormField2 && (IsEmpty(normField2) || normField2 == 0))\n  ) {\n    return null;\n  }\n\n  var value1 = IIf(hasNormField1, (field1 / normField1), field1);\n  var value2 = IIf(hasNormField2, (field2 / normField2), field2);\n\n  var breaks1 = ${JSON.stringify(a)};\n  var breaks2 = ${JSON.stringify(d)};\n  var classCodes = ${JSON.stringify(b)};\n\n  function getClassCode(value, breaks) {\n    var code = null;\n\n    for (var i in breaks) {\n      var info = breaks[i];\n      if (value >= info[0] && value <= info[1]) {\n        code = classCodes[i];\n        break;\n      }\n    }\n\n    return code;\n  }\n\n  var code1 = getClassCode(value1, breaks1);\n  var code2 = getClassCode(value2, breaks2);\n\n  var classValue = IIf(IsEmpty(code1) || IsEmpty(code2), null, code1 + code2);\n  return classValue;\n  `}
async function ba(a,b,c){var d=await N.fetchMessageBundle("esri/smartMapping/t9n/smartMapping");const {basemap:e,classificationMethod:f,field1:g,field2:h,focus:k,numClasses:m,signal:n}=a;var p=a.layer,q=b.classBreakInfos;const u=c.classBreakInfos;if(m!==q.length||q.length!==u.length)throw new l("relationship-renderer:error","incompatible class breaks");var w=Z(m,k);const x=I(a.field1,a.field2,q,u),y=(await X({basemap:e,geometryType:p.geometryType,theme:"default",relationshipScheme:a.relationshipScheme,
worldScale:!!a.symbolType?.includes("3d-volumetric"),view:a.view})).scheme;a=await Q.createRenderer({layer:p,basemap:e,valueExpression:x,valueExpressionTitle:d.relationship.legendTitle,numTypes:-1,sortEnabled:!1,defaultSymbolEnabled:a.defaultSymbolEnabled,typeScheme:{colors:D.getColors(y,m,k),...y},statistics:{uniqueValueInfos:w},legendOptions:a.legendOptions,outlineOptimizationEnabled:a.outlineOptimizationEnabled,sizeOptimizationEnabled:a.sizeOptimizationEnabled,symbolType:a.symbolType,colorMixMode:a.colorMixMode,
edgesType:a.edgesType,filter:a.filter,view:a.view,signal:n});p=a.renderer;w=p.uniqueValueInfos;d=d.relationship;for(const t of w??[])t.label=d[t.value];q=new F({type:"relationship",classificationMethod:f,numClasses:m,focus:k,field1:new B.AuthoringInfoFieldInfo({field:g.field,normalizationField:g.normalizationField,label:g.label,classBreakInfos:q.map(({minValue:t,maxValue:E})=>new A.AuthoringInfoClassBreakInfo({minValue:t,maxValue:E}))}),field2:new B.AuthoringInfoFieldInfo({field:h.field,normalizationField:h.normalizationField,
label:h.label,classBreakInfos:u.map(({minValue:t,maxValue:E})=>new A.AuthoringInfoClassBreakInfo({minValue:t,maxValue:E}))})});p.authoringInfo=q;return{renderer:p,classBreaks:{field1:b,field2:c},uniqueValueInfos:a.uniqueValueInfos,relationshipScheme:y,basemapId:a.basemapId,basemapTheme:a.basemapTheme}}function ca(a,b,c){const d=H(b,c);a.sort((e,f)=>{e=d.indexOf(e.value);f=d.indexOf(f.value);let g=0;e<f?g=-1:e>f&&(g=1);return g})}function da(a,b){a.authoringInfo??(a.authoringInfo=new F);const c=a.authoringInfo;
c.numClasses=b.numClasses;c.focus=b.focus||null;c.focus||delete c.focus;const {field1:d,field2:e}=b;c.field1=new B.AuthoringInfoFieldInfo({field:d.field,normalizationField:d.normalizationField,label:d.label,classBreakInfos:d.classBreakInfos.map(f=>new A.AuthoringInfoClassBreakInfo({minValue:f.minValue,maxValue:f.maxValue}))});c.field2=new B.AuthoringInfoFieldInfo({field:e.field,normalizationField:e.normalizationField,label:e.label,classBreakInfos:e.classBreakInfos.map(f=>new A.AuthoringInfoClassBreakInfo({minValue:f.minValue,
maxValue:f.maxValue}))});a.authoringInfo=c}async function J(a){const {layer:b,classificationMethod:c,field1:d,field2:e,numClasses:f,filter:g,view:h,signal:k}=a;a={layer:b,classificationMethod:c,field:e.field,normalizationField:e.normalizationField,normalizationType:e.normalizationField?"field":null,minValue:e.minValue,maxValue:e.maxValue,analyzeData:!(null!=e.minValue&&null!=e.maxValue),numClasses:f,filter:g,view:h,signal:k};const [m,n]=await Promise.all([v.getClassBreaks({layer:b,classificationMethod:c,
field:d.field,normalizationField:d.normalizationField,normalizationType:d.normalizationField?"field":null,minValue:d.minValue,maxValue:d.maxValue,analyzeData:!(null!=d.minValue&&null!=d.maxValue),numClasses:f,filter:g,view:h,signal:k}),v.getClassBreaks(a)]);if(!m||!n)throw new l("relationship-renderer:error","error when calculating class breaks");return{field1:m.result,field2:n.result}}async function K(a){a=await W(a);const {field1:b,field2:c,renderer:d,numClasses:e,focus:f,colors:g}=a,h=d.clone();
h.valueExpression=I(b,c,b.classBreakInfos,c.classBreakInfos);const k=h.uniqueValueInfos??[];ca(k,e,f);if(g){const m=L.createUniqueColors(g,g.length);k.forEach((n,p)=>S.applyColorToSymbol(n.symbol,m[p]))}da(h,a);return h}const T=new Set(["equal-interval","natural-breaks","quantile"]),U=new Set(["HH","HL","LH","LL"]),Y={2:[["HL","HH"],["LL","LH"]],3:[["HL","HM","HH"],["ML","MM","MH"],["LL","LM","LH"]],4:[["HL","HM1","HM2","HH"],["M2L","M2M1","M2M2","M2H"],["M1L","M1M1","M1M2","M1H"],["LL","LM1","LM2",
"LH"]]},aa={2:["L","H"],3:["L","M","H"],4:["L","M1","M2","H"]};z.createRenderer=async function(a){a=await G(a);const {field1:b,field2:c}=await J(a);return ba(a,b,c)};z.regenerateRenderer=async function(a){const {creatorParameters:b,view:c,signal:d,filter:e,renderer:f}=await V(a),{layer:g,field1:h,field2:k,numClasses:m,focus:n,outlineOptimizationEnabled:p,sizeOptimizationEnabled:q}=b,{field1:u,field2:w}=await J(b),[x,y,t]=await Promise.all([K({field1:{...h,classBreakInfos:u.classBreakInfos},field2:{...k,
classBreakInfos:w.classBreakInfos},renderer:f,numClasses:m,focus:n}),p?O({layer:g,view:c,signal:d,filter:e}).catch(v.errorCallback):null,q?P({layer:g,view:c,signal:d,filter:e}).catch(v.errorCallback):null]);r.spliceVisualVariables(x,y?.visualVariables,r.findOutlineVVIndex);r.spliceVisualVariables(x,t?.minSize,r.findScaleDependentSizeVVIndex);return{renderer:x}};z.updateRenderer=K;Object.defineProperty(z,Symbol.toStringTag,{value:"Module"})});