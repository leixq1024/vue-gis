// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.31/esri/copyright.txt for details.
//>>built
define("exports ../../renderers/ClassBreaksRenderer ../../renderers/DictionaryRenderer ../../renderers/DotDensityRenderer ../../renderers/HeatmapRenderer ../../renderers/PieChartRenderer ../../renderers/Renderer ../../renderers/SimpleRenderer ../../renderers/UniqueValueRenderer ../../renderers/support/jsonUtils ../../core/Logger ../../core/Error ../heuristics/outline ../heuristics/sizeRange ./support/utils ../support/binningUtils ../support/adapters/support/layerUtils ../symbology/location".split(" "),
function(n,B,C,D,E,F,G,t,H,I,J,g,u,v,f,w,h,k){async function x(b){if(!b?.layer)throw new g("location-renderer:missing-parameters","'layer' parameter is required");b.forBinning&&w.verifyBinningParams(b,"location-renderer");const a={...b,layer:b.layer};a.symbolType=a.symbolType||"2d";var c=b.forBinning?h.binningCapableLayerTypes:h.featureCapableLayerTypes;b=h.createLayerAdapter(a.layer,c,b.forBinning);if(!b)throw new g("location-renderer:invalid-parameters","'layer' must be one of these types: "+h.getLayerTypeLabels(c).join(", "));
a.layer=b;await b.load(null!=a.signal?{signal:a.signal}:null);c=b.geometryType;a.outlineOptimizationEnabled="polygon"===c?a.outlineOptimizationEnabled:!1;a.sizeOptimizationEnabled="point"===c||"multipoint"===c||"polyline"===c?a.sizeOptimizationEnabled:!1;if("mesh"===c)a.symbolType="3d-volumetric",a.colorMixMode=a.colorMixMode||"replace",a.edgesType=a.edgesType||"none";else{if("3d-volumetric-uniform"===a.symbolType&&"point"!==c)throw new g("location-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");
if(a.symbolType.includes("3d-volumetric")&&(!a.view||"3d"!==a.view.type))throw new g("location-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'");}return a}async function y(b,a){let c=b.locationScheme,e=null;var d=null;d=await f.getBasemapInfo(b.basemap,b.view);e=null!=d.basemapId?d.basemapId:null;d=null!=d.basemapTheme?d.basemapTheme:null;if(c)return{scheme:k.cloneScheme(c),basemapId:e,basemapTheme:d};
if(b=k.getSchemes({basemapTheme:d,geometryType:a,worldScale:!!b.symbolType?.includes("3d-volumetric"),view:b.view}))c=b.primaryScheme,e=b.basemapId,d=b.basemapTheme;return{scheme:c,basemapId:e,basemapTheme:d}}n.createRenderer=async function(b){var a=await x(b);const c=a.layer.geometryType;b=await y(a,c);const e=b.scheme;if(!e)throw new g("location-renderer:insufficient-info","Unable to find location scheme");const {view:d,layer:p,signal:q,filter:r}=a,[l,m]=await Promise.all([a.outlineOptimizationEnabled?
u({view:d,layer:p,signal:q,filter:r}).catch(f.errorCallback):null,a.sizeOptimizationEnabled?v({view:d,layer:p,signal:q,filter:r}).catch(f.errorCallback):null]),z=l?.opacity;a=new t({symbol:f.createSymbol(c,{type:a.symbolType,color:e.color,size:f.getSymbolSizeFromScheme(e,c),outline:f.getSymbolOutlineFromScheme(e,c,z),meshInfo:{colorMixMode:a.colorMixMode,edgesType:a.edgesType}})});l?.visualVariables.length&&(a.visualVariables=l.visualVariables.map(A=>A.clone()));m?.minSize&&(a.visualVariables?a.visualVariables.push(m.minSize):
a.visualVariables=[m.minSize]);return{renderer:a,locationScheme:k.cloneScheme(e),basemapId:b.basemapId,basemapTheme:b.basemapTheme}};Object.defineProperty(n,Symbol.toStringTag,{value:"Module"})});