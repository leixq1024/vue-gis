// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.31/esri/copyright.txt for details.
//>>built
define("../../../chunks/tslib.es6 ../../../Graphic ../../../core/arrayUtils ../../../core/Error ../../../core/promiseUtils ../../../core/accessorSupport/decorators/property ../../../core/has ../../../core/Logger ../../../core/accessorSupport/decorators/subclass ../../../intl/date ../../../layers/support/arcgisLayerUrl ../../../layers/support/fieldUtils ../../../rest/generateRenderer ../../../rest/support/AutoIntervalBinParameters ../../../rest/support/BinsQuery ../../../rest/support/DateBinParameters ../../../rest/support/FixedBoundariesBinParameters ../../../rest/support/FixedIntervalBinParameters ../../../rest/support/GenerateRendererParameters ../../../rest/support/StatisticDefinition ../../../rest/support/UniqueValueDefinition ../../statistics/support/predominanceUtils ../../statistics/support/utils ../../statistics/support/WorkerClient ../utils ./InMemoryLayerAdapter ./support/utils ../../../statistics/utils ../../../views/2d/viewpointUtils".split(" "),
function(F,K,G,u,A,L,C,ba,M,N,O,x,P,Q,R,S,T,U,D,H,V,I,t,W,B,X,n,y,Y){function J(a,c=!1){return"string"!==typeof a?a:(c?new Date(`1970-01-01T${a}Z`):new Date(a)).getTime()}function Z(a,c,b){const e=[],g=c.length;c.forEach((k,h)=>{const [f,d]=k;k=null;k=0!==h||b?h!==g-1||b?t.mergeWhereClauses(`${a} >= ${f}`,`${a} ${h===g-1?" \x3c\x3d ":" \x3c "} ${d}`):`${a} >= ${f}`:`${a} < ${d}`;e.push("WHEN ("+k+") THEN "+(h+1))});return["CASE",e.join(" "),"ELSE 0 END"].join(" ")}C=class extends X{constructor(){super(...arguments);
this.adapterName="feature-layer-adapter"}_isStatsSupportedOnService(){const a=this.layer;if(!a.capabilities?.query?.supportsStatistics||"multipatch"===this.geometryType&&!O.isHostedAgolService(a.url)&&10.5>a.version)throw new u(`${this.adapterName}:not-supported`,"Layer does not support statistics query");return Promise.resolve()}_fetchFeaturesFromService(a,c){return this.layer.queryFeatures(a,{signal:c}).then(b=>b.features)}_fetchFeaturesJSONFromService(a,c){return this._fetchFeaturesFromService(a,
c).then(n.ensureFeaturesJSON)}_summaryStatsFromGenRend(a){const c=a.normalizationType,b=a.normalizationField;return this.classBreaks({field:a.field,numClasses:5,classificationMethod:"standard-deviation",standardDeviationInterval:.25,normalizationType:c,normalizationField:"field"===c?b:void 0,minValue:a.minValue,maxValue:a.maxValue,filter:a.filter,signal:a.signal}).then(e=>{let g,k;e.classBreakInfos?.some(f=>{f.hasAvg&&(g=f);return!!g});if(g){var h=g.maxValue-g.minValue;k=g.minValue+h/2;h*=4}return y.processSummaryStatisticsResult({min:e.minValue,
max:e.maxValue,avg:k,stddev:h},a.outStatisticTypes)})}async _summaryStatsFromServiceQuery(a,c){await this._isStatsSupportedOnService();"percent-of-total"===a.normalizationType&&(a.normalizationTotal=await this._getNormalizationTotal(a.field,a.normalizationType,a.filter));var b=B.isAnyDateField(c)||x.isTimeOnlyField(c);c=n.getSummaryStatsQuery(this,a,c);c=await this.layer.queryFeatures(c,{signal:a.signal});b=n.getSummaryStatisticsFromFeatureSet(c,b);return y.processSummaryStatisticsResult(b,a.outStatisticTypes)}_uvFromGenRenderer(a,
c){const b=a.field??void 0;var e=new V({attributeField:b});e=new D({classificationDefinition:e});return this.generateRenderer(e,a.signal).then(g=>{const k={},h=this.getField(b);g.uniqueValues.forEach(f=>{let d=f.value;if(null==d||""===d||"string"===typeof d&&(""===d.trim()||"\x3cnull\x3e"===d.toLowerCase()))d=null;null==k[d]?k[d]={count:f.count,data:x.isNumericField(h)&&d?Number(d):d}:k[d].count+=f.count});return{count:k}}).then(g=>y.createUVResult(g,[c],a.returnAllCodedValues))}async _uvFromServiceQuery(a,
c){return this._isStatsSupportedOnService().then(()=>this.layer.queryFeatures(n.getUVQuery(this,a),{signal:a.signal})).then(b=>n.getUniqueValuesFromFeatureSet(b,{layer:this,field:a.field,field2:a.field2,field3:a.field3,fieldDelimiter:B.fieldDelimiter,view:a.view,signal:a.signal})).then(b=>y.createUVResult(b,c,a.returnAllCodedValues,B.fieldDelimiter))}_getNormalizationTotal(a,c,b,e){return a&&"percent-of-total"===c?this.summaryStatistics({field:a,outStatisticTypes:{include:["sum"]},filter:b,signal:e}).then(g=>
g.sum):Promise.resolve(null)}_getQueryParamsForExpr(a,c){const b=a.signal;if(!a.valueExpression&&!a.sqlExpression){const {field:e,normalizationType:g,normalizationField:k}=a,h=e?this.getField(e):null,f=B.isAnyDateField(h)||x.isTimeOnlyField(h);c={field:e,normalizationType:g,normalizationField:k,normalizationTotal:c,layer:this};return{sqlExpression:f?n.getSQLExpressionForDateOrTimeField(this,h):n.getFieldExpr(c),sqlWhere:f?null:a.sqlWhere||t.getSQLFilterForNormalization({field:e,normalizationType:g,
normalizationField:k}),filter:a.filter,signal:b}}return{valueExpression:a.valueExpression,sqlExpression:a.sqlExpression,sqlWhere:a.sqlWhere,filter:a.filter,signal:b}}_getDataRange(a,c,b){return null!=c&&null!=b?Promise.resolve({min:c,max:b}):this.summaryStatistics({...a,outStatisticTypes:{include:["min","max"]}}).then(e=>({min:e.min,max:e.max}))}_histogramForExpr(a){return this._getNormalizationTotal(a.field,a.normalizationType,a.filter,a.signal).then(c=>{const b=this._getQueryParamsForExpr(a,c);
return this._getDataRange(b,a.minValue,a.maxValue).then(e=>{const g=e.min,k=e.max;if(null==g||null==k)return{bins:[],minValue:g,maxValue:k,normalizationTotal:c};const h=a.numBins||n.defaultNumBins;e=y.getEqualIntervalBins(g,k,h);e=Z(b.sqlExpression,e,null!=a.minValue&&null!=a.maxValue);const f=new H({statisticType:"count",outStatisticFieldName:"countOFExpr",onStatisticField:"1"}),d=this.layer.createQuery();d.where=t.mergeWhereClauses(d.where,b.sqlWhere);d.sqlFormat="standard";d.outStatistics=[f];
d.groupByFieldsForStatistics=[e];d.orderByFields=[e];n.updateQueryWithFeatureFilter(d,a.filter);return this._isStatsSupportedOnService().then(()=>this.layer.queryFeatures(d,{signal:b.signal})).then(l=>n.getHistogramFromFeatureSet(l,g,k,h,c))})})}async _getBinQueryParams(a,c,b,e){const {field:g,sqlExpression:k,normalizationField:h,classificationMethod:f,normalizationType:d}=a;var l=g?this.getField(g):null,m=x.isTimeOnlyField(l);l=x.isDateOnlyField(l)||m;const q=a.numBins||n.defaultNumBins;if(l){if(d||
f)throw new u(`${this.adapterName}:not-supported`,"NormalizationType and classificationMethod are not supported for date-only and time-only fields");a=(b-c)/q/1E3;return new S({field:g,expression:k,interval:{units:m?"seconds":"days",value:Math.ceil(m?a:a/86400)},start:c,end:b})}if("defined-interval"===f)return new U({field:g,expression:k,normalizationField:h,normalizationTotal:e,normalizationType:d,interval:a.definedInterval??Math.ceil((b-c)/q),start:d?null:c,end:d?null:b,normalizationMinValue:d?
c:null,normalizationMaxValue:d?b:null});if("manual"===f)throw new u(`${this.adapterName}:not-supported`,"Layer does not support manual classificationMethod");if("natural-breaks"===f||"quantile"===f||"standard-deviation"===f){b=n.getFieldExpr({field:g,normalizationField:h,normalizationTotal:e,normalizationType:d,layer:this});m=null!==a.minValue&&null!==a.maxValue?t.getRangeExpr(b,a.minValue,a.maxValue):void 0;a=await this._binParamsFromGenRend(a,m);if(!a.intervals)throw new u(`${this.adapterName}:invalid`,
"Invalid intervals returned from generate renderer");c=[c,...a.intervals.map(p=>p[1])];return new T({field:d?null:g,expression:d?b:k,boundaries:c})}return new Q({field:g,normalizationField:h,normalizationTotal:e,normalizationType:d,expression:k,bins:q,start:d?null:c,end:d?null:b,normalizationMinValue:d?c:null,normalizationMaxValue:d?b:null})}async _histogramFromQueryBins(a){const {field:c,normalizationType:b,minValue:e,maxValue:g,filter:k,view:h,signal:f}=a,d=await this._getNormalizationTotal(c,b,
k,f);var l=this._getQueryParamsForExpr(a,d);const {min:m,max:q}=await this._getDataRange(l,e,g);if(null==m||null==q)return{bins:[],minValue:m,maxValue:q,normalizationTotal:d};const p=new H({statisticType:"count",outStatisticFieldName:"countOFExpr",onStatisticField:"1"}),r=this.layer.createQuery();l=t.mergeWhereClauses(r.where,l.sqlWhere);a=new R({binParameters:await this._getBinQueryParams(a,m,q,d),outStatistics:[p],binOrder:a.sortOrder,where:l,lowerBoundaryAlias:"lowerBoundary",upperBoundaryAlias:"upperBoundary",
outTimeZone:h?.timeZone?N.resolveTimeZone(h?.timeZone):null});n.updateQueryWithFeatureFilter(a,k);a=await this.layer.queryBins(a,{signal:f});const v=x.isTimeOnlyField(c?this.getField(c):null);return{bins:a.features.map(z=>({minValue:J(z.attributes.lowerBoundary,v),maxValue:J(z.attributes.upperBoundary,v),count:z.attributes.countOFExpr})),minValue:m,maxValue:q,normalizationTotal:d}}_binParamsFromGenRend(a,c){const {field:b,normalizationType:e,normalizationField:g,signal:k}=a,h=t.getSQLFilterForNormalization({field:b,
normalizationType:e,normalizationField:g});a=new D({classificationDefinition:y.createClassBreaksDefinition({field:b,normalizationType:e,normalizationField:g,classificationMethod:a.classificationMethod,standardDeviationInterval:a.standardDeviationInterval,definedInterval:a.definedInterval,breakCount:a.numBins||n.defaultNumBins}),where:t.mergeWhereClauses(h,c)});return this.generateRenderer(a,k).then(f=>{const {normalizationTotal:d,classBreaks:l}=f;return n.generateBinParams({field:b,normalizationType:e,
normalizationField:g,normalizationTotal:d,classBreaks:l,where:h,layer:this})})}_classBreaksFromGenRend(a){const {field:c,normalizationType:b,normalizationField:e,normalizationTotal:g,signal:k}=a,h=t.getSQLFilterForNormalization({field:c,normalizationType:b,normalizationField:e});var f=n.getFieldExpr({field:c,normalizationType:b,normalizationField:e,normalizationTotal:g,layer:this});f=t.getRangeExpr(f,a.minValue,a.maxValue);var d=y.createClassBreaksDefinition({field:c,normalizationType:b,normalizationField:e,
classificationMethod:a.classificationMethod,standardDeviationInterval:a.standardDeviationInterval,breakCount:a.numClasses||5});d=new D({classificationDefinition:d});d.where=t.mergeWhereClauses(h,f);return this.generateRenderer(d,k).then(l=>y.resolveCBResult(l,a.classificationMethod))}async summaryStatistics(a){const {field:c,normalizationType:b,sqlExpression:e,view:g,features:k,useFeaturesInView:h}=a,f=c?this.getField(c):null,d=B.isAnyDateField(f)||x.isTimeOnlyField(f),l=a.valueExpression||e,m=l&&
!e,q=g&&"3d"===g.type;if(this._hasLocalSource||k||h||m)return m||k||h||q?this._summaryStatsFromMemory(a,f):this._summaryStatsFromClientQuery(a,f);if(!this.supportsSQLExpression&&(d||l||"natural-log"===b||"square-root"===b))throw new u(`${this.adapterName}:not-supported`,"Layer does not support standardized SQL expression for queries");return(b&&!this.supportsSQLExpression?this._summaryStatsFromGenRend(a):this._summaryStatsFromServiceQuery(a,f)).catch(()=>{A.throwIfAborted(a.signal);return this._summaryStatsFromMemory(a,
f)})}async uniqueValues(a){const {valueExpression:c,sqlExpression:b,features:e,useFeaturesInView:g,signal:k}=a,h=c&&(!b||!this.supportsSQLExpression),f=this._hasLocalSource||e||g||h,d=a.view,l=d&&"3d"===d.type,m=await n.getDomainsForFields(a,this);return f?h||e||g||l?this._uvFromMemory(a,m):this._uvFromClientQuery(a,m):this._uvFromServiceQuery(a,m).catch(q=>{A.throwIfAborted(k);return!a.field||a.field2||a.field3||a.filter?q:this._uvFromGenRenderer(a,m[0])}).catch(()=>{A.throwIfAborted(k);return l?
this._uvFromMemory(a,m):this._uvFromClientQuery(a,m)})}async histogram(a){const {field:c,normalizationType:b,normalizationField:e,classificationMethod:g,view:k,filter:h,signal:f}=a;var d=c?this.getField(c):null;d=B.isAnyDateField(d)||x.isTimeOnlyField(d);const l=a.valueExpression||a.sqlExpression,m=l&&!a.sqlExpression,q=this.supportsSQLExpression,p=!g||"equal-interval"===g,r=a.minValue,v=a.maxValue,z=null!=r&&null!=v,E=a.numBins||n.defaultNumBins;if(this._hasLocalSource||a.features||a.useFeaturesInView||
m)return this._histogramFromMemory(a);if(this.layer.capabilities?.operations?.supportsQueryBins&&a.useQueryBins)return this._histogramFromQueryBins(a);if((l||q)&&p){if(!q&&(l||"natural-log"===b||"square-root"===b))throw new u(`${this.adapterName}:not-supported`,"Layer does not support standardized SQL expression for queries");return this._histogramForExpr(a)}if(d&&p)throw new u(`${this.adapterName}:not-supported`,"Normalization and date field are not allowed when layer does not support standardized SQL expression for queries");
return b||!p?this._binParamsFromGenRend(a).then(w=>{if(!z)return n.getBins(this,w,c,E,k,h,f);if(r>w.max||v<w.min)throw new u(`${this.adapterName}:insufficient-data`,"Range defined by 'minValue' and 'maxValue' does not intersect available data range of the field");if(p)return n.getBins(this,{min:r,max:v,sqlExpr:w.sqlExpr,excludeZerosExpr:w.excludeZerosExpr},c,E,k,h,f);w=n.getFieldExpr({field:c,normalizationType:b,normalizationField:e,normalizationTotal:w.normTotal,layer:this});w=t.getRangeExpr(w,r,
v);return this._binParamsFromGenRend(a,w).then(aa=>n.getBins(this,aa,c,E,k,h,f))}):this._histogramForField(a)}async classBreaks(a){const c=!1!==a.analyzeData,b=this._hasLocalSource||a.features||a.useFeaturesInView||a.valueExpression||a.filter;return c&&b?this._classBreaksFromMemory(a):(c?this._classBreaksFromGenRend(a):this._classBreaksFromInterpolation(a)).catch(()=>{A.throwIfAborted(a.signal);return this._classBreaksFromMemory(a)})}async queryFeatureCount(a){if(this._hasLocalSource)throw new u(`${this.adapterName}:not-supported`,
"Layer does not support count query");const c=this.layer,b=c.createQuery();b.where=t.mergeWhereClauses(b.where,a.whereClause);n.updateQueryWithFeatureFilter(b,a.filter);return c.queryFeatureCount(b,{signal:a.signal})}async generateRenderer(a,c){const b=this.layer;if(this._hasLocalSource||10.1>b.version)throw new u(`${this.adapterName}:not-supported`,"Layer does not support generateRenderer operation (requires ArcGIS Server version 10.1+)");const e=b.createQuery();a.where=t.mergeWhereClauses(a.where,
e.where);return P.generateRenderer(b.parsedUrl?.path??"",{source:b.dynamicDataSource??void 0,gdbVersion:b.gdbVersion??void 0},a,{signal:c})}async predominantCategories(a){if(!this._hasLocalSource&&!this.supportsSQLExpression)throw new u(`${this.adapterName}:not-supported`,"Layer does not support advanced SQL expressions and standardized queries");const {fields:c,view:b,signal:e,filter:g}=a;a=I.getArcadeForPredominantCategory(c);const k=I.getSQLForPredominantCategoryName(c);a=b&&this._hasLocalSource?
await this._uvFromMemory({valueExpression:a,view:b,signal:e,filter:g}):await this._uvFromServiceQuery({sqlExpression:k.expression,valueExpression:a,signal:e,filter:g});return n.getPredominantCategoriesFromUVInfos(a.uniqueValueInfos,c)}async getSampleFeatures(a,c){const {view:b,requiredFields:e,returnGeometry:g,filter:k,signal:h}=a,f=a.sampleSize;if(null==f||0===f)return[];const d=this.layer.createQuery(),l="json"===c;d.outSpatialReference=b?.spatialReference;d.returnGeometry=!!g;d.outFields=e;n.updateQueryWithFeatureFilter(d,
k);let m=[],q=!1;if(b)try{const p=await b.whenLayerView(this.layer);if(q=!n.getMissingFields(this,e,p).length){if(1<=f&&!a.filter&&"getSampleFeatures"in p){await this._waitForLayerViewUpdate(p);const r=await p.getSampleFeatures({minFeatureCount:f,sampleSize:f});if(null!=r)return l?r:r.map(v=>K.fromJSON(v))}m=await this._fetchFeaturesFromMemory(p,d,h,c);if(m.length>=f&&0<f)return G.pickRandom(m,f,1)}}catch(p){A.throwIfAborted(h)}try{if(this._hasLocalSource)return q?m:l?await this._fetchFeaturesJSONFromService(d,
h):await this._fetchFeaturesFromService(d,h);const p=await this.queryFeatureCount({view:b,filter:k,signal:h}),r=this.layer.capabilities.query.maxRecordCount;c=-1===f?p:f;c=r&&c>r?r:c;if(p<=m.length||m.length>=r)return m;d.maxAllowableOffset=a.resolution||4E5*(b?b.extent.width/b.width/b.scale:Y.getScaleToResolutionFactor(this.layer.spatialReference));if(p<=c)return l?await this._fetchFeaturesJSONFromService(d,h):await this._fetchFeaturesFromService(d,h);if(2E4>=p){const v=this.layer.createQuery();
n.updateQueryWithFeatureFilter(v,k);const z=await this.layer.queryObjectIds();d.objectIds=G.pickRandom(z,c,1);return l?await this._fetchFeaturesJSONFromService(d,h):await this._fetchFeaturesFromService(d,h)}this.layer.capabilities?.query?.supportsPagination&&(d.num=Math.min(c,2E4));return l?await this._fetchFeaturesJSONFromService(d,h):await this._fetchFeaturesFromService(d,h)}catch(p){return A.throwIfAborted(h),m}}load(a){const c=this.layer.load(a).then(async b=>{this.geometryType=b.geometryType;
this.objectIdField=b.objectIdField;this.supportsSQLExpression=b.capabilities?.query?.supportsSqlExpression;this.hasQueryEngine=this._hasLocalSource=!b.url&&!!b.source;this.minScale=b.minScale;this.maxScale=b.maxScale;this.fullExtent=b.fullExtent;this.workerClient=W.WorkerClient.getInstance();await this.workerClient.open(a.signal)});this.addResolvingPromise(c);return Promise.resolve(this)}};F.__decorate([L.property({constructOnly:!0})],C.prototype,"layer",void 0);return C=F.__decorate([M.subclass("esri.smartMapping.support.adapters.FeatureLayerAdapter")],
C)});