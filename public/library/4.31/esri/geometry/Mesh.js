// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.31/esri/copyright.txt for details.
//>>built
define("require ../chunks/tslib.es6 ../core/deprecate ../core/Error ../core/Loadable ../core/Logger ../core/Promise ../core/promiseUtils ../core/reactiveUtils ../core/accessorSupport/decorators/property ../core/has ../core/RandomLCG ../core/accessorSupport/decorators/subclass ../core/libs/gl-matrix-2/factories/vec3f64 ./Geometry ./Point ./Polygon ./support/aaBoundingBox ./support/axisAngleDegrees ./support/MeshComponent ./support/meshErrors ./support/MeshGeoreferencedVertexSpace ./support/MeshLocalVertexSpace ./support/MeshTransform ./support/MeshVertexAttributes ./support/meshVertexSpaceUtils ./support/triangulationUtils ./support/meshUtils/centerAt ./support/meshUtils/extent ./support/meshUtils/loadExternal ./support/meshUtils/Metadata ./support/meshUtils/primitives ./support/meshUtils/rotate ./support/meshUtils/scale".split(" "),
function(A,g,G,B,e,H,I,C,J,h,D,X,K,L,M,q,N,u,E,v,p,w,O,x,y,t,P,Q,R,S,z,m,T,U){function n(){return H.getLogger("esri.geometry.Mesh")}var k;D={base:null,key:"type",defaultKeyValue:"georeferenced",typeMap:{georeferenced:w,local:O}};e=k=class extends e.LoadableMixin(I.EsriPromiseMixin(M)){constructor(a){super(a);this.components=null;this.vertexSpace=new w;this.transform=null;this.metadata=new z.Metadata;this.hasZ=!0;this.hasM=!1;this.vertexAttributes=new y.MeshVertexAttributes;this.type="mesh"}initialize(){if(0===
this.metadata.externalSources.length||this.vertexAttributes.position.length)this.loadStatus="loaded";this.when(()=>{this.addHandles(J.watch(()=>({vertexAttributes:this.vertexAttributes,components:this.components?.map(a=>a.clone())}),()=>this._clearSources(),{once:!0,sync:!0}))})}get hasExtent(){return this.loaded?0<this.vertexAttributes.position.length&&(!this.components||0<this.components.length):null!=this.metadata.displaySource?.extent}get _transformedExtent(){const {spatialReference:a,vertexSpace:b}=
this,c=this;return R.computeMeshExtent({get transform(){return c.transform},vertexSpace:b,spatialReference:a,untransformedBounds:this._untransformedBounds})}get _untransformedBounds(){const {vertexAttributes:{position:a},components:b}=this;return 0===a.length||0===b?.length?u.create(u.zero):u.fromBuffer(a)}get origin(){const a=t.vertexSpaceOriginToPoint(this.vertexSpace,this.spatialReference);if(null!=a)return a;const {center:b,zmin:c}=this._transformedExtent;return new q({x:b.x,y:b.y,z:c,spatialReference:this.spatialReference})}get extent(){return this.loaded||
null==this.metadata?.displaySource?.extent?this._transformedExtent:this.metadata.displaySource.extent.clone()}addComponent(a){this._checkIfLoaded("addComponent()")&&(this.components||(this.components=[]),this.components.push(v.from(a)),this.notifyChange("components"))}removeComponent(a){if(this._checkIfLoaded("removeComponent()")){if(this.components&&(a=this.components.indexOf(a),-1!==a)){this.components.splice(a,1);this.notifyChange("components");return}n().error("removeComponent()",p.componentNotFoundMessage)}}rotate(a,
b,c,d){E.composeAxes(a,b,c,F);T.rotate(this,F,d);return this}offset(a,b,c){if(!this._checkIfLoaded("offset()"))return this;const {vertexSpace:d,vertexAttributes:r}=this,f=r?.position;if(!f)return this;if(t.isRelativeVertexSpace(d)){const [l,V,W]=d.origin;d.origin=L.fromValues(l+a,V+b,W+c)}else{for(let l=0;l<f.length;l+=3)f[l]+=a,f[l+1]+=b,f[l+2]+=c;this.vertexAttributesChanged()}return this}scale(a,b){if(!this._checkIfLoaded("scale()"))return this;U.scale(this,a,b);return this}centerAt(a,b){if(!this._checkIfLoaded("centerAt()"))return this;
Q.centerAt(this,a,b);return this}load(a){const {metadata:{displaySource:b}}=this;b&&this.addResolvingPromise(S.loadExternal(this,b,a));return Promise.resolve(this)}addExternalSources(a){this.metadata.externalSources.addMany(a)}updateDisplaySource(a){this.metadata.displaySource=a}clone(){return this.cloneAndModifyVertexAttributes(this.vertexAttributes.clone(),this.vertexSpace.clone(),{preserveMetadata:!0})}cloneAndModifyVertexAttributes(a,b,c){let d=null;if(this.components){const r=new Map,f=new Map;
d=this.components.map(l=>l.cloneWithDeduplication(r,f))}a={components:d,spatialReference:this.spatialReference,vertexAttributes:a,vertexSpace:b,transform:this.transform?.clone()??null,metadata:c?.preserveMetadata?this.metadata.clone():new z.Metadata};return new k(a)}cloneShallow(){return new k({components:this.components,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes,vertexSpace:this.vertexSpace.clone(),transform:this.transform,metadata:this.metadata})}vertexAttributesChanged(){this.notifyChange("vertexAttributes")}async toBinaryGLTF(a){const [{toBinaryGLTF:b}]=
await Promise.all([new Promise((c,d)=>A(["./support/meshUtils/exporters/gltf/gltfexport"],c,d)),this.load(a)]);C.throwIfAborted(a);return await b(this,a)}get memoryUsage(){let a;a=0+this.vertexAttributes.memoryUsage;if(null!=this.components)for(const b of this.components)a+=b.memoryUsage;return a}_clearSources(){this.metadata.clearSources()}_checkIfLoaded(a){return this.loaded?!0:(n().error(a,p.meshNotLoadedMessage),!1)}static createBox(a,b){if(!(a instanceof q))return n().error(".createBox()",p.invalidLocationMessage),
null;a=new k(m.convertUnitGeometry(m.createUnitSizeBox(),a,b));return b?.imageFace&&"all"!==b.imageFace?m.extractSingleFaceOfBox(a,b.imageFace):a}static createSphere(a,b){return a instanceof q?new k(m.convertUnitGeometry(m.createUnitSizeSphere(b?.densificationFactor||0),a,b)):(n().error(".createSphere()",p.invalidLocationMessage),null)}static createCylinder(a,b){return a instanceof q?new k(m.convertUnitGeometry(m.createUnitSizeCylinder(b?.densificationFactor||0),a,b)):(n().error(".createCylinder()",
p.invalidLocationMessage),null)}static createPlane(a,b){if(!(a instanceof q))return n().error(".createPlane()",p.invalidLocationMessage),null;const c=b?.facing??"up",d=m.convertPlaneSizeParameter(c,b?.size);return new k(m.convertUnitGeometry(m.createUnitSizePlane(c),a,{...b,size:d}))}static createFromPolygon(a,b){if(!(a instanceof N))return n().error(".createFromPolygon()",p.invalidPolygonMessage),null;const c=P.triangulate(a);return new k({vertexAttributes:new y.MeshVertexAttributes({position:c.position}),
components:[new v({faces:c.faces,shading:"flat",material:b?.material??null})],spatialReference:a.spatialReference,vertexSpace:new w})}static async createFromGLTF(a,b,c){if(!(a instanceof q))throw a=new p.InvalidLocationError,n().error(".createfromGLTF()",a.message),a;const {loadGLTFMesh:d}=await C.whenOrAbort(new Promise((r,f)=>A(["./support/meshUtils/loadGLTFMesh"],r,f)),c);return new k(await d(a,b,c))}static async createFromFiles(a,b,c){G.deprecatedFunction(n(),"`Mesh.createFromFiles` is deprecated in favor of 'SceneLayer.convertMesh'",
{replacement:"SceneLayer.convertMesh",version:"4.29"});if(!(a instanceof q))throw a=b=new p.InvalidLocationError,n().error(".createFromFiles()",a.message),b;if(!c?.layer)throw new B("invalid:no-layer","SceneLayer required for file to mesh conversion.");return c.layer.convertMesh(b,{location:a,...c})}static createWithExternalSource(a,b,c){const d=c?.extent??null,{spatialReference:r}=a,f=c?.transform?.clone()??new x;a=t.selectVertexSpace(a,c);b={source:b,extent:d,unitConversionDisabled:c?.unitConversionDisabled};
c=new z.Metadata;c.externalSources.push(b);return new k({metadata:c,transform:f,vertexSpace:a,spatialReference:r})}static createIncomplete(a,b){var {spatialReference:c}=a;const d=b?.transform?.clone()??new x;a=t.selectVertexSpace(a,b);c=new k({transform:d,vertexSpace:a,spatialReference:c});c.addResolvingPromise(Promise.reject(new B("mesh-incomplete","Mesh resources are not complete")));return c}};g.__decorate([h.property({type:[v],json:{write:!0}})],e.prototype,"components",void 0);g.__decorate([h.property({nonNullable:!0,
types:D,constructOnly:!0,json:{write:!0}})],e.prototype,"vertexSpace",void 0);g.__decorate([h.property({type:x,json:{write:!0}})],e.prototype,"transform",void 0);g.__decorate([h.property({constructOnly:!0})],e.prototype,"metadata",void 0);g.__decorate([h.property()],e.prototype,"hasExtent",null);g.__decorate([h.property()],e.prototype,"_transformedExtent",null);g.__decorate([h.property()],e.prototype,"_untransformedBounds",null);g.__decorate([h.property()],e.prototype,"origin",null);g.__decorate([h.property({readOnly:!0,
json:{read:!1}})],e.prototype,"extent",null);g.__decorate([h.property({readOnly:!0,json:{read:!1,write:!0,default:!0}})],e.prototype,"hasZ",void 0);g.__decorate([h.property({readOnly:!0,json:{read:!1,write:!0,default:!1}})],e.prototype,"hasM",void 0);g.__decorate([h.property({type:y.MeshVertexAttributes,nonNullable:!0,json:{write:!0}})],e.prototype,"vertexAttributes",void 0);e=k=g.__decorate([K.subclass("esri.geometry.Mesh")],e);const F=E.create();return e});