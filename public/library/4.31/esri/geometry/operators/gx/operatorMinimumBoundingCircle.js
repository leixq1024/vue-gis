// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.31/esri/copyright.txt for details.
//>>built
define(["exports","../../../chunks/SimpleGeometryCursor","../../../chunks/Geometry","../../../chunks/QuadraticBezier","../../../chunks/Transformation2D"],function(k,l,c,h,g){class n{getOperatorType(){return 10113}supportsCurves(){return!1}accelerateGeometry(a,b,d){return!1}canAccelerateGeometry(a){return!1}executeMany(a,b,d){return new p(a,b,d)}execute(a,b){a=new l.SimpleGeometryCursor([a]);(b=this.executeMany(a,!1,b).next())||c.throwInternalErrorException("null output");return b}minimumBoundingCircle(a,
b,d,e){return h.minimumBoundingCirclePoint2D(a,b,d)}}class p extends l.GeometryCursor{constructor(a,b,d){super();this.m_geometryCursor=a;this.m_bMerge=b;this.m_progressTracker=d}tock(){c.geometryReleaseAssert(0);return!1}getRank(){c.geometryReleaseAssert(0);return 0}next(){if(this.m_bMerge)return this.mergedMinimumBoundingCircle();const a=this.m_geometryCursor.next();return a?this.minimumBoundingCircle(a):null}getGeometryID(){return this.m_geometryCursor.getGeometryID()}minimumBoundingCircle(a){c.throwIfCurves(a);
c.throwIfMesh(a);this.m_progressTracker?.checkProgress();if(a.isEmpty())return a.clone();var b=a.getGeometryType();if(b===c.GeometryType.enumPoint)return this.makeCircle([a.getXY()],1);if(b===c.GeometryType.enumLine)return a=[a.getStartXY(),a.getEndXY()],this.makeCircle(a,2);if(b===c.GeometryType.enumEnvelope)return b=g.makeObjectArray(g.Point2D,2),a.queryCorner(0,b[0]),a.queryCorner(2,b[1]),this.makeCircle(b,2);if(c.isMultiVertex(b)){b=[0,0,0];const d=h.minimumBoundingCircle(a,b),e=Array(d);for(let f=
0;f<d;++f)e[f]=a.getXY(b[f]);return this.makeCircle(e,d)}c.throwInvalidArgumentException("Geometry type not supported.")}makeCircle(a,b){const d=new h.Polygon,e=new h.EllipticArc;if(1===b)e.constructCircleRadius(0,a[0],!1);else if(2===b){b=g.Point2D.lerp(a[0],a[1],.5);var f=g.Point2D.distance(a[0],b);a=g.Point2D.distance(a[1],b);e.constructCircleRadius(Math.max(f,a),b,!1)}else if(3===b){b=g.Point2D.calculateCircleCenterFromThreePoints(a[0],a[1],a[2]);f=g.Point2D.distance(a[0],b);const q=g.Point2D.distance(a[1],
b);a=g.Point2D.distance(a[2],b);e.constructCircleRadius(Math.max(f,q,a),b,!1)}d.addPathFromClosedSegment(e,!1);return d}mergedMinimumBoundingCircle(){let a=null;var b=this.m_geometryCursor.next();if(b)a=new h.MultiPoint;else return null;const d=a.getImpl();do switch(c.throwIfCurves(b),c.throwIfMesh(b),this.m_progressTracker?.checkProgress(),b.getGeometryType()){case c.GeometryType.enumPoint:d.addPoint2D(b.getXY());break;case c.GeometryType.enumLine:d.addPoint2D(b.getStartXY());d.addPoint2D(b.getEndXY());
break;case c.GeometryType.enumEnvelope:for(let e=0;4>e;++e){const f=new g.Point2D;b.queryCorner(e,f);d.addPoint2D(f)}break;case c.GeometryType.enumMultiPoint:case c.GeometryType.enumPolyline:case c.GeometryType.enumPolygon:b=b.getImpl();for(let e=0,f=b.getPointCount();e<f;e++)d.addPoint2D(b.getXY(e));break;default:c.throwInvalidArgumentException("Geometry type not supported.")}while(b=this.m_geometryCursor.next());return this.minimumBoundingCircle(a)}}const m=new n;k.execute=function(a){return m.execute(a,
null)};k.executeMany=function(a,b){a=m.executeMany(new l.SimpleGeometryCursor(a),b,null);return Array.from(a)};k.supportsCurves=function(){return m.supportsCurves()};Object.defineProperty(k,Symbol.toStringTag,{value:"Module"})});