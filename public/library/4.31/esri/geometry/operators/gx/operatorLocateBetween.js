// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.31/esri/copyright.txt for details.
//>>built
define(["exports","../../../chunks/SimpleGeometryCursor","../../../chunks/Geometry","../../../chunks/Transformation2D","../../../chunks/QuadraticBezier"],function(r,u,h,v,g){class x{constructor(a,b,c,e){this.m_interval=c;this.m_progressTracker=e;this.m_attribute=a;this.m_ord=b;(g.VertexDescription.getComponentCount(this.m_attribute)<=b||0>b)&&h.throwInvalidArgumentException("LocateBetween: ordinate");2===g.VertexDescription.getInterpolation(this.m_attribute)&&h.throwInvalidArgumentException("LocateBetween: angular interpolation")}processGeometry(a){const b=
a.getGeometryType();if(b===h.GeometryType.enumGeometryCollection)return this.processGeometryCollection(a);h.isArea(b)&&h.throwInvalidArgumentException("LocateBetween does not support Polygons and Envelopes.");if(a.isEmpty()||!a.hasAttribute(this.m_attribute))return new g.Point({vd:a.getDescription()});if(h.isSegment(b))return this.processSegment(a);switch(b){case h.GeometryType.enumPoint:return this.processPoint(a);case h.GeometryType.enumMultiPoint:return this.processMultiPoint(a);case h.GeometryType.enumPolyline:return this.processPolyline(a);
default:h.throwInternalErrorException("LocateBetween")}}processPoint(a){const b=a.getAttributeAsDbl(this.m_attribute,this.m_ord);return this.m_interval.containsCoordinate(b)?new g.MultiPoint({point:a}):new g.Point({vd:a.getDescription()})}processMultiPoint(a){let b=null,c=-1;const e=a.getAttributeStreamRef(this.m_attribute),k=g.VertexDescription.getComponentCount(this.m_attribute);for(let f=0,d=0,l=a.getPointCount();f<l;++f,d+=k){const m=e.readAsDbl(d);this.m_interval.containsCoordinate(m)?-1===c&&
(c=f):0<=c&&(b||=new g.MultiPoint({vd:a.getDescription()}),b.addPoints(a,c,f),c=-1)}0<=c&&(b||=new g.MultiPoint({vd:a.getDescription()}),b.addPoints(a,c,-1));return b?b:new g.Point({vd:a.getDescription()})}processPolyline(a){var b=a.queryInterval(this.m_attribute,this.m_ord);if(this.m_interval.contains(b))return a;if(!this.m_interval.isIntersecting(b))return new g.Point({vd:a.getDescription()});let c=b=null;const e=a.querySegmentIterator(),k=new g.SegmentBuffer,f=new g.Point,d=new g.Point,l=new g.Point;
let m=!0,n=!1;for(;e.nextPath();)for(m=!0,n=!1;e.hasNextSegment();){const p=e.nextSegment(),q=[null],t=this.processSegmentHelper(p,k,q,f);if(t===h.GeometryType.enumUnknown)m=!0,n=!1;else if(t===h.GeometryType.enumPoint){if(!m&&(c.getPointByVal(c.getPointCount()-1,d),d.equals(f)))continue;m=!0;if(n&&(p.queryStart(d),f.equals(d)))continue;p.queryEnd(d);n=f.equals(d);b?b.add(f):b=new g.MultiPoint({point:f})}else t===h.GeometryType.enumLine&&(n=!1,c||=new g.Polyline,m&&null!==b&&!b.isEmpty()&&(b.getPointByVal(b.getPointCount()-
1,d),q[0].queryStart(f),d.equals(f)&&b.removePoint(b.getPointCount()-1)),c.addSegment(q[0],m),p.queryEnd(d),q[0].queryEnd(l),m=d.equals(l)?!1:!0)}null!==b&&b.isEmpty()&&(b=null);return null!==b&&null!==c?(a=new g.GeometryCollection,a.addGeometry(c),a.addGeometry(b),a):null!==b?b:null!==c?c:new g.Point({vd:a.getDescription()})}processSegment(a){h.geometryReleaseAssert(0);return{}}processGeometryCollection(a){if(a.isEmpty()||!a.hasAttribute(this.m_attribute))return new g.Point({vd:a.getDescription()});
const b=g.generateGeometryCursor(a),c=new g.GeometryCollection;for(var e=b.next();null!==e;e=b.next())e=this.processGeometry(e),e.isEmpty()||c.addGeometry(e);return c.isEmpty()?new g.Point({vd:a.getDescription()}):c}processSegmentHelper(a,b,c,e){var k=a.getAttributeAsDbl(0,this.m_attribute,this.m_ord),f=a.getAttributeAsDbl(1,this.m_attribute,this.m_ord),d=Number.isNaN(k)?f:k;f=Number.isNaN(f)?k:f;var l=new v.Envelope1D;l.setCoords(d,f);k=l.clone();k.intersect(this.m_interval);if(k.isEmpty())return h.GeometryType.enumUnknown;
if(l.equals(k))return c[0]=a,h.GeometryType.enumLine;l=f-d;f=a.calculateLength2D();if(0===k.width())return b=(k.vmin-d)/l,b=1===b?1:a.lengthToT(b*f),a.queryCoord(b,e),h.GeometryType.enumPoint;e=(k.vmin-d)/l;d=(k.vmax-d)/l;e>d&&(d=v.swap(e,e=d));e=1===e?1:a.lengthToT(e*f);d=1===d?1:a.lengthToT(d*f);a.queryCut(e,d,b);c[0]=b.get();return h.GeometryType.enumLine}}class y{getOperatorType(){return 10801}accelerateGeometry(a,b,c){return!1}canAccelerateGeometry(a){return!1}supportsCurves(){return!0}executeMany(a,
b,c){return new z(a,b,c)}}class z extends u.GeometryCursor{constructor(a,b,c){super();this.m_collectionCursor=null;this.m_interval=b;this.m_progressTracker=c;this.m_inputGeoms=a;this.m_index=-1}tock(){h.geometryReleaseAssert(0);return!1}getRank(){h.geometryReleaseAssert(0);return 0}next(){if(this.m_collectionCursor){var a=this.m_collectionCursor.next();if(a)return a;this.m_collectionCursor=null}a=this.m_inputGeoms.next();if(null===a)return null;h.throwIfMesh(a);this.m_index=this.m_inputGeoms.getGeometryID();
a=(new x(2,0,this.m_interval,this.m_progressTracker)).processGeometry(a);return a.getGeometryType()===h.GeometryType.enumGeometryCollection?(this.m_collectionCursor=g.generateGeometryCursor(a),this.m_collectionCursor.next()):a}getGeometryID(){return this.m_index}}const w=new y;r.executeMany=function(a,b){a=w.executeMany(new u.SimpleGeometryCursor(a),b,null);return Array.from(a)};r.supportsCurves=function(){return w.supportsCurves()};Object.defineProperty(r,Symbol.toStringTag,{value:"Module"})});