// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.31/esri/copyright.txt for details.
//>>built
define(["exports","../../../chunks/SimpleGeometryCursor","../../../chunks/Geometry","../../../chunks/Transformation2D","../../../chunks/QuadraticBezier"],function(x,E,n,k,u){function F(a,c,b,d,e,g){var f=d-c;if(f<=g)return u.nthElement(a,c,b,d,e),b;f=I(a,c,d,e,Math.min(Math.max(f>>1,3),100));g=a[f];a[c]=k.swap(a[f],a[f]=a[c]);f=c+1;let h=!1;for(let l=c+1;l!==d;++l)e(a[l],g)&&(a[f]=k.swap(a[l],a[l]=a[f]),++f,h=!0);if(!h)for(d=c+1;d<b;++d)e(g,a[d])||(d!==f&&(a[f]=k.swap(a[d],a[d]=a[f])),++f);--f;a[f]=
k.swap(a[c],a[c]=a[f]);return f}function J(a,c,b){let d=BigInt(Math.trunc(c/2));c=BigInt(c);for(let e=0;e<b;++e)a.push(Number(d%c)),d=6364136223846793005n*d+1442695040888963407n&9223372036854775807n,d=BigInt.asUintN(64,d);k.numericSort(a);b=k.unique(a,(e,g)=>e===g);a.length=b}function I(a,c,b,d,e){const g=[];J(g,b-c,e);b=[];for(let f=0,h=g.length;f<h;f++)e=g[f],b.push(k.makePair(a[c+e],e));a=Math.trunc(b.length/2);b.sort((f,h)=>d(f.first,h.first)?-1:1);return c+b[a].second}function G(){return{p:new k.Point2D,
userData:Number.NaN,edge:null}}function m(a,c){return{first:a,second:c}}function w(a,c){a.first=c.first;a.second=c.second}function K(){return this.i1-this.i0}function y(){return{i0:Number.NaN,i1:Number.NaN,nextFreeEdgeIndex:[-1],box:[m(null,null),m(null,null)],size:K}}function z(){return{p:[new k.Point2D,new k.Point2D],points:[null,null]}}function A(a,c,b){return a[b]!==c[b]?a[b]<c[b]:a[1-b]<c[1-b]}function L(a,c){if(a.first!==c.first)return a.first-c.first;let b=a.second.first,d=c.second.first;for(let e=
0;3>e;++e)if(b[e]!==d[e])return b[e]-d[e];b=a.second.second;d=c.second.second;for(a=0;3>a;++a)if(b[a]!==d[a])return b[a]-d[a];return 0}class M{constructor(){this.info=0;this.mask=!1;this.p=null;this.a=[null,null];this.twin=null}nextFreeEdge(){return this.twin}setIndex(a){this.info=a;this.mask=!1}getIndex(){return this.info}setMask(){this.mask=!0}getMask(){return this.mask}}class B{constructor(){this.m_nextFreePairEdge=m(null,null);this.m_points=[];this.m_pointZero=null;this.m_edges=[];this.m_voronoiToEdge=
[];this.m_nextFreeEdge=0}clear(){this.m_nextFreePairEdge=m(null,null);this.m_points.length=0;this.m_pointZero=null;this.m_edges.length=0;this.m_nextFreeEdge=this.m_voronoiToEdge.length=0}reservePoints(a){n.geometryReleaseAssert(1<a)}prepare(a){const c=G();c.p.x=Number.POSITIVE_INFINITY;c.p.y=Number.POSITIVE_INFINITY;c.userData=a;this.m_points.push(c)}addVertex(a,c){const b=G();b.p.assign(a);b.userData=c;b.edge=null;this.m_points.push(b)}removeDuplicates(){const a=this.m_points.shift();this.m_points.sort((d,
e)=>d.p.compareX(e.p));const c=k.unique(this.m_points,(d,e)=>d.p.equals(e.p)),b=c!==this.m_points.length;this.m_points.length=c;this.m_points.unshift(a);return b}removeDuplicatesEx(a){n.geometryReleaseAssert(0);return!1}boundVoronoiCells(a,c){var b=this.m_points.length;if(2>b)return!1;var d=[this.m_points[1].p.clone(),this.m_points[1].p.clone()];for(var e=2;e<b;e++){var g=this.m_points[e].p;g.x<d[0].x&&(d[0].x=g.x);d[1].x<g.x&&(d[1].x=g.x);g.y<d[0].y&&(d[0].y=g.y);d[1].y<g.y&&(d[1].y=g.y)}e=new k.Point2D;
e.x=.5*(d[0].x+d[1].x);e.y=.5*(d[0].y+d[1].y);d=0;for(g=1;g<b;g++){var f=this.m_points[g].p;f=k.Point2D.sqrDistanceCoords(f.x,f.y,e.x,e.y);d<f&&(d=f)}b=Math.sqrt(d);a=Math.max(b+2*a,1.5*b);b=1;d=0;for(g=0;12>g;g++)f=new k.Point2D,f.x=e.x+a*b,f.y=e.y+a*d,this.addVertex(f,c),f=.5*b+.8660254037844386*d,b=.8660254037844386*b-.5*d,d=f;return!0}construct(){const a=y();if(!this.constructTask(a))return!1;this.solveTask(a);return!0}constructTask(a){this.m_pointZero=this.createZeroHandle();n.geometryReleaseAssert(void 0!==
this.m_pointZero);if(3>this.m_points.length)return!1;const c=6*(this.m_points.length-2);this.m_edges=k.makeObjectArray(M,c);for(let b=0;b<c;b++)this.m_edges[b].setIndex(b);a.i0=1;a.i1=this.m_points.length;a.nextFreeEdgeIndex[0]=0;return!0}splitTask(a,c,b,d){a.k=this.findMaxSide(d.i0,d.i1);let e=d.i0+d.i1>>1;e=0===a.k?F(this.m_points,d.i0,e,d.i1,(g,f)=>g.p[0]!==f.p[0]?g.p[0]<f.p[0]:g.p[1]<f.p[1],1250):F(this.m_points,d.i0,e,d.i1,(g,f)=>g.p[1]!==f.p[1]?g.p[1]<f.p[1]:g.p[0]<f.p[0],1250);c.i0=d.i0;c.i1=
e;c.nextFreeEdgeIndex[0]=d.nextFreeEdgeIndex[0];d.nextFreeEdgeIndex[0]+=6*(c.i1-c.i0-1)+2;b.i0=e;b.i1=d.i1;b.nextFreeEdgeIndex[0]=d.nextFreeEdgeIndex[0];d.nextFreeEdgeIndex[0]+=6*(b.i1-b.i0-1)+2;a.pTask=d;a.pTask0=c;a.pTask1=b}solveMergeTask(a){const c=this.newPairEdgeEx(a.pTask.nextFreeEdgeIndex,!1);a.pTask.box[a.k]=m(a.pTask0.box[a.k].first,a.pTask1.box[a.k].second);a.pTask.box[1-a.k]=m(A(this.getPointXYFromEdge(a.pTask0.box[1-a.k].first),this.getPointXYFromEdge(a.pTask1.box[1-a.k].first),1-a.k)?
a.pTask0.box[1-a.k].first:a.pTask1.box[1-a.k].first,A(this.getPointXYFromEdge(a.pTask0.box[1-a.k].second),this.getPointXYFromEdge(a.pTask1.box[1-a.k].second),1-a.k)?a.pTask1.box[1-a.k].second:a.pTask0.box[1-a.k].second);if(a.pTask.i0+2===a.pTask.i1){var b=a.pTask0.box[a.k].second,d=b.twin;a=a.pTask1.box[a.k].first;var e=a.twin;this.joinEdges2(d,e);this.joinEdges2(e,d);this.join(b,a,0,1,c)}else b=[Array(2),Array(2)],b[0][0]=b[1][0]=m(a.pTask0.box[a.k].second,a.pTask0.box[a.k].second.twin),b[0][1]=
b[1][1]=m(a.pTask1.box[a.k].first,a.pTask1.box[a.k].first.twin),d=[!1,!1],a.pTask0.i0+1===a.pTask0.i1?(this.findEdgeSide(b[0],d,1,0),this.findEdgeSide(b[1],d,1,1)):(this.findEdge(b[0],d,0),this.findEdge(b[1],d,1)),d[0]||d[1]?(d[0]&&(e=this.newPairEdgeEx(a.pTask0.nextFreeEdgeIndex,!1),this.insertEdge(b[0][0].first,e.first,0),this.insertEdge(b[0][0].second,e.second,1)),d[1]&&(a=this.newPairEdgeEx(a.pTask1.nextFreeEdgeIndex,!1),this.insertEdge(b[0][1].first,a.first,1),this.insertEdge(b[0][1].second,
a.second,0))):(this.getNextDEdge(b[0][0].first,0)!==b[0][0].first&&(b[1][0]=this.newPairEdgeEx(a.pTask0.nextFreeEdgeIndex,!1),this.insertEdge(b[0][0].first,b[1][0].first,0),this.insertEdge(b[0][0].second,b[1][0].second,1)),this.getNextDEdge(b[0][1].first,0)!==b[0][1].first&&(b[1][1]=this.newPairEdgeEx(a.pTask1.nextFreeEdgeIndex,!1),this.insertEdge(b[0][1].first,b[1][1].first,1),this.insertEdge(b[0][1].second,b[1][1].second,0))),this.merge(b[1][0],b[0][0],b[0][1],b[1][1],c)}solveTask(a){switch(a.i1-
a.i0){case 1:this.insertPoint(a.i0,a.nextFreeEdgeIndex);var c=this.m_points[a.i0].edge;a.box[0]=a.box[1]=k.makePair(c,c);break;case 2:c=a.i0;var b=c+1;this.insertPoint(c,a.nextFreeEdgeIndex);this.insertPoint(b,a.nextFreeEdgeIndex);c=this.m_points[c];b=this.m_points[b];var d=c.edge,e=b.edge,g=d.twin,f=e.twin;this.joinEdges2(g,f);this.joinEdges2(f,g);g=this.newPairEdgeEx(a.nextFreeEdgeIndex,!1);this.join(d,e,0,1,g);for(g=0;2>g;g++)a.box[g]=A(this.getPointXY(c),this.getPointXY(b),g)?m(d,e):m(e,d);break;
case 3:c=[a.i0,a.i0+1,a.i0+2];this.insertPoint(c[0],a.nextFreeEdgeIndex);this.insertPoint(c[1],a.nextFreeEdgeIndex);this.insertPoint(c[2],a.nextFreeEdgeIndex);b=[this.m_points[c[0]],this.m_points[c[1]],this.m_points[c[2]]];d=this.caseFromCompare(b[0].p,b[1].p,b[2].p);c=[b[0].edge,b[1].edge,b[2].edge];d=B.c_aTableDelaunayTriangulationSolution[d];g=19*((d&7)+1&255)&255;f=19*((d>>5)+1&255)&255;e=(d<<3&255)>>6;d=g&3;g>>=6;const h=f&3;f>>=6;a.box[0]=m(c[d],c[g]);a.box[1]=m(c[h],c[f]);f=[c[0].twin,c[1].twin,
c[2].twin];a=[this.newPairEdgeEx(a.nextFreeEdgeIndex,!1),this.newPairEdgeEx(a.nextFreeEdgeIndex,!1),this.newPairEdgeEx(a.nextFreeEdgeIndex,!1)];3===e&&(e=this.orientation(b[0].p,b[1].p,b[2].p)+1);switch(e){case 0:this.joinEdges2(f[0],f[2]);this.joinEdges2(f[2],f[1]);this.joinEdges2(f[1],f[0]);this.join(c[0],c[2],0,1,a[0]);this.join(c[2],c[1],0,1,a[1]);this.join(c[1],c[0],0,1,a[2]);break;case 1:b=[0,1,2];b[3-(d+g)]=k.swap(b[1],b[1]=b[3-(d+g)]);this.joinEdges2(f[b[0]],f[b[1]]);this.joinEdges2(f[b[1]],
f[b[2]]);this.joinEdges2(f[b[2]],f[b[0]]);this.join(c[b[0]],c[b[1]],0,1,a[0]);this.join(c[b[1]],c[b[2]],0,1,a[1]);this.join(a[1].first,f[b[2]],0,1,a[2]);break;case 2:this.joinEdges2(f[0],f[1]),this.joinEdges2(f[1],f[2]),this.joinEdges2(f[2],f[0]),this.join(c[0],c[1],0,1,a[0]),this.join(c[1],c[2],0,1,a[1]),this.join(c[2],c[0],0,1,a[2])}break;default:c={k:0,pTask:null,pTask0:null,pTask1:null},b=y(),d=y(),this.splitTask(c,b,d,a),this.solveTask(b),this.solveTask(d),this.solveMergeTask(c)}}constructForConvexHull(){n.geometryReleaseAssert(0);
return!1}getOutsideHull(){const a=[],c=this.m_points[0].edge;let b=c;do a.push(this.getPointFromEdge(this.getTwinEdge(b))),b=this.getNextDEdge(b,0);while(b!==c);return a}getConvexHull(){const a=[],c=this.m_points[0].edge;let b=c;do{const d=this.getPointFromEdge(this.getTwinEdge(b));2>a.length||!this.insideLine(this.getPointXY(a.at(-2)),this.getPointXY(a.at(-1)),this.getPointXY(d))?a.push(d):a[a.length-1]=d;b=this.getNextDEdge(b,0)}while(b!==c);2<a.length&&this.insideLine(this.getPointXY(a[0]),this.getPointXY(a.at(-1)),
this.getPointXY(a.at(-2)))&&a.pop();2<a.length&&this.insideLine(this.getPointXY(a[1]),this.getPointXY(a[0]),this.getPointXY(a.at(-1)))&&(a[0]=a.at(-1),a.pop());return a}getVoronoiPolygon(a,c){a.length=0;for(var b=c=this.getEdgeFromPoint(c);;){const d=this.calculateCircleCenter(b);a.push(d);b=this.getNextDEdge(b,1);if(b===c)break}}getNearestPoint(a){this.isInfinitePointFromPoint(a)&&n.throwInvalidArgumentException("Not supported for the infinite point");const c=this.getPointXY(a);let b=this.m_pointZero,
d=Number.MAX_VALUE,e=a=this.getEdgeFromPoint(a);do{const g=this.getPointFromEdge(this.getTwinEdge(e));if(!this.isInfinitePointFromPoint(g)){const f=k.Point2D.sqrDistance(c,this.getPointXY(g));f<d&&(b=g,d=f)}e=this.getCounterClockwiseEdge(e)}while(e!==a);return b}addConstraint(a,c){const b=[null];var d=[null];if(!this.constraintFindFirstEdge(b,d,a,c))return m(d[0],b[0]);b[0]=this.getTwinEdge(b[0]);const e=this.getPointXY(a),g=this.getPointXY(c);a=[[],[]];const f=b[0];for(;;){var h=this.getClockwiseEdge(d[0]);
h.getMask()&&n.throwInvalidArgumentException("add_constraint");h=m(h,this.getTwinEdge(h));this.deleteTwinEdges(h,!0);h=this.getCounterClockwiseEdge(this.getTwinEdge(b[0]));const p=this.getTwinEdge(this.getClockwiseEdge(d[0]));var l=this.getPointFromEdge(p);if(l===c){a[0].push(b[0]);b[0]=h;a[1].push(d[0]);d[0]=p;break}l=this.orientation(e,g,this.getPointXY(l));0===l&&n.throwInvalidArgumentException("add_constraint - point on constraint");0<l?(a[0].push(b[0]),b[0]=h):(a[1].push(d[0]),d[0]=p)}a[0].push(b[0]);
a[1].push(d[0]);c=this.newPairEdge();c.first.setMask();c.second.setMask();this.join(d[0],f,1,1,c);this.triangulateConstraint(a[0],1,a[0].length-1,c);a[1].reverse();d=m(c.second,c.first);this.triangulateConstraint(a[1],1,a[1].length-1,d);return d}verify(){for(let a=0,c=this.m_edges.length;a<c;a++){const b=this.m_edges[a];if(!b.getMask()&&!this.testEdge(b))return!1}return!0}getDelaunayTriangleCount(){return this.m_points.length-2<<1}getSmallestEnclosingCircle(){n.geometryReleaseAssert(0);return{}}getVoronoiSegments(a=
Number.MAX_VALUE){const c=[];for(let f=0,h=this.m_edges.length;f<h;f+=2){var b=m(null,null);b.first=this.m_edges[f];b.second=b.first.twin;this.isInfinitePointFromEdge(b.first)&&(b.second=k.swap(b.first,b.first=b.second));if(this.isInfinitePointFromEdge(b.second)){var d=k.makeObjectArray(k.Point2D,3);d[0]=this.calculateCircleCenter(this.getNextDEdge(b.first,0).twin,1);d[2]=this.calculateCircleCenter(this.getNextDEdge(b.first,1),1);var e=k.makeObjectArray(k.Point2D,2);e[0].assign(d[0]);e[1].assign(d[2]);
e[0].rightPerpendicularThis();e[1].leftPerpendicularThis();d[1]=d[0].add(e[0]).add(d[2].add(e[1]));d[1].normalize();for(const l of d)l.mulThis(a);e=z();e.points[0]=b.first.p;e.points[1]=b.second.p;for(b=0;b<d.length-1;b++){for(var g=0;2>g;g++)e.p[g]=d[b+g];e.p[0].equals(e.p[1])||c.push(e)}}else if(this.isInfinitePointFromEdge(this.getNextDEdge(b.first,0).twin)&&this.isInfinitePointFromEdge(this.getNextDEdge(b.first,1).twin))for(d=k.makeObjectArray(k.Point2D,3),d[0]=this.calculateCircleCenter(b.first),
d[1]=this.getPointXY(this.getPointFromEdge(b.first)).add(this.getPointXY(this.getPointFromEdge(b.second))).mul(.5),d[2]=this.calculateCircleCenter(b.second),e=z(),e.points[0]=b.first.p,e.points[1]=b.second.p,b=0;b<d.length-1;b++){for(g=0;2>g;g++)e.p[g]=d[b+g];e.p[0].equals(e.p[1])||c.push(e)}else d=z(),d.p[0]=this.calculateCircleCenter(b.first),d.p[1]=this.calculateCircleCenter(b.second),d.points[0]=b.first.p,d.points[1]=b.second.p,d.p[0].equals(d.p[1])||c.push(d)}return c}startDelaunayTriangles(){return-1}nextDelaunayTriangle(a,
c){for(;;){++c[0];if(c[0]===this.m_edges.length)return!1;var b=this.m_edges[c[0]];a.p[0]=this.getPointFromEdge(b);if(this.isInfinitePointFromPoint(a.p[0]))continue;const d=this.getTwinEdge(b);a.p[1]=this.getPointFromEdge(d);if(!(this.isInfinitePointFromPoint(a.p[1])||this.getPointXY(a.p[1]).lt(this.getPointXY(a.p[0]))||(b=this.getTwinEdge(this.getNextDEdge(b,1)),a.p[2]=this.getPointFromEdge(b),this.isInfinitePointFromPoint(a.p[2])||this.getPointXY(a.p[2]).lt(this.getPointXY(a.p[0])))))return!0}}getPointCount(){return this.m_points.length-
1}getPoint(a){return this.m_points[a+1]}getInfinitePoint(){return this.m_pointZero}isInfinitePointFromPoint(a){return a===this.m_pointZero}getPointXY(a){return a.p}getPointIndex(a){return a.userData}setPointIndex(a,c){a.userData=c}getEdgeFromPoint(a){return a.edge}isInfinitePointFromEdge(a){return a.p===this.m_pointZero}getEdgeCount(){return this.m_edges.length}getEdge(a){return this.m_edges[a]}getEdgeIndex(a){return a.getIndex()}getPointFromEdge(a){return a.p}getPointXYFromEdge(a){return a.p.p}getCounterClockwiseEdge(a){return a.a[0]}getClockwiseEdge(a){return a.a[1]}getTwinEdge(a){return a.twin}getPreviousEdge(a){return this.getTwinEdge(this.getCounterClockwiseEdge(a))}getNextEdge(a){return this.getClockwiseEdge(this.getTwinEdge(a))}getPairEdgeFromPoint(a){n.geometryReleaseAssert(0);
return{}}getNextDEdge(a,c=1){return a.a[c]}newPairEdge(){const a=m(this.m_nextFreePairEdge.first,this.m_nextFreePairEdge.second);this.m_nextFreePairEdge.first=this.m_nextFreePairEdge.first.nextFreeEdge();this.m_nextFreePairEdge.second=this.m_nextFreePairEdge.second.nextFreeEdge();a.first.twin=a.second;a.second.twin=a.first;return a}newPairEdgeEx(a,c){c&&null!==this.m_nextFreePairEdge.first?(a=m(this.m_nextFreePairEdge.first,this.m_nextFreePairEdge.second),this.m_nextFreePairEdge.first=this.m_nextFreePairEdge.first.nextFreeEdge(),
this.m_nextFreePairEdge.second=this.m_nextFreePairEdge.second.nextFreeEdge()):(c=a[0]++,a=a[0]++,a=m(this.m_edges[c],this.m_edges[a]));a.first.twin=a.second;a.second.twin=a.first;return a}insertEdge(a,c,b){c.p=a.p;const d=a.a[b],e=c.a;e[b]=d;e[1-b]=a;a.a[b]=c;d.a[1-b]=c}insertPoint(a,c){const b=this.m_points[a];c=this.newPairEdgeEx(c,!1);const d=c.first,e=c.second;b.edge=c.first;d.p=this.m_points[a];d.a[0]=c.first;d.a[1]=c.first;e.p=this.m_pointZero;e.a[0]=c.second;e.a[1]=c.second;null===this.m_points[0].edge&&
(this.m_points[0].edge=c.second)}deleteTwinEdges(a,c){this.deleteEdge(a.first);this.deleteEdge(a.second);c&&(a.first.twin=this.m_nextFreePairEdge.first,a.second.twin=this.m_nextFreePairEdge.second,this.m_nextFreePairEdge=a)}join(a,c,b,d,e){this.insertEdge(a,e.first,b);this.insertEdge(c,e.second,d)}joinEdges2(a,c){a.a[1]=c;c.a[0]=a}joinEdges4(a,c,b,d){n.geometryReleaseAssert(0)}checkEdge(a,c,b,d,e){for(;;){const f=m(null,null);f.first=this.getNextDEdge(a.first,d);f.second=f.first.twin;if(this.isInfinitePointFromEdge(f.second))return a;
var g=this.getPointXYFromEdge(a.second);const h=this.getPointXYFromEdge(f.second);if(0>=this.inCircle(c,b,g,h))return a;this.deleteTwinEdges(a,e);e||(g=this.getNextDEdge(a.second,d).twin,this.join(f.second,g,d,d,a));a=f}}calculateCircleCenter(a,c=Number.MAX_VALUE){var b=this.getPointXYFromEdge(a);const d=this.getPointXYFromEdge(a.twin);a=this.getNextDEdge(a,0);if(this.isInfinitePointFromEdge(a.twin))return a=new k.Point2D,Number.isNaN(c)?a.setNAN():(b=d.sub(b),b.leftPerpendicularThis(),a.assign(b),
a.divThis(Math.max(Math.abs(a.x),Math.abs(a.y))),a.normalize(),a.mulThis(c)),a;c=this.getPointXYFromEdge(a.twin);return this.calculateCircleCenterFromThreePoints(b,d,c)}createZeroHandle(){return this.m_points[0]}deleteEdge(a){const c=a.p;c.edge===a&&(c.edge=a.a[0]);a.a[0].a[1]=a.a[1];a.a[1].a[0]=a.a[0]}testEdge(a){if(this.isInfinitePointFromEdge(a))return!0;var c=a.twin;if(this.isInfinitePointFromEdge(c))return!0;var b=this.getNextDEdge(a,0).twin,d=this.getNextDEdge(c,0).twin;if(this.isInfinitePointFromEdge(b)||
this.isInfinitePointFromEdge(d))return!0;a=this.getPointXYFromEdge(a);c=this.getPointXYFromEdge(c);b=this.getPointXYFromEdge(b);d=this.getPointXYFromEdge(d);return 0>=this.orientation(a,c,b)||0<=this.orientation(a,c,d)?!1:0>=this.inCircle(a,c,b,d)}findMaxSide(a,c){const b=[this.m_points[a].p.clone(),this.m_points[a].p.clone()];for(a++;a!==c;a++){const d=this.m_points[a].p;d.x<b[0].x&&(b[0].x=d.x);b[1].x<d.x&&(b[1].x=d.x);d.y<b[0].y&&(b[0].y=d.y);b[1].y<d.y&&(b[1].y=d.y)}return b[1].x-b[0].x<b[1].y-
b[0].y?1:0}findEdge(a,c,b){let d=!1,e=0;for(;;){const g=m(null,null);g.second=this.getNextDEdge(a[e].second,b^e);g.first=g.second.twin;if(0===b&&0>this.orientation(this.getPointXYFromEdge(a[0].first),this.getPointXYFromEdge(a[1].first),this.getPointXYFromEdge(g.first))||1===b&&0<this.orientation(this.getPointXYFromEdge(a[0].first),this.getPointXYFromEdge(a[1].first),this.getPointXYFromEdge(g.first)))a[e]=g,c[e]=!0,d=!1;else{if(d)break;e^=1;d=!0}}}findEdgeSide(a,c,b,d){for(;;){const e=m(null,null);
e.second=this.getNextDEdge(a[b].second,d^b);e.first=e.second.twin;if(!(0===d&&0>this.orientation(this.getPointXYFromEdge(a[0].first),this.getPointXYFromEdge(a[1].first),this.getPointXYFromEdge(e.first))||1===d&&0<this.orientation(this.getPointXYFromEdge(a[0].first),this.getPointXYFromEdge(a[1].first),this.getPointXYFromEdge(e.first))))break;a[b]=e;c[b]=!0}}merge(a,c,b,d,e){a={...a};d={...d};e={...e};c={...c};b={...b};const g=c.second,f=b.second;for(;;){this.join(c.first,b.first,0,1,e);c.first=this.getNextDEdge(e.first,
0);b.first=this.getNextDEdge(e.second,1);if(c.first===a.first&&b.first===d.first){this.joinEdges2(g,f);this.joinEdges2(d.second,a.second);break}c.second=c.first.twin;b.second=b.first.twin;const p=this.getPointXYFromEdge(e.first),t=this.getPointXYFromEdge(e.second);if(c.first===a.first){var h=m(null,null);h.first=this.getNextDEdge(b.first,1);h.second=h.first.twin;h=this.checkEdge(h,p,t,1,!1);w(c,e);w(e,b);b=m(h.second,h.first)}else if(b.first===d.first)h=m(null,null),h.first=this.getNextDEdge(c.first,
0),h.second=h.first.twin,h=this.checkEdge(h,p,t,0,!1),b=m(e.second,e.first),w(e,c),c=m(h.second,h.first);else{h=m(null,null);h.first=this.getNextDEdge(c.first,0);h.second=h.first.twin;h=this.checkEdge(h,p,t,0,!1);let q=m(null,null);q.first=this.getNextDEdge(b.first,1);q.second=q.first.twin;q=this.checkEdge(q,p,t,1,!1);var l=this.getPointXYFromEdge(h.second);const r=this.getPointXYFromEdge(q.second);l=this.inCircle(p,t,l,r);0===l&&(l=this.orientation(p,t,r));0<l?(w(c,e),w(e,b),b=m(q.second,q.first)):
(b=m(e.second,e.first),w(e,c),c=m(h.second,h.first))}this.deleteTwinEdges(e,!1)}}mergeForConvexHull(a,c,b,d){n.geometryReleaseAssert(0)}constructForConvexHullRecursive(a,c){n.geometryReleaseAssert(0)}findEdgeClockwise(a,c,b,d,e,g){for(a[0]=d;;){c[0]=a[0];++c[0]===b.length&&(c[0]=0);d=this.orientation(e,g,this.getPointXYFromEdge(b[c[0]]));if(0>=d)return 0>d;a[0]=c[0]}}findEdgeCounterClockwise(a,c,b,d,e,g){for(c[0]=d;;){a[0]=0!==c[0]?c[0]:b.length;a[0]--;d=this.orientation(e,g,this.getPointXYFromEdge(b[a[0]]));
if(0<=d)return 0<d;c[0]=a[0]}}constraintFindFirstEdge(a,c,b,d){const e=[];var g=this.getEdgeFromPoint(b),f=g;do{var h=this.getTwinEdge(f);if(this.getPointFromEdge(h)===d)return a[0]=h,c[0]=f,a[0].setMask(),c[0].setMask(),!1;e.push(h);f=this.getClockwiseEdge(f)}while(f!==g);3>e.length&&n.throwInvalidArgumentException("add_constraint");g=-1;for(let l=0,p=e.length;l<p;l++)this.isInfinitePointFromEdge(e[l])&&(-1!==g&&n.throwInvalidArgumentException("add_constraint"),g=l);b=this.getPointXY(b);d=this.getPointXY(d);
if(-1!==g)for(u.rotate(e,0,g+1,e.length),e.pop(),0===this.orientation(b,d,this.getPointXYFromEdge(e[0]))&&n.throwInvalidArgumentException("add_constraint - point on constraint"),0===this.orientation(b,d,this.getPointXYFromEdge(e.at(-1)))&&n.throwInvalidArgumentException("add_constraint - point on constraint"),g=0,f=e.length-1;g+1!==f;){h=g+f>>1;const l=this.orientation(b,d,this.getPointXYFromEdge(e[h]));0===l&&n.throwInvalidArgumentException("add_constraint - point on constraint");0<l?g=h:f=h}else g=
0,f=this.orientation(b,d,this.getPointXYFromEdge(e[g])),0!==f?0<f?(h=[0],f=[0],this.findEdgeClockwise(h,f,e,g,b,d)||n.throwInvalidArgumentException("add_constraint"),g=h[0],f=f[0]):(h=[0],f=[0],this.findEdgeCounterClockwise(h,f,e,g,b,d)||n.throwInvalidArgumentException("add_constraint"),g=h[0],f=f[0]):(g++,f=this.orientation(b,d,this.getPointXYFromEdge(e[g])),0>=f&&n.throwInvalidArgumentException("add_constraint"),h=[0],f=[0],this.findEdgeClockwise(h,f,e,g,b,d)||n.throwInvalidArgumentException("add_constraint"),
g=h[0],f=f[0]);a[0]=e[g];c[0]=e[f];return!0}triangulateConstraint(a,c,b,d){if(c!==b){var e=b;for(var g=c;g!==b;++g)0>this.inCircle(this.getPointXYFromEdge(d.first),this.getPointXYFromEdge(d.second),this.getPointXYFromEdge(a[e]),this.getPointXYFromEdge(a[g]))&&(e=g);e!==b&&(g=this.newPairEdge(),this.join(d.first,a[e],1,1,g),a[e]=g.second,this.triangulateConstraint(a,e+1,b,g));e!==c&&(b=this.newPairEdge(),this.join(a[e],d.second,1,0,b),this.triangulateConstraint(a,c,e-1,b))}}insideLine(a,c,b){return 0!==
this.orientation(a,c,b)?!1:c.x<a.x!==c.x<b.x||c.y<a.y!==c.y<b.y}orientation(a,c,b){return k.Point2D.orientationRobust(a,c,b)}inCircle(a,c,b,d){return k.Point2D.inCircleRobust(a,c,b,d)}calculateCircleCenterFromThreePoints(a,c,b){c.lt(a)&&(c=k.swap(a,a=c));b.lt(c)&&(b=k.swap(c,c=b));c.lt(a)&&(c=k.swap(a,a=c));return k.Point2D.calculateCircleCenterFromThreePoints(a,c,b)}compare(a,c){return 3*(((a[0]<c[0]?1:0)<<1)+(a[0]>c[0]?1:0))+((a[1]<c[1]?1:0)<<1)+(a[1]>c[1]?1:0)-1}caseFromCompare(a,c,b){return(this.compare(a,
c)<<6)+(this.compare(a,b)<<3)+this.compare(c,b)}}B.c_aTableDelaunayTriangulationSolution=Uint8Array.from([41,74,0,0,0,0,0,0,0,206,0,0,0,0,0,0,0,0,0,0,65,0,0,0,0,0,33,33,65,0,0,0,0,0,0,0,193,0,0,0,0,0,0,0,0,0,0,214,0,0,0,0,0,86,54,86,0,0,0,0,0,0,0,214,173,0,0,0,0,0,0,0,107,239,0,0,0,0,0,0,0,0,0,181,0,0,0,0,0,0,0,181,0,0,0,0,0,0,117,117,245,0,0,0,0,0,0,0,0,0,103,0,0,0,0,0,0,0,167,0,0,0,0,0,0,231,103,231,0,0,0,0,0,0,50,0,0,0,0,0,0,0,0,198,0,0,41,0,0,74,0,0,49,0,0,49,0,0,50,0,0,194,0,0,193,0,0,194,0,
0,0,0,0,206,0,0,0,0,0,0,0,0,54,0,0,0,0,0,0,0,0,198,0,0,0,0,0,82,50,82,0,0,0,0,0,0,0,198,0,66,0,0,65,0,0,66,49,66,33,57,65,82,50,90,0,194,0,0,193,0,0,194,0,0,0,0,0,0,0,214,0,0,0,0,0,86,54,86,0,0,0,0,0,0,0,222,0,0,0,0,0,0,178,0,0,0,0,0,0,230,102,230,177,0,0,177,0,0,178,0,177,0,0,177,0,0,178,0,113,226,113,113,249,226,122,226,0,0,0,0,0,0,102,0,0,0,0,0,0,0,190,0,0,0,0,0,0,230,102,230,0,0,0,165,0,0,0,0,0,0,0,0,243,0,0,0,0,0,173,0,0,0,0,0,0,0,0,165,0,0,0,0,0,0,0,0,245,0,0,0,0,0,107,0,0,239,0,0,163,0,0,163,
0,0,167,0,0,247,0,0,243,0,0,247,0,0,37,37,69,0,0,0,0,0,0,0,211,0,0,0,0,0,0,0,69,0,0,0,0,0,37,37,69,0,0,0,0,0,0,0,221,0,0,0,0,215,0,0,211,0,0,215,35,87,35,35,91,87,63,87,0,215,0,0,211,0,0,215,0,0,0,165,0,0,0,0,0,0,115,115,243,0,0,0,0,0,0,181,0,0,0,0,0,0,0,189,0,0,0,0,0,0,117,117,245,0,0,0,99,0,0,99,0,0,103,0,163,0,0,163,0,0,167,0,99,247,115,123,243,231,103,255]);class N{constructor(a){this.m_numberOfSets=a;this.m_elements=Array.from({length:a},(c,b)=>b);this.m_sizes=k.makePrimitiveArray(a,1)}getNumberOfSets(){return this.m_numberOfSets}connected(a,
c){return this.findRoot(a)===this.findRoot(c)}connect(a,c){a=this.findRoot(a);c=this.findRoot(c);if(a===c)return!1;this.m_sizes[a]<this.m_sizes[c]?(this.m_sizes[c]+=this.m_sizes[a],this.m_elements[a]=c):(this.m_sizes[a]+=this.m_sizes[c],this.m_elements[c]=a);--this.m_numberOfSets;return!0}connectRange(a,c,b){if(c!==b)for(let d=c;d<b;++d)this.connect(a[c],a[d])}size(){return this.m_elements.length}size1(a){n.geometryReleaseAssert(0);return 0}findRoot(a){if(this.m_elements[a]!==a){do this.m_elements[a]=
this.m_elements[this.m_elements[a]],a=this.m_elements[a];while(this.m_elements[a]!==a)}return a}}class O{getOperatorType(){return 10112}accelerateGeometry(a,c,b){return!1}canAccelerateGeometry(a){return!1}supportsCurves(){return!1}executeMany(a,c,b,d){return new H(a,c,b,d)}execute(a,c,b,d=null){c=new H(null,c,!1,b);c.addGeometry(a);return c.buildAlphaShape(d)}}class H extends E.GeometryCursor{alphaShapeConstruct(a,c){const b=a.getEdgeCount(),d=new u.Polygon({vd:this.m_vertexDescription});if(!d)throw Error("alphaShapeConstruct");
for(let g=0;g<b;++g){if(2!==c[g])continue;const f=m(null,null);f.first=a.getEdge(g);f.second=a.getTwinEdge(f.first);var e=a.getEdgeIndex(f.second);if(1!==c[e])continue;a.getPointXYFromEdge(f.first);d.startPath(a.getPointXYFromEdge(f.first));e=g;let h=f.second;for(;;){c[e]=3;for(h=a.getCounterClockwiseEdge(h);1===c[a.getEdgeIndex(h)];)h=a.getCounterClockwiseEdge(h);if(h===f.first)break;d.lineTo(a.getPointXYFromEdge(h));e=a.getEdgeIndex(h);h=a.getTwinEdge(h)}}return d}alphaShape(a,c){const b=a.getEdgeCount(),
d=new Uint8Array(b);for(let p=0;p<b;++p){if(0!==d[p])continue;var e=[null,null,null],g=a.getEdge(p);e[0]=a.getPointFromEdge(g);var f=a.getClockwiseEdge(a.getTwinEdge(g));e[1]=a.getPointFromEdge(f);g=a.getEdgeIndex(f);f=a.getClockwiseEdge(a.getTwinEdge(f));e[2]=a.getPointFromEdge(f);f=a.getEdgeIndex(f);let t=1;for(var h=0;3>h;++h)if(a.isInfinitePointFromPoint(e[h])){t=2;break}if(1===t){h=k.makeObjectArray(k.Point2D,3);for(var l=0;3>l;++l)h[l]=a.getPointXY(e[l]);e=k.Point2D.sqrDistance(h[0],h[1]);l=
k.Point2D.sqrDistance(h[1],h[2]);const q=k.Point2D.sqrDistance(h[2],h[0]);h=2*h[1].sub(h[0]).crossProduct(h[2].sub(h[0]));c<e*l*q/(h*h)&&(t=2)}d[p]=d[g]=d[f]=t}return this.alphaShapeConstruct(a,d)}alphaShapeAlphaOut(a,c){var b=a.getEdgeCount();const d=new Uint8Array(b),e=[],g=new N(a.getPointCount());for(let r=0;r<b;++r)if(0===d[r]){var f=[null,null,null],h=a.getEdge(r);f[0]=a.getPointFromEdge(h);var l=a.getClockwiseEdge(a.getTwinEdge(h));f[1]=a.getPointFromEdge(l);h=a.getEdgeIndex(l);l=a.getClockwiseEdge(a.getTwinEdge(l));
f[2]=a.getPointFromEdge(l);l=a.getEdgeIndex(l);var p=1;for(var t=0;3>t;++t)if(a.isInfinitePointFromPoint(f[t])){p=2;break}if(1===p){var q=Array(3);for(p=0;3>p;++p)q[p]=a.getPointXY(f[p]);p=k.Point2D.sqrDistance(q[0],q[1]);t=k.Point2D.sqrDistance(q[1],q[2]);const C=k.Point2D.sqrDistance(q[2],q[0]);q=q[1].sub(q[0]).crossProduct(q[2].sub(q[0]));const v=k.makePair(Number.NaN,k.makePair([0,0,0],[0,0,0]));v.first=p*t*C/(q*q);v.second.first[0]=r;v.second.first[1]=h;v.second.first[2]=l;v.second.second[0]=
a.getPointIndex(f[0]);v.second.second[1]=a.getPointIndex(f[1]);v.second.second[2]=a.getPointIndex(f[2]);e.push(v);p=2}d[r]=d[h]=d[l]=p}e.sort((r,C)=>L(r,C));b=0;for(const r of e){if(1===g.getNumberOfSets()&&r.first!==b)break;d[r.second.first[0]]=d[r.second.first[1]]=d[r.second.first[2]]=1;g.connectRange([r.second.second[0],r.second.second[1],r.second.second[2]],0,3);b=r.first}c&&(c[0]=.25*b);return this.alphaShapeConstruct(a,d)}constructor(a,c,b,d){super();this.m_inputGeometryCursor=this.m_multiPointForAttributes=
null;this.m_index=-1;this.m_nDelaunayPoints=0;this.m_cDelaunay=new B;this.m_vertexDescription=null;this.m_progressTracker=d;this.m_alpha=Number.isNaN(c)||!Number.isFinite(c)||0>c?-1:c<Number.MIN_VALUE?0:c;this.m_bMerge=b;this.m_bDone=!1;this.m_inputGeometryCursor=a;this.prepareDelaunay()}prepareDelaunay(){this.m_nDelaunayPoints=0;this.m_cDelaunay.clear();0!==this.m_alpha&&this.m_cDelaunay.prepare(k.intMax())}next(){if(this.m_bMerge){if(!this.m_bDone){var a=this.calculateAlphaShapeMerging(this.m_inputGeometryCursor,
this.m_progressTracker);this.m_bDone=!0;return a}return null}if(!this.m_bDone){a=this.m_inputGeometryCursor.next();if(null!==a)return n.throwIfCurves(a),n.throwIfMesh(a),this.m_index=this.m_inputGeometryCursor.getGeometryID(),this.calculateAlphaShape(a,this.m_progressTracker);this.m_bDone=!0}return null}tock(){return!0}getRank(){return 1}getGeometryID(){return this.m_index}calculateAlphaShapeMerging(a,c){for(;c=a.next();)n.throwIfCurves(c),n.throwIfMesh(c),this.addGeometry(c);return this.buildAlphaShape()}calculateAlphaShape(a,
c){if(a.isEmpty())return new u.Polygon({vd:a.getDescription()});this.prepareDelaunay();this.addGeometry(a);return this.buildAlphaShape()}buildAlphaShape(a=null){a&&(a[0]=this.m_alpha);if(0===this.m_alpha)return this.m_vertexDescription?new u.Polygon({vd:this.m_vertexDescription}):new u.Polygon;if(this.m_cDelaunay.removeDuplicates())for(let c=0,b=this.m_cDelaunay.getPointCount();c<b;++c)this.m_cDelaunay.setPointIndex(this.m_cDelaunay.getPoint(c),c);return this.m_cDelaunay.construct()?0>this.m_alpha?
this.alphaShapeAlphaOut(this.m_cDelaunay,a):this.alphaShape(this.m_cDelaunay,this.m_alpha):this.m_vertexDescription?new u.Polygon({vd:this.m_vertexDescription}):new u.Polygon}addGeometry(a){n.throwIfCurves(a);n.throwIfMesh(a);if(0!==this.m_alpha&&(this.m_vertexDescription&&this.m_bMerge||(this.m_vertexDescription=a.getDescription(),1<this.m_vertexDescription.getAttributeCount()?this.m_multiPointForAttributes=new u.MultiPoint({vd:this.m_vertexDescription}):this.m_multiPointForAttributes=null),!a.isEmpty())){var c=
a.getGeometryType();if(n.isMultiVertex(c)){c=new k.Point2D;for(let b=0,d=a.getPointCount();b<d;b++)a.queryXY(b,c),this.m_cDelaunay.addVertex(c,this.m_nDelaunayPoints++);this.m_multiPointForAttributes&&this.m_multiPointForAttributes.addPoints(a,0,-1)}else c===n.GeometryType.enumPoint?(c=a.getXY(),this.m_cDelaunay.addVertex(c,this.m_nDelaunayPoints++),this.m_multiPointForAttributes&&this.m_multiPointForAttributes.add(a)):n.throwInvalidArgumentException("bad geometry type")}}}const D=new O;x.execute=
function(a,c,b){return D.execute(a,c,null,b)};x.executeMany=function(a,c,b){a=D.executeMany(new E.SimpleGeometryCursor(a),c,b,null);return Array.from(a)};x.supportsCurves=function(){return D.supportsCurves()};Object.defineProperty(x,Symbol.toStringTag,{value:"Module"})});