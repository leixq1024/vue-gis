// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.31/esri/copyright.txt for details.
//>>built
define("../../../geometry ../../../Graphic ../../../core/arrayUtils ../../../core/promiseUtils ../../../core/accessorSupport/ensureType ../../../geometry/Mesh ../../../geometry/projection ../../../geometry/support/MeshVertexAttributes ../../../layers/orientedImagery/core/coverageUtils ../symbols ../../../geometry/Point".split(" "),function(L,q,z,n,B,A,t,C,u,r,D){async function E(p,a,d,e){return Float64Array.from((await Promise.all(p.reduce((c,f,b)=>{b=Math.floor(b/3);c[b]=c[b]??[];c[b].push(f);return c},
[]).map(async c=>(await t.projectWithZConversion(new D(c,a),d,e)).toArray()))).flat())}class F{constructor(p){this.viewModel=p;this.createFootprints=async a=>{const {coverageFrustums:d,currentBestFeature:e,isAdditionalCoverageVisible:c,view:f}=this.viewModel;var b=d.filter(z.isSome);for(const g of b){b=g.clone();if(!f.spatialReference.equals(b.spatialReference)){const {components:m,spatialReference:v,origin:h,vertexAttributes:w,vertexSpace:x}=b;if("local"===x.type){const y=await t.projectWithZConversion(h,
f.spatialReference,a);n.throwIfAborted(a);b.centerAt(y)}else b=Float64Array.from(await u.projectVertices([...w.position],v.clone(),f.spatialReference.clone(),a)),n.throwIfAborted(a),b=new A({vertexAttributes:new C.MeshVertexAttributes({position:b}),components:m,spatialReference:f.spatialReference.clone()})}g.imageID===e.attributes.objectId?this.viewModel.bestFeatureFootprint=new q({attributes:{imageID:g.imageID},geometry:b,symbol:r.activeFrustumSymbol.clone(),visible:!1}):this.viewModel.additionalFootprints.push(new q({attributes:{imageID:g.imageID},
geometry:b,symbol:r.additionalFrustumSymbol.clone(),visible:c}))}};this.updateFootprint=async(a,d)=>{const {currentBestFeature:e,activeViewer:c,footprintExtent:f,view:b}=this.viewModel;var g=B.ensureType(A,this.viewModel.bestFeatureFootprint.geometry);const m=c?.imageSize;if(e&&g&&m&&f){var {cameraHeight:v,location:h,cameraPitch:w,horizontalFieldOfView:x,verticalFieldOfView:y,cameraRoll:G}=e.attributes,H=h.toArray(),{vertexAttributes:{position:I},spatialReference:J}=g;g=await E(I,J,h.spatialReference);
var k=await this.viewModel.getMapPoint(a,{feature:e,mode:"default",imageSize:m});n.throwIfAborted(d);k=k.filter(z.isSome);k.length&&(k[0].spatialReference.equals(h.spatialReference)||(k=await Promise.all(k.map(async l=>{l=await t.projectWithZConversion(l,h.spatialReference,d);n.throwIfAborted(d);return l}))),a=await u.updateFrustum(a.map(({x:l,y:K})=>[l,K]),k.map(l=>l.toArray()),{cameraHeight:v,cameraLocation:H,cameraPitch:w,frustumVertices:g,horizontalFieldOfView:x,imageHeight:m[1],imageWidth:m[0],
inSRS:{wkid:h.spatialReference.wkid},outSRS:{wkid:b.spatialReference.wkid},verticalFieldOfView:y,cameraRoll:G??0,options:d}),this.viewModel.updateCurrentCoveragePolygon(new q({attributes:{imageID:e.attributes.objectId},geometry:a,symbol:r.activeFrustumSymbol.clone(),visible:this.viewModel.currentCoverageVisible})))}else this.viewModel.updateCurrentCoveragePolygon(null)};this.updateFootprintPanorama=async(a,d)=>{await n.waitTick(d);const {horizontalFieldOfView:e,pitch:c,verticalFieldOfView:f,yaw:b}=
a;if(a=this.viewModel.currentBestFeature?.clone())({attributes:a}=a),a.orientedImageryType=null,a.cameraHeading=(b+a.cameraHeading)%360,a.cameraPitch=c,a.horizontalFieldOfView=e,a.verticalFieldOfView=f,a.cameraRoll=0,{frustum:d}=u.createCoveragePolygon(a),d?this.viewModel.updateCurrentCoveragePolygon(new q({attributes:{imageID:a.objectId},geometry:d,symbol:r.activeFrustumSymbol.clone(),visible:this.viewModel.currentCoverageVisible})):this.viewModel.updateCurrentCoveragePolygon(null)}}updateGroundElevation(p,
a){const {geometry:d}=this.viewModel.currentBestFeature,e=a.queryElevation(d);p.forEach(c=>{({geometry:c}=c);switch(c?.type){case "mesh":({vertexAttributes:{position:c}}=c);const f=Math.floor(c.length/3);for(let b=0;b<f;b+=1)c[3*b+2]+=e?.z??0;break;case "point":c.z=(c.z??0)+(e?.z??0)}})}}return F});