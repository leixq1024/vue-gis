// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.31/esri/copyright.txt for details.
//>>built
define("require exports ../../../chunks/tslib.es6 ../../../core/Accessor ../../../core/asyncUtils ../../../core/Evented ../../../core/has ../../../core/promiseUtils ../../../core/reactiveUtils ../../../core/accessorSupport/decorators/property ../../../core/Logger ../../../core/RandomLCG ../../../core/accessorSupport/decorators/subclass ../../../geometry/projection ../../../support/elevationInfoUtils ../sketch/normalizedPoint ./Settings ./SnappingDomain ./SnappingOptions ./snappingUtils ./candidates/DrapedEdgeSnappingCandidate ./candidates/EdgeSnappingCandidate ./candidates/IntersectionSnappingCandidate ./candidates/LineSnappingCandidate ./candidates/ParallelLineSnappingCandidate ./candidates/RightAngleSnappingCandidate ./candidates/RightAngleTriangleSnappingCandidate ../support/viewUtils".split(" "),
function(y,m,p,H,I,J,T,u,v,r,U,V,K,z,A,n,D,w,L,E,M,N,x,O,P,F,Q,R){function B(a,b){return!b||null==b.direction&&null==b.distance?!0:a instanceof M.DrapedEdgeSnappingCandidate||a instanceof N.EdgeSnappingCandidate||a instanceof O.LineSnappingCandidate||a instanceof P.ParallelLineSnappingCandidate||a instanceof Q.RightAngleTriangleSnappingCandidate||a instanceof F.RightAngleSnappingCandidate&&(null!=b.direction||a.selfSnappingType!==F.SelfSnappingRightAngleType.LastVertex)?!1:!0}function C(a,b){let c=
-1;for(let d=0;d<a.length;++d)if(b.constraint.equals(a[d].constraint)){c=d;break}return c}function S({coordinateHelper:a,elevationInfo:b}){return a.hasZ()?A.absoluteHeightElevationInfo:b}m.SnappingManager=class extends J.EventedMixin(H){constructor(a){super(a);this.options=new L;this._engineCache=new Map;this._loadTask=null;this._engines=[];this._currentMainCandidate=null;this._currentOtherActiveCandidates=[];this._currentSnappedType=q.MAIN}initialize(){this.addHandles([v.watch(()=>{const {distance:a,
touchSensitivityMultiplier:b,effectiveSelfEnabled:c,effectiveFeatureEnabled:d,effectiveGridEnabled:e}=this.options;return{selfEnabled:c,featureEnabled:d,gridEnabled:"2d"===this.view.type&&e,viewReady:this.view.ready,viewSpatialReference:this.view.spatialReference,distance:a,touchSensitivityMultiplier:b}},(a,b)=>{b&&(this.doneSnapping(),this.emit("changed"));this._loadTask?.abort();this._loadTask=I.createTask(c=>this._updateEngines(a,b,c))},v.syncAndInitial),v.watch(()=>this.options,a=>{for(const b of this._engines)b.options=
a},v.sync)])}destroy(){this._destroyEngines()}get updating(){return this._engines.some(a=>a.updating)||!this._loadTask?.finished}_destroyEngines(){this._engineCache.forEach(a=>a.destroy());this._engineCache.clear();this._engines=[]}async _updateEngines(a,b,c){if(a.viewReady){b?.viewSpatialReference!==a.viewSpatialReference&&this._destroyEngines();({_engineCache:b}=this);var d=[];a.featureEnabled&&!b.has("feature")&&d.push(this._setupFeatureSnappingEngine(c));a.selfEnabled&&!b.has("self")&&d.push(this._setupSelfSnappingEngine(c));
a.gridEnabled&&!b.has("grid")&&"2d"===this.view.type&&d.push(this._setupGridSnappingEngine(c));await Promise.allSettled(d);c.aborted||(this._engines=Array.from(b.values()))}else this._destroyEngines()}async _setupSelfSnappingEngine(a){const {SelfSnappingEngine:b}=await new Promise((c,d)=>y(["./SelfSnappingEngine"],c,d));u.throwIfAborted(a);a=new b({view:this.view,options:this.options});this._engineCache.set("self",a)}async _setupGridSnappingEngine(a){const {view:b}=this,{GridSnappingEngine:c}=await new Promise((d,
e)=>y(["./GridSnappingEngine"],d,e));u.throwIfAborted(a);"2d"===b.type&&(a=new c({view:b,options:this.options}),this._engineCache.set("grid",a))}async _setupFeatureSnappingEngine(a){const {FeatureSnappingEngine:b}=await new Promise((f,k)=>y(["./FeatureSnappingEngine"],f,k));u.throwIfAborted(a);const {view:c,options:d,_engineCache:e}=this;a=new b({view:c,options:d,spatialReference:c.spatialReference});e.set("feature",a)}get _squaredMouseProximityThreshold(){return this.options.distance*this.options.distance}get _squaredTouchProximityThreshold(){const {distance:a,
touchSensitivityMultiplier:b}=this.options,c=a*b;return c*c}snap(a){return null!=a.scenePoint?this._snapMultiPoint(a):this._snapSinglePoint(a)}update(a){const {point:b,context:c}=a;this._removeVisualization();const d=this._currentMainCandidate;if(null==d)return b;var e=this._selectUpdateInput(a);if(null==e)return b;({spatialReference:a}=c);var f=z.project(e,a);if(null==f)return b;({view:e}=this);const {elevationInfo:k,visualizer:l}=c,g=[];f=n.fromPoint(f,e,k);const h=d.constraint.closestTo(f);if(!this._arePointsWithinScreenThreshold(f,
h,c)||!B(d,c.drawConstraints))return this._resetSnappingState(),b;d.targetPoint=n.markAsTarget(h);g.push(...d.hints);for(const t of this._currentOtherActiveCandidates)B(t,c.drawConstraints)&&(t.targetPoint=n.markAsTarget(h),g.push(...t.hints));null!=l&&this.addHandles(l.draw(g,{spatialReference:a,elevationInfo:S(c),view:e,selfSnappingZ:c.selfSnappingZ}),"visualization-handle");return n.toElevationAlignedDehydratedPoint(h,e,b,c)}doneSnapping(){this._removeVisualization();this._resetSnappingState()}_selectUpdateInput({point:a,
scenePoint:b}){switch(this._currentSnappedType){case q.MAIN:return a;case q.SCENE:return b}}_resetSnappingState(){this._currentMainCandidate=null;this._currentOtherActiveCandidates=[];this._currentSnappedType=q.MAIN}_removeVisualization(){this.removeHandles("visualization-handle")}async _snapSinglePoint({point:a,context:b,signal:c}){const {view:d}=this;var {elevationInfo:e}=b;e=n.fromPoint(a,d,e);const f=await this._fetchCandidates(e,w.SnappingDomain.ALL,b,c);return this._createSnapResult(e,q.MAIN,
f,d,a,b,c)}async _snapMultiPoint({point:a,scenePoint:b,context:c,signal:d}){const {view:e}=this,{coordinateHelper:f,elevationInfo:k,spatialReference:l}=c;await z.initializeProjection(b.spatialReference,l);b=z.project(b,l);var g=n.fromPoint(b,e,k);const h=await this._fetchCandidates(g,w.SnappingDomain.FEATURE,c,d);if(0<h.length)return a=await this._fetchCandidates(g,w.SnappingDomain.SELF,c,d),this._createSnapResult(g,q.SCENE,[...h,...a],e,b,c,d);b=n.fromPoint(a,e,k);g=await this._fetchCandidates(b,
w.SnappingDomain.SELF,c,d);return this._createSnapResult(b,q.MAIN,g,e,{z:f.hasZ()&&a.hasZ?a.z??0:void 0,m:f.hasM()&&a.hasM?a.m??0:void 0},c,d)}async _fetchCandidates(a,b,c,d){return(await Promise.all(this._engines.map(e=>e.fetchCandidates(a,b,c,d)))).flat()}_createSnapResult(a,b,c,d,e,f,k){return{get valid(){return!u.isAborted(k)},apply:()=>{const {spatialReference:l}=f,{snappedPoint:g,hints:h}=this._processCandidates(a,b,c,f);this._removeVisualization();null!=f.visualizer&&this.addHandles(f.visualizer.draw(h,
{spatialReference:l,elevationInfo:A.absoluteHeightElevationInfo,view:d,selfSnappingZ:f.selfSnappingZ}),"visualization-handle");return n.toElevationAlignedDehydratedPoint(g,d,e,f)}}}_processCandidates(a,b,c,d){if(1>c.length)return this.doneSnapping(),{snappedPoint:a,hints:[]};this._currentSnappedType!==b&&this._resetSnappingState();E.sortCandidatesInPlace(a,c);const e=this._currentMainCandidate;if(null!=e){var f=e instanceof x.IntersectionSnappingCandidate?0<=C(c,e.first)&&0<=C(c,e.second)?0:-1:C(c,
e);if(0<=f)if(c[f]instanceof x.IntersectionSnappingCandidate){if(this._arePointsWithinScreenThreshold(a,e.targetPoint,d))return this._updateSnappingCandidate(e,b,c,d)}else return this._intersectWithOtherCandidates(f,c,a,b,d)}return this._intersectWithOtherCandidates(0,c,a,b,d)}_intersectWithOtherCandidates(a,b,c,d,e){const {coordinateHelper:f}=e,k=b[a],l=[];for(let g=0;g<b.length;++g){if(g===a)continue;const h=b[g],t=k.constraint.intersect(h.constraint);if(t)for(const G of t.closestPoints(k.targetPoint))l.push([new x.IntersectionSnappingCandidate(n.markAsTarget(G),
k,h,h.isDraped),this._squaredScreenDistance(c,G,f)])}return 0<l.length&&(l.sort((g,h)=>g[1]-h[1]),l[0][1]<this._squaredPointProximityThreshold(e.pointer))?this._updateSnappingCandidate(l[0][0],d,b,e):B(k,e.drawConstraints)?this._updateSnappingCandidate(k,d,b,e):{snappedPoint:c,hints:[]}}_updateSnappingCandidate(a,b,c,d){this.doneSnapping();this._currentMainCandidate=a;this._currentSnappedType=b;b=this._currentMainCandidate.targetPoint;const e=[];e.push(...a.hints);for(const f of c){if(a instanceof
x.IntersectionSnappingCandidate){if(f.constraint.equals(a.first.constraint)||f.constraint.equals(a.second.constraint))continue}else if(f.constraint.equals(a.constraint))continue;c=f.constraint.closestTo(b);this._squaredScreenDistance(c,b,d.coordinateHelper)<D.defaults.satisfiesConstraintScreenThreshold*D.defaults.satisfiesConstraintScreenThreshold&&(f.targetPoint=b,this._currentOtherActiveCandidates.push(f),e.push(...f.hints))}return{snappedPoint:b,hints:e}}_squaredPointProximityThreshold(a){return"touch"===
a?this._squaredTouchProximityThreshold:this._squaredMouseProximityThreshold}_arePointsWithinScreenThreshold(a,b,c){return this._squaredScreenDistance(a,b,c.coordinateHelper)<this._squaredPointProximityThreshold(c.pointer)}_squaredScreenDistance(a,b,c){return E.squaredScreenDistance(this._toScreen(a,c),this._toScreen(b,c))}_toScreen(a,b){return R.vectorToScreenPoint(a,b.spatialReference,A.absoluteHeightElevationInfo,this.view)}get test(){}};p.__decorate([r.property({constructOnly:!0})],m.SnappingManager.prototype,
"view",void 0);p.__decorate([r.property()],m.SnappingManager.prototype,"options",void 0);p.__decorate([r.property({readOnly:!0})],m.SnappingManager.prototype,"updating",null);p.__decorate([r.property()],m.SnappingManager.prototype,"_loadTask",void 0);p.__decorate([r.property()],m.SnappingManager.prototype,"_engines",void 0);p.__decorate([r.property()],m.SnappingManager.prototype,"_squaredMouseProximityThreshold",null);p.__decorate([r.property()],m.SnappingManager.prototype,"_squaredTouchProximityThreshold",
null);m.SnappingManager=p.__decorate([K.subclass("esri.views.interactive.snapping.SnappingManager")],m.SnappingManager);var q;(function(a){a[a.MAIN=0]="MAIN";a[a.SCENE=1]="SCENE"})(q||={});Object.defineProperty(m,Symbol.toStringTag,{value:"Module"})});