// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.31/esri/copyright.txt for details.
//>>built
define("exports ../../../chunks/tslib.es6 ../../../core/Accessor ../../../core/Logger ../../../core/mathUtils ../../../core/unitUtils ../../../core/accessorSupport/decorators/property ../../../core/has ../../../core/RandomLCG ../../../core/accessorSupport/decorators/subclass ../../../chunks/vec32 ../../../geometry/projection ../../../geometry/support/normalizeUtils ../../../geometry/support/scaleUtils ../../2d/grid/constants ../../2d/grid/gridUtils ../sketch/normalizedPoint ./snappingUtils ./candidates/IntersectionSnappingCandidate ./candidates/LineSnappingCandidate".split(" "),
function(d,e,I,J,A,K,g,R,S,L,B,t,M,N,O,C,l,P,Q,D){d.GridSnappingEngine=class extends I{constructor(a){super(a);this.options=null}destroy(){this._set("options",null)}get grid(){return this.view.grid}get effectiveViewRotation(){return this.grid?.rotateWithMap?0:A.deg2rad(this.view.rotation??0)}get gridRotation(){return A.deg2rad(this.grid?.rotation??0)}get gridCenter(){const {spatialReference:a,grid:c}=this;if(!c||!a||!t.isLoadedOrLoadFor(c.center.spatialReference,a))return null;try{const b=t.project(c.center,
a),f=a.isWrappable&&null!=this.view?.center?M.getClosestDenormalizedXToReference(b.x,this.view.center.x,a):b.x;return l.create(f,b.y,b.z)}catch(b){return J.getLogger(this).errorOnce("Grid Snapping - Failed to project grid center.",b),null}}get offsetScaleFactor(){const {pixelsPerStride:a,grid:c}=this;if(!c||!a)return 1;const {majorLineInterval:b,dynamicScaling:f}=c;return 1>b?null:C.getScaleFactor(b,a,f)}get spatialReference(){return this.view.spatialReference}get gridMetersPerStride(){const {grid:a}=
this;return a?K.convertUnit(a.spacing,a.units,"meters"):null}get viewMetersPerPixel(){const {viewMetersPerSRUnit:a}=this;return null==a?null:a*N.getResolutionForScale(this.view.scale,this.view.spatialReference)}get viewMetersPerSRUnit(){const {spatialReference:a}=this.view;return this.gridCenter?C.measureMetersPerUnitAtReferencePoint(this.gridCenter[0],this.gridCenter[1],a):null}get pixelsPerStride(){const {gridMetersPerStride:a,viewMetersPerPixel:c}=this;return c&&a?a/c:null}get updating(){return null!=
this.grid&&null!=this.spatialReference&&null==this.viewMetersPerSRUnit}async fetchCandidates(a,c,b){const {options:f,view:m}=this;if(!f?.effectiveGridEnabled||!m.grid||b.feature?.attributes&&P.gridPlacementGraphicSymbol in b.feature.attributes)return[];a=b.coordinateHelper.arrayToPoint(a);return this.fetchCandidatesSync(a,f.distance*("touch"===b.pointer?f.touchSensitivityMultiplier:1))}fetchCandidatesSync(a,c){const b=[],{grid:f,effectiveViewRotation:m,gridRotation:p,gridCenter:h,viewMetersPerPixel:u,
viewMetersPerSRUnit:v,offsetScaleFactor:E,spatialReference:y,gridMetersPerStride:F,pixelsPerStride:G}=this;if(!(f&&u&&v&&h&&y&&E&&F&&G)||!f.dynamicScaling&&G<O.minimumPixelsPerStrideForDisplayWhenScalingOff||!t.isLoadedOrLoadFor(a.spatialReference,y))return b;a=t.project(a,y);a=l.create(a.x,a.y,a.z);a=q(a,-p,h,-m);const n=F/v*E;var k=(a[0]-h[0])/n;var r=(a[1]-h[1])/n;k=l.create(h[0]+(Math.trunc(k)+Math.round(k%1))*n,h[1]+(Math.trunc(r)+Math.round(r%1))*n);c=0>=u?{shouldSnapX:!1,shouldSnapY:!1}:{shouldSnapX:Math.abs((k[0]-
a[0])/u*v)<c,shouldSnapY:Math.abs((k[1]-a[1])/u*v)<c};const {shouldSnapX:w,shouldSnapY:x}=c;if(!w&&!x)return[];c=l.create((w?k:a)[0],(x?k:a)[1]);c=q(c,p,h,m);r=q(k,p,h,m);if(x){var z=H(k,a,n,"y");z=q(z,p,h,m);b.push(new D.LineSnappingCandidate({lineStart:r,lineEnd:z,targetPoint:c,isDraped:!1}))}w&&(a=H(k,a,n,"x"),a=q(a,p,h,m),b.push(new D.LineSnappingCandidate({lineStart:r,lineEnd:a,targetPoint:c,isDraped:!1})));w&&x&&b.push(new Q.IntersectionSnappingCandidate(c,b[0],b[1],!1));return b}};e.__decorate([g.property({constructOnly:!0})],
d.GridSnappingEngine.prototype,"view",void 0);e.__decorate([g.property()],d.GridSnappingEngine.prototype,"options",void 0);e.__decorate([g.property()],d.GridSnappingEngine.prototype,"grid",null);e.__decorate([g.property()],d.GridSnappingEngine.prototype,"effectiveViewRotation",null);e.__decorate([g.property()],d.GridSnappingEngine.prototype,"gridRotation",null);e.__decorate([g.property()],d.GridSnappingEngine.prototype,"gridCenter",null);e.__decorate([g.property()],d.GridSnappingEngine.prototype,
"offsetScaleFactor",null);e.__decorate([g.property()],d.GridSnappingEngine.prototype,"spatialReference",null);e.__decorate([g.property()],d.GridSnappingEngine.prototype,"gridMetersPerStride",null);e.__decorate([g.property()],d.GridSnappingEngine.prototype,"viewMetersPerPixel",null);e.__decorate([g.property()],d.GridSnappingEngine.prototype,"viewMetersPerSRUnit",null);e.__decorate([g.property()],d.GridSnappingEngine.prototype,"pixelsPerStride",null);e.__decorate([g.property()],d.GridSnappingEngine.prototype,
"updating",null);d.GridSnappingEngine=e.__decorate([L.subclass("esri.views.interactive.snapping.GridSnappingEngine")],d.GridSnappingEngine);const q=(a,c,b,f)=>{a=l.createWritable(a[0],a[1],a[2]);return B.rotateZ(a,B.rotateZ(a,a,b,c),b,f)},H=(a,c,b,f)=>"y"===f?l.create(a[0]+b*(c[0]>a[0]?1:-1),a[1]):l.create(a[0],a[1]+b*(c[1]>a[1]?1:-1));Object.defineProperty(d,Symbol.toStringTag,{value:"Module"})});