// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.31/esri/copyright.txt for details.
//>>built
define("../../../../geometry ../../../../core/events ../../../../core/Handles ../../../../core/maybe ../../../../core/reactiveUtils ../../../../core/screenUtils ../../../../core/libs/gl-matrix-2/factories/vec2f64 ../../../../geometry/projection ../DisplayObject ../../../layers/support/Geometry ../../../webgl/enums ../../../webgl/Texture ../../../webgl/TextureDescriptor ../../../../geometry/Polygon ../../../../geometry/Point".split(" "),function(K,z,A,B,x,v,C,m,D,E,F,G,H,I,w){class J extends D.DisplayObject{constructor(b){super();
this.element=b;this._handles=new A;this.isWrapAround=!1;this.perspectiveTransform=C.create();this.wrapAroundShift=0;this.clipGeometry=null;this._handles.add(x.when(()=>this.element,()=>{const a=this.element;this.ready();a&&this._handles.add(z.on(a,"play",()=>this.requestRender()))},x.initial))}getMesh(b){throw Error("Method not implemented.");}destroy(){this._handles.destroy();this.texture=B.disposeMaybe(this.texture)}get textureSize(){if(!this.texture)return[1,1];const b=this.texture.descriptor;
return[b.width,b.height]}get dvsMat3(){return this.parent.dvsMat3}beforeRender(b){const a=this.element;if(null!=a){var {context:c}=b,{videoWidth:e,videoHeight:d}=a;if(0!==e&&0!==d){if(this.texture)a.paused||this.texture.setData(a);else{const f=new H.TextureDescriptor;f.wrapMode=F.TextureWrapMode.CLAMP_TO_EDGE;f.preMultiplyAlpha=!0;f.width=e;f.height=d;this.texture=new G.Texture(c,f,a)}a.paused||(this.texture.generateMipmap(),this.requestRender());super.beforeRender(b)}}}_createTransforms(){return null}updateDrawCoords(b,
a,c,e){var d=this.element,f=this._getFrameInfo();if(d&&f){this._initializeData(b,f,c);var {controlPoints:g,horizon:h}=f;d=Math.sqrt(g.length);var {x:n,y:r}=b;b=this._vertices;var l=g[0];f=g[d-1];var k=g[(d-1)*d],p=g[(d-1)*d+d-1];d=m.project(h?h[0].mapPoint:l.mapPoint,c);f=m.project(h?h[1].mapPoint:f.mapPoint,c);k=m.project(k.mapPoint,c);p=m.project(p.mapPoint,c);this.clipGeometry=h?new E({geometry:I.fromJSON({rings:[[[k.x,k.y],[p.x,p.y],[f.x,f.y],[d.x,d.y],[k.x,k.y]]],spatialReference:c})}):null;
for(l=0;l<g.length;l++){const {sourcePoint:t,mapPoint:u}=g[l];if(null==t||null==u)continue;const q=m.project(u,c);b[2*l]=q.x-n;b[2*l+1]=q.y-r}if(e){c=Math.min(d.x,f.x,k.x,p.x);b=Math.max(d.x,f.x,k.x,p.x);const {worldWidth:t,xBounds:u}=e,[q,y]=u;c<q&&b>q?a=t:b>y&&c<y&&(a=-t)}this.wrapAroundShift=a;this.isWrapAround=0!==a}}draw(b,a){this.isReady&&this._vertices&&this._indices&&this._texCoords?a.render(b,{transform:{dvs:this.dvsMat3},config:{perspective:this.perspectiveTransform,texSize:this.textureSize,
wrapAroundShift:this.wrapAroundShift,isWrapAround:this.isWrapAround,opacity:this.opacity,texture:{texture:this.texture,unit:0}},position:this._vertices,tex:this._texCoords,index:this._indices}):this.requestRender()}_initializeData(b,a,c){if(null==this._vertices||null==this._indices){var {controlPoints:e}=a;a=Math.sqrt(e.length);var d=new Float32Array(2*e.length),f=new Uint16Array(2*e.length);for(var g=0;g<e.length;g++){const {sourcePoint:h,mapPoint:n}=e[g];if(null==h||null==n)continue;const r=m.project(n,
c);d[2*g]=r.x-b.x;d[2*g+1]=r.y-b.y;f[2*g]=h.x;f[2*g+1]=h.y}b=new Uint16Array(a*a+(a-2)*(a+2));c=0;for(e=0;e<a;e++){for(g=0;g<a;g++)b[c++]=e*a+g,b[c++]=(e+1)*a+g;e<a-2&&(b[c++]=(e+1)*a+(a-1),b[c++]=(e+1)*a)}this._vertices=d;this._texCoords=f;this._indices=b}}_getFrameInfo(){if(!this.groundControlPoints)return null;const b=this._getFrameControlPoints(),a=this.frameHorizonPoints;var c=null;if(a){c=a.endX;const e=a.endY;c=[{sourcePoint:v.createScreenPoint(a.startX,a.startY),mapPoint:new w(a.startLongitude,
a.startLatitude)},{sourcePoint:v.createScreenPoint(c,e),mapPoint:new w(a.endLongitude,a.endLatitude)}]}return{controlPoints:b,horizon:c}}_getFrameControlPoints(){const b=this.groundControlPoints,a=b?.length;if(!a)return[];const c=Array(a);var e=Math.max(...b.map(({x:d})=>d));e=this.element.videoWidth/e;for(let d=0;d<a;d++){const {x:f,y:g,lat:h,lon:n}=b[d];c[d]={sourcePoint:v.createScreenPoint(f*e,-g*e),mapPoint:new w(n,h)}}return c}}return J});