// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.31/esri/copyright.txt for details.
//>>built
define("exports ../../../../../core/maybe ../number ./Buffer ../shaderGraph/techniques/mesh/dataViewUtils ../../../../webgl/enums ../../../../webgl/VertexArrayObject".split(" "),function(q,r,x,t,y,z,u){function A(a,b){const d=a.attributes.filter(c=>b.locations.has(c.name)).map(c=>({name:c.name,type:c.type,count:c.count,divisor:0,normalized:c.normalized??!1,offset:c.offset,stride:a.stride}));return new Map([["geometry",d]])}function B(a,b){const d=[];var c=a.attributes.filter(e=>b.locations.has(e.name));
for(const e of c)d.push({name:e.name,type:e.type,count:e.count,divisor:0,normalized:e.normalized??!1,offset:e.offset,stride:a.stride}),c=b.computeAttributeMap[e.name],null!=c&&2===c.length&&(d.push({name:c[0],count:e.count,divisor:0,type:e.type,normalized:e.normalized??!1,offset:e.offset+a.stride,stride:a.stride}),d.push({name:c[1],count:e.count,divisor:0,type:e.type,normalized:e.normalized??!1,offset:e.offset+2*a.stride,stride:a.stride}));return new Map([["geometry",d]])}class C{constructor(a,b){this._bufferPool=
a;this._layout=b;this._invalidatedCompute=this._invalidatedGeometry=!1;this._position=this._layout.attributes.find(d=>"pos"===d.name||"position"===d.name);if(!this._position)throw Error("InternalError: Unable to find position attribute");}destroy(){this._indexBuffer=r.destroyMaybe(this._indexBuffer);this._vertexBuffer=r.destroyMaybe(this._vertexBuffer);this._computeVAO?.disposeVAOOnly();this._geometryVAO?.disposeVAOOnly()}get layout(){return this._layout}getDrawArgs(a,b,d,c){return c?{primitive:z.PrimitiveType.POINTS,
count:b/3,offset:d/3}:{primitive:a,count:b,offset:d}}getAttributePrecisionPackFactors(){const a={};for(const b of this.layout.attributes)b.packPrecisionFactor&&(a[b.name]=b.packPrecisionFactor);return a}getDebugVertexInfo(a=!1,b){if(!this._vertexBuffer)return null;const d=this._layout,c=d.stride;var e=this._vertexBuffer.getView(0,this._vertexBuffer.byteSize);const l=[];if(a)if(null==b)console.log("must provide location info to see compute attributes");else for(var g of d.attributes){var f=b.computeAttributeMap[g.name];
null!=f&&2===f.length&&(l.push({...g,name:f[0],offset:g.offset+c}),l.push({...g,name:f[1],offset:g.offset+2*c}))}b=new DataView(e.slice().buffer);e=e.byteLength/c;a&&(e=this._indexBuffer.fillPointer/3);g=this._indexBuffer.getView(0,this._indexBuffer.byteSize);f=0;const m=[];for(let h=0;h<e;h++){a&&(f=g[3*h]*c);const v={};for(const k of[...d.attributes,...l]){let w=`${k.offset} ${k.name}`,n=y.unpackDataView(b,k,f);if(k.packPrecisionFactor)if(w+=` (precision: ${k.packPrecisionFactor})`,"number"===typeof n)n/=
k.packPrecisionFactor;else for(let p=0;p<n.length;p++)n[p]/=k.packPrecisionFactor;v[w]=n}f+=c;m.push(v)}return{vertices:m,layout:d}}_ensure(a,b){if(this._vertexBuffer&&this._indexBuffer)this._indexBuffer.ensure(Math.max(a,1E3)),this._vertexBuffer.ensure(Math.max(b,1E3));else{const d=this._layout.stride/Uint32Array.BYTES_PER_ELEMENT;this._indexBuffer=new t.MappedBuffer("index",Math.max(a,1E3),1,this._bufferPool);this._vertexBuffer=new t.MappedBuffer("vertex",Math.max(b,1E3),d,this._bufferPool)}}append(a){var b=
a.layout.stride;this._ensure(a.indices.byteLength/Uint32Array.BYTES_PER_ELEMENT,a.vertices.byteLength/b);const {vertices:d,indices:c}=a;a=this._vertexBuffer.insert(d,0,d.byteLength/b,0);b=this._indexBuffer.insert(c,0,c.byteLength/4,a);return{vertexFrom:a,indexFrom:b}}copyRecordFrom(a,b,d,c){const {indexStart:e,indexCount:l,vertexStart:g,vertexCount:f}=b;this._ensure(l,f);const m=a._position;var h=m.offset;d=x.i1616to32(d*(m.packPrecisionFactor??1),c*(m.packPrecisionFactor??1));h=this._vertexBuffer.copyFrom(a._vertexBuffer,
g,f,d,h);a=this._indexBuffer.copyFrom(a._indexBuffer,e,l,h-g,0);b=b.clone();b.vertexStart=h;b.indexStart=a;b.overlaps=0;return b}remove(a,b,d,c){this._indexBuffer.free(a,b);this._vertexBuffer.free(d,c)}upload(){this._invalidatedCompute=this._invalidatedGeometry=!0}getGeometryVAO(a,b){if(!this._vertexBuffer||!this._indexBuffer||!this._vertexBuffer.bufferSize)return null;if(this._invalidatedGeometry){if(this._vertexBuffer.invalidated||this._indexBuffer.invalidated)this._vertexBuffer.invalidate(),this._indexBuffer.invalidate(),
this._geometryVAO?.disposeVAOOnly(),this._geometryVAO=null;this._vertexBuffer.upload();this._indexBuffer.upload();const d=this._indexBuffer.getGPUBuffer(a,!1),c=this._vertexBuffer.getGPUBuffer(a);this._geometryVAO||(this._geometryVAO=new u.VertexArrayObject(a,b.locations,A(this.layout,b),new Map([["geometry",c]]),d));this._invalidatedGeometry=!1}return this._geometryVAO}getComputeVAO(a,b){if(!this._vertexBuffer||!this._indexBuffer||!this._vertexBuffer.bufferSize)return null;if(this._invalidatedCompute){if(this._vertexBuffer.invalidated||
this._indexBuffer.invalidatedComputeBuffer)this._vertexBuffer.invalidate(),this._indexBuffer.invalidate(),this._computeVAO?.disposeVAOOnly(),this._computeVAO=null;this._vertexBuffer.upload();this._indexBuffer.upload();const d=this._indexBuffer.getGPUBuffer(a,!0),c=this._vertexBuffer.getGPUBuffer(a);this._computeVAO||(this._computeVAO=new u.VertexArrayObject(a,b.locations,B(this.layout,b),new Map([["geometry",c]]),d),this._invalidatedCompute=!1)}return this._computeVAO}get memoryStats(){return{bytesUsed:this._vertexBuffer.memoryStats.bytesUsed+
this._indexBuffer.memoryStats.bytesUsed,bytesReserved:this._vertexBuffer.memoryStats.bytesReserved+this._indexBuffer.memoryStats.bytesReserved,vertex:this._vertexBuffer.memoryStats,index:this._indexBuffer.memoryStats}}reshuffle(a){this._vertexBuffer&&this._vertexBuffer.reshuffle(a.vertex.count,a.vertex.operations);this._indexBuffer&&this._indexBuffer.reshuffle(a.index.count,a.index.operations)}}q.MappedMesh=C;Object.defineProperty(q,Symbol.toStringTag,{value:"Module"})});