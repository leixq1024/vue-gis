// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.31/esri/copyright.txt for details.
//>>built
define("exports ../../../../../../../core/arrayUtils ../../../../../../../core/Error ../../../../../../../core/lang ../../../../../../../core/Logger ../../../grouping ../../../animations/infos ../../../animations/utils ./utils ../../../../../layers/features/support/DictionaryValue".split(" "),function(z,w,E,F,G,H,I,u,J,K){async function x(a,f,e=!1){const {defaultValue:b,valueExpressionInfo:l,value:h}=f;if(l){const {expression:g}=l;return(a=await a.createComputedField({expression:g},e))?{...f,computed:a,
defaultValue:b}:null}return{...f,computed:new K.DictionaryValue(h),defaultValue:b}}async function B(a,f){var {valueExpressionInfo:e}=f;({expression:e}=e);return(a=await a.createComputedField({expression:e}))?{...f,computed:a}:null}function A(a){return"object"!==typeof a||null==a?!1:"valueExpressionInfo"in a&&a.valueExpressionInfo||"type"in a&&"Process"===a.type&&"op"in a&&"Random"===a.op?!0:!1}function y(a){if(Array.isArray(a))for(const f of a)if(y(f))return!0;if("object"===typeof a){if(A(a))return!0;
for(const f in a)if(y(a[f]))return!0}return!1}class C{static async create(a,f,e){const b={},l=new Map,h=new Map,g=new Map,m=new Map,p=new Map,q=new Map;for(const k in e){const c=e[k];if(null==c||"object"!==typeof c)b[k]=c;else if(Array.isArray(c)){if("object"===typeof c[0])throw Error(`InternalError: Cannot handle ${k}. Nested array params are not supported`);b[k]=c}else if("valueExpressionInfo"in c)if(c.value)b[k]=c.value;else{var d=await B(a,c);d?(l.set(k,d),b[k]=null):b[k]=c.defaultValue}else switch(c.type){case "cim-effect-infos":if(c.effectInfos.some(n=>
n.overrides.length)){h.set(k,{effects:await Promise.all(c.effectInfos.map(async n=>{const t=n.overrides.map(r=>x(a,r));return{effect:n.effect,compiledOverrides:(await Promise.all(t)).filter(w.isSome)}}))});break}b[k]=c.effectInfos.map(n=>n.effect);break;case "cim-marker-placement-param":c.overrides.length&&g.set(k,{placementInfo:c,compiledOverrides:(await Promise.all(c.overrides.map(n=>x(a,n)))).filter(w.isSome)});b[k]=c.placement;break;case "text-rasterization-param":if(c.overrides.length){d=c.overrides.map(n=>
x(a,n,c.useLegacyLabelEvaluationRules));m.set(k,{compiledOverrides:(await Promise.all(d)).filter(w.isSome),rasterizationParam:c,objectIdToResourceId:new Map});continue}b[k]=await f.fetchResourceImmediate({type:"cim-rasterization-info",resource:c.resource})??null;break;case "sprite-rasterization-param":if(c.overrides.length){d=c.overrides.map(n=>x(a,n));m.set(k,{compiledOverrides:(await Promise.all(d)).filter(w.isSome),rasterizationParam:c,objectIdToResourceId:new Map});continue}if("animated"===c.resource.type){m.set(k,
{compiledOverrides:[],rasterizationParam:c,objectIdToResourceId:new Map});continue}b[k]=await f.fetchResourceImmediate({type:"cim-rasterization-info",resource:c.resource})??null;break;case "cim-marker-transform-param":({params:d}=c);if(y(d)){const n={compiledMarkerInfos:[]};await Promise.all(d.map(async t=>{const r={props:{}};for(const v in t)if(A(t[v])){const D=await B(a,t[v]);r.compiledExpressionMap||(r.compiledExpressionMap=new Map);const L=r.compiledExpressionMap;D&&L.set(v,D)}else r.props[v]=
t[v];n.compiledMarkerInfos.push(r)}));p.set(k,n)}else b[k]={type:"cim-marker-transform-info",infos:d};break;case "animation-params":({params:d}=c);d=u.createParamList(d);y(d)?(d=await Promise.all(d.map(n=>u.compileAnimationParam(n,a))),q.set(k,{params:d,propertyIdToResourceId:new Map,key:k})):(d=u.fromJSON(d),d=await f.fetchResourceImmediate({type:"animation-info",resource:d}),null!=d&&"sprite"===d.type&&(b[k]={dataRow:d.rect.y,dataColumn:d.rect.x}));break;default:b[k]=c}}return new C(e,b,l,h,g,m,
p,q)}constructor(a,f,e,b,l,h,g,m){this.inputMeshParams=a;this._resolvedMeshParams=f;this._dynamicProperties=e;this._dynamicEffectProperties=b;this._dynamicPlacementProperties=l;this._dynamicAsyncProperties=h;this._dynamicTransformProperties=g;this._dynamicAsyncAnimations=m;this.evaluator=p=>p}get hasDynamicProperties(){return!!(this._dynamicProperties.size||this._dynamicAsyncProperties.size||this._dynamicEffectProperties.size||this._dynamicTransformProperties.size||this._dynamicPlacementProperties.size||
this._dynamicAsyncAnimations.size)}get evaluatedMeshParams(){this._evaluatedMeshParams||(this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams));return this._evaluatedMeshParams}enqueueRequest(a,f,e){for(var b of this._dynamicAsyncProperties.values()){var l=F.clone(b.rasterizationParam.resource);"animated"===b.rasterizationParam.resource.type&&b.rasterizationParam.resource.randomizeStartTime&&(l.primitiveName="__RESERVED__PRIMITIVE__NAME__",l.startGroup=H.getStartGroup(f.getObjectId()||
0));for(const {primitiveName:h,propertyName:g,computed:m,defaultValue:p,valueExpressionInfo:q}of b.compiledOverrides)try{J.applyComputedValue(l,"animated"===b.rasterizationParam.resource.type?l.primitiveName:h,g,m,f,e,p)}catch(d){G.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.mesh.MeshWriterInputEvaluator").errorOnce(new E("invalid-arcade-expression",`Encountered an error when evaluating the arcade expression '${q?.expression}' (primitive: '${h}', property: '${g}')`,d))}l=a.enqueueRequest({type:"cim-rasterization-info",
resource:l});b.objectIdToResourceId.set(f.getObjectId(),l)}for(const h of this._dynamicAsyncAnimations.values())b=h.params.map(g=>u.resolveToAnimationInfo(g,f,e)).map(I.hydrate).map(g=>g.simplify()),b=u.encodeParamList(b),b=a.enqueueRequest({type:"animation-info",resource:b}),h.propertyIdToResourceId.set(f.getObjectId()+"."+h.key,b)}evaluateMeshParams(a,f,e){for(const [h,g]of this._dynamicProperties.entries())this._resolvedMeshParams[h]=g.computed.readWithDefault(f,e,g.defaultValue);for(const [h,
g]of this._dynamicPlacementProperties.entries())for(const {computed:m,defaultValue:p,propertyName:q}of g.compiledOverrides){var b=m.readWithDefault(f,e,p);g.placementInfo.placement[q]=b;this._resolvedMeshParams[h]=g.placementInfo.placement}for(const [h,g]of this._dynamicEffectProperties.entries())for(var l of g.effects){for(const {computed:m,defaultValue:p,propertyName:q}of l.compiledOverrides)b=m.readWithDefault(f,e,p),l.effect[q]=b;this._resolvedMeshParams[h]=g.effects.map(m=>m.effect)}for(const [h,
g]of this._dynamicTransformProperties.entries()){l={type:"cim-marker-transform-info",infos:[]};for(const m of g.compiledMarkerInfos){b={...m.props};if(m.compiledExpressionMap)for(const [p,q]of m.compiledExpressionMap){const d=q.computed.readWithDefault(f,e,q.defaultValue);b[p]="number"===typeof d||"boolean"===typeof d?d:q.defaultValue}l.infos.push(b)}this._resolvedMeshParams[h]=l}for(const [h,g]of this._dynamicAsyncProperties.entries())e=g.objectIdToResourceId.get(f.getObjectId()),null!=e&&(e=a.getResource(e),
this._resolvedMeshParams[h]=e);for(const [h,g]of this._dynamicAsyncAnimations.entries())e=g.propertyIdToResourceId.get(f.getObjectId()+"."+h),null!=e&&(e=a.getResource(e),this._resolvedMeshParams[h]={dataRow:e.rect.y,dataColumn:e.rect.x});this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams);return this.evaluatedMeshParams}}z.MeshWriterInputEvaluator=C;z.hasExpression=A;Object.defineProperty(z,Symbol.toStringTag,{value:"Module"})});