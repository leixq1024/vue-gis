// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.31/esri/copyright.txt for details.
//>>built
define("exports ../../../../core/mathUtils ../../../../core/libs/gl-matrix-2/math/mat3 ../../../../core/libs/gl-matrix-2/factories/mat3f64 ../../../../core/libs/gl-matrix-2/math/mat4 ../../../../core/libs/gl-matrix-2/factories/mat4f64 ../../../../core/libs/gl-matrix-2/math/vec2 ../../../../core/libs/gl-matrix-2/factories/vec2f64 ../../../../chunks/vec32 ../../../../core/libs/gl-matrix-2/factories/vec3f64 ../../../../core/libs/gl-matrix-2/factories/vec4f64 ../../../../core/libs/gl-matrix-2/types/mat4 ../../../../geometry/support/aaBoundingRect ../../../../geometry/support/buffer/BufferView ../../layers/support/FastSymbolUpdates ../../support/debugFlags ../../support/buffer/InterleavedLayout ../core/shaderLibrary/ShaderOutput ../core/shaderLibrary/hud/HUD.glsl ../core/shaderLibrary/util/AlphaCutoff ../effects/geometry/olidUtils ../lib/GLTextureMaterial ../lib/Material ../lib/RenderSlot ../lib/screenSizePerspectiveUtils ../lib/Util ../lib/VertexAttribute ./ScaleInfo ./internal/bufferWriterUtils ./internal/MaterialUtil ../../../../chunks/HUDMaterial.glsl ../shaders/HUDMaterialTechnique ../shaders/HUDMaterialTechniqueConfiguration".split(" "),
function(O,Y,Z,aa,na,oa,ba,P,h,D,I,pa,qa,ra,sa,ta,ua,M,va,Q,wa,ca,da,F,N,xa,k,ya,C,za,ea,Aa,Ba){function fa(a,b,c,e){pa.isMat4(b)&&(b=Z.fromMat4(Ca,b));h.transformMat3(e.normal,a,b);h.transformMat4(e.normal,e.normal,c.viewInverseTransposeMatrix);e.cosAngle=h.dot(ha,Da);return e}function ia(a,b,c,e,d,g,m,n,p){let q=b-d-e[0]*p[0],f=q+e[0]+2*d;p=c-d-e[1]*p[1];d=p+e[1]+2*d;const y=n.distanceFieldBoundingBox;n.textureIsSignedDistanceField&&null!=y&&(q+=e[0]*y[0],p+=e[1]*y[1],f-=e[0]*(1-y[2]),d-=e[1]*(1-
y[3]),q-=g,f+=g,p-=g,d+=g);ba.set(ja,b,c);ba.rotate(J,a,ja,Y.deg2rad(m));return J[0]>q&&J[0]<f&&J[1]>p&&J[1]<d}class Ea extends da.Material{constructor(a,b){super(a,ka);this.produces=new Map([[F.RenderSlot.HUD_MATERIAL,c=>M.isColorHighlightOrOID(c)&&!this.parameters.drawInSecondSlot],[F.RenderSlot.LABEL_MATERIAL,c=>M.isColorHighlightOrOID(c)&&this.parameters.drawInSecondSlot],[F.RenderSlot.OCCLUSION_PIXELS,()=>this.parameters.occlusionTest],[F.RenderSlot.DRAPED_MATERIAL,c=>this.parameters.draped&&
M.isColorHighlightOrOID(c)]]);this._visible=!0;this._configuration=new Ba.HUDMaterialTechniqueConfiguration(b)}getConfiguration(a,b){this._configuration.output=a;this._configuration.hasSlicePlane=this.parameters.hasSlicePlane;this._configuration.hasVerticalOffset=!!this.parameters.verticalOffset;this._configuration.hasScreenSizePerspective=!!this.parameters.screenSizePerspective;this._configuration.screenCenterOffsetUnitsEnabled="screen"===this.parameters.centerOffsetUnits;this._configuration.hasPolygonOffset=
this.parameters.polygonOffset;this._configuration.draped=this.parameters.draped;this._configuration.occlusionTestEnabled=this.parameters.occlusionTest;this._configuration.pixelSnappingEnabled=this.parameters.pixelSnappingEnabled;this._configuration.signedDistanceFieldEnabled=this.parameters.textureIsSignedDistanceField;this._configuration.sampleSignedDistanceFieldTexelCenter=this.parameters.sampleSignedDistanceFieldTexelCenter;this._configuration.hasRotation=this.parameters.hasRotation;this._configuration.vvSize=
!!this.parameters.vvSize;this._configuration.vvColor=!!this.parameters.vvColor;this._configuration.occlusionPass=b.slot===F.RenderSlot.OCCLUSION_PIXELS;this._configuration.occludedFragmentFade=this.parameters.occludedFragmentFade;this._configuration.horizonCullingEnabled=this.parameters.horizonCullingEnabled;this._configuration.depthTestEnabled=this.parameters.depthEnabled||b.slot===F.RenderSlot.OCCLUSION_PIXELS;a===M.ShaderOutput.Color&&(this._configuration.debugDrawLabelBorder=!!ta.debugFlags.LABELS_SHOW_BORDER);
this._configuration.oitPass=b.oitPass;this._configuration.terrainDepthTest=b.terrainDepthTest;this._configuration.cullAboveTerrain=b.cullAboveTerrain;return this._configuration}intersect(a,b,c,e,d,g){const {options:{selectionMode:m,hud:n,excludeLabels:p},point:q,camera:f}=c;({parameters:e}=this);if(m&&n&&(!p||!e.isLabel)&&a.visible&&q){var {scaleX:y,scaleY:B}=this._getScreenScale(a,f.pixelRatio);Z.fromMat4(R,b);if(a.attributes.has(k.VertexAttribute.FEATUREATTRIBUTE)){d=R;var v=d[0],w=d[1],E=d[2],
K=d[3],G=d[4],z=d[5],l=d[6],A=d[7],H=d[8];const S=1/Math.sqrt(v*v+w*w+E*E),T=1/Math.sqrt(K*K+G*G+z*z),U=1/Math.sqrt(l*l+A*A+H*H);d[0]=v*S;d[1]=w*S;d[2]=E*S;d[3]=K*T;d[4]=G*T;d[5]=z*T;d[6]=l*U;d[7]=A*U;d[8]=H*U}d=a.attributes.get(k.VertexAttribute.POSITION);v=a.attributes.get(k.VertexAttribute.SIZE);w=a.attributes.get(k.VertexAttribute.NORMAL);E=a.attributes.get(k.VertexAttribute.ROTATION);a=a.attributes.get(k.VertexAttribute.CENTEROFFSETANDDISTANCE);xa.assert(3<=d.size);K=ea.calculateAnchorPosForRendering(e);
G="screen"===this.parameters.centerOffsetUnits;for(z=0;z<d.data.length/d.size;z++)l=z*d.size,h.set(t,d.data[l],d.data[l+1],d.data[l+2]),h.transformMat4(t,t,b),h.transformMat4(t,t,f.viewMatrix),l=z*a.size,h.set(x,a.data[l],a.data[l+1],a.data[l+2]),G||(t[0]+=x[0],t[1]+=x[1],0!==x[2]&&(l=x[2],h.normalize(x,t),h.subtract(t,t,h.scale(x,x,l)))),l=z*w.size,h.set(L,w.data[l],w.data[l+1],w.data[l+2]),fa(L,R,f,V),this._applyVerticalOffsetTransformationView(t,V,f,W),f.applyProjection(t,r),-1<r[0]&&(G&&(x[0]||
x[1])&&(r[0]+=x[0]*f.pixelRatio,0!==x[1]&&(r[1]+=N.applyScaleFactor(x[1],W.factorAlignment)*f.pixelRatio),f.unapplyProjection(r,t)),r[0]+=this.parameters.screenOffset[0]*f.pixelRatio,r[1]+=this.parameters.screenOffset[1]*f.pixelRatio,r[0]=Math.floor(r[0]),r[1]=Math.floor(r[1]),l=z*v.size,u[0]=v.data[l],u[1]=v.data[l+1],N.applyPrecomputedScaleFactor(u,W.factor,u),l=1*f.pixelRatio,A=0,e.textureIsSignedDistanceField&&(A=Math.min(e.outlineSize,.5*u[0])*f.pixelRatio/2),u[0]*=y,u[1]*=B,ia(q,r[0],r[1],u,
l,A,e.rotation+E.data[z*E.size],e,K)&&(A=c.ray,h.transformMat4(la,t,na.invert(Fa,f.viewMatrix)),r[0]=q[0],r[1]=q[1],f.unprojectFromRenderScreen(r,t)&&(l=D.create(),h.copy(l,A.direction),H=1/h.length(l),h.scale(l,l,H),A=h.distance(A.origin,t)*H,g(A,l,-1,!0,1,la))))}}intersectDraped(a,b,c,e,d,g){b=a.attributes.get(k.VertexAttribute.POSITION);c=a.attributes.get(k.VertexAttribute.SIZE);const m=a.attributes.get(k.VertexAttribute.ROTATION),n=this.parameters,p=ea.calculateAnchorPosForRendering(n),{scaleX:q,
scaleY:f}=this._getScreenScale(a,a.screenToWorldRatio),y=2*a.screenToWorldRatio;for(let w=0;w<b.data.length/b.size;w++){var B=w*b.size;const E=b.data[B];B=b.data[B+1];var v=w*c.size;u[0]=c.data[v];u[1]=c.data[v+1];v=0;n.textureIsSignedDistanceField&&(v=Math.min(n.outlineSize,.5*u[0])*a.screenToWorldRatio/2);u[0]*=q;u[1]*=f;ia(e,E,B,u,y,v,n.rotation+m.data[w*m.size],n,p)&&d(g.dist,g.normal,-1,!1)}}createBufferWriter(){return new Ga}_updateScaleInfo(a,b,c){const e=this.parameters;null!=e.screenSizePerspective?
N.precomputeScaleFactor(c,b,e.screenSizePerspective,a.factor):(a.factor.scale=1,a.factor.factor=0,a.factor.minScaleFactor=0);null!=e.screenSizePerspectiveAlignment?N.precomputeScaleFactor(c,b,e.screenSizePerspectiveAlignment,a.factorAlignment):(a.factorAlignment.factor=a.factor.factor,a.factorAlignment.scale=a.factor.scale,a.factorAlignment.minScaleFactor=a.factor.minScaleFactor)}applyShaderOffsetsView(a,b,c,e,d,g,m){b=fa(b,c,d,V);this._applyVerticalGroundOffsetView(a,b,d,m);this._applyVerticalOffsetTransformationView(m,
b,d,g);this._applyPolygonOffsetView(m,b,e[3],d,m);this._applyCenterOffsetView(m,e,m);return m}applyShaderOffsetsNDC(a,b,c,e,d){this._applyCenterOffsetNDC(a,b,c,e);null!=d&&h.copy(d,e);this._applyPolygonOffsetNDC(e,b,c,e);return e}_applyPolygonOffsetView(a,b,c,e,d){var g=e.aboveGround?1:-1;c=Math.sign(c);0===c&&(c=g);g*=c;if(0>=this.parameters.shaderPolygonOffset)return h.copy(d,a);b=Y.clamp(Math.abs(b.cosAngle),.01,1);e=1-Math.sqrt(1-b*b)/b/e.viewport[2];0<g?h.scale(d,a,e):h.scale(d,a,1/e);return d}_applyVerticalGroundOffsetView(a,
b,c,e){const d=h.length(a),g=c.aboveGround?1:-1;c=c.computeRenderPixelSizeAtDist(d)*va.HUDVerticalPixelOffset;b=h.scale(t,b.normal,g*c);h.add(e,a,b);return e}_applyVerticalOffsetTransformationView(a,b,c,e){const d=this.parameters;if(!d.verticalOffset?.screenLength){if(d.screenSizePerspective||d.screenSizePerspectiveAlignment){var g=h.length(a);this._updateScaleInfo(e,g,b.cosAngle)}else e.factor.scale=1,e.factorAlignment.scale=1;return a}g=h.length(a);c=za.verticalOffsetAtDistance(c,g,d.verticalOffset,
b.cosAngle,d.screenSizePerspectiveAlignment??d.screenSizePerspective);this._updateScaleInfo(e,g,b.cosAngle);h.scale(b.normal,b.normal,c);return h.add(a,a,b.normal)}_applyCenterOffsetView(a,b,c){const e="screen"!==this.parameters.centerOffsetUnits;c!==a&&h.copy(c,a);e&&(c[0]+=b[0],c[1]+=b[1],b[2]&&(h.normalize(L,c),h.add(c,c,h.scale(L,L,b[2]))));return c}_applyCenterOffsetNDC(a,b,c,e){const d="screen"!==this.parameters.centerOffsetUnits;e!==a&&h.copy(e,a);d||(e[0]+=b[0]/c.fullWidth*2,e[1]+=b[1]/c.fullHeight*
2);return e}_applyPolygonOffsetNDC(a,b,c,e){const d=this.parameters.shaderPolygonOffset;a!==e&&h.copy(e,a);d&&(a=c.aboveGround?1:-1,e[2]-=(a*Math.sign(b[3])||a)*d);return e}set visible(a){this._visible=a}get visible(){const {color:a,outlineSize:b,outlineColor:c}=this.parameters,e=a[3]>=Q.alphaCutoff||b>=Q.alphaCutoff&&c[3]>=Q.alphaCutoff;return this._visible&&e}createGLMaterial(a){return new Ha(a)}calculateRelativeScreenBounds(a,b,c=qa.create()){var e=this.parameters;c[0]=e.anchorPosition[0]*-a[0]+
e.screenOffset[0]*b;c[1]=e.anchorPosition[1]*-a[1]+e.screenOffset[1]*b;c[2]=c[0]+a[0];c[3]=c[1]+a[1];return c}_getScreenScale(a,b){a=a.attributes.get(k.VertexAttribute.FEATUREATTRIBUTE);if(null==a)return{scaleX:b,scaleY:b};a=I.fromArray(a.data,Ia);sa.evaluateModelTransformScale(X,this.parameters,a);return{scaleX:X[0]*b,scaleY:X[1]*b}}}class Ha extends ca.GLTextureMaterial{constructor(a){super({...a,...a.material.parameters})}beginSlot(a){this.updateTexture(this._material.parameters.textureId);this._material.setParameters(this.textureBindParameters);
return this.acquireTechnique(Aa.HUDMaterialTechnique,a)}}const W=new ya.ScaleInfo,t=D.create(),L=D.create(),r=I.create(),ha=D.create(),la=D.create(),J=P.create(),ja=P.create(),R=aa.create(),Ca=aa.create(),Fa=oa.create(),x=D.create(),X=D.create(),Ia=I.create(),V={normal:ha,cosAngle:0},u=[0,0],Da=D.fromValues(0,0,1);class ka extends ca.GLTextureMaterialBindParameters{constructor(){super(...arguments);this.renderOccluded=da.RenderOccludedFlag.Occlude;this.isDecoration=!1;this.color=I.freeze(1,1,1,1);
this.polygonOffset=!1;this.anchorPosition=P.fromValues(.5,.5);this.screenOffset=[0,0];this.shaderPolygonOffset=1E-5;this.sampleSignedDistanceFieldTexelCenter=this.textureIsSignedDistanceField=!1;this.outlineColor=I.freeze(1,1,1,1);this.rotation=this.outlineSize=0;this.vvSizeEnabled=this.hasRotation=!1;this.vvSymbolRotationMatrix=this.vvSymbolAnchor=this.vvOpacity=this.vvColor=this.vvSize=null;this.hasSlicePlane=!1;this.occlusionTest=this.pixelSnappingEnabled=!0;this.horizonCullingEnabled=this.occludedFragmentFade=
!1;this.centerOffsetUnits="world";this.drawInSecondSlot=!1;this.depthEnabled=!0;this.isLabel=this.draped=!1}}const ma=ua.newLayout().vec3f(k.VertexAttribute.POSITION).vec3f(k.VertexAttribute.NORMAL).vec2f(k.VertexAttribute.UV0).vec4u8(k.VertexAttribute.COLOR).vec2f(k.VertexAttribute.SIZE).f32(k.VertexAttribute.ROTATION).vec4f(k.VertexAttribute.CENTEROFFSETANDDISTANCE).vec4f(k.VertexAttribute.FEATUREATTRIBUTE),Ja=ma.clone().vec4u8(k.VertexAttribute.OBJECTANDLAYERIDCOLOR);class Ga{constructor(){this.vertexBufferLayout=
wa.olidEnabled()?Ja:ma}elementCount(a){return 6*a.get(k.VertexAttribute.POSITION).indices.length}write(a,b,c,e,d,g){C.writePosition(c.get(k.VertexAttribute.POSITION),a,d.position,g,6);C.writeNormal(c.get(k.VertexAttribute.NORMAL),b,d.normal,g,6);a=c.get(k.VertexAttribute.UV0)?.data;var m=0,n=0,p=1,q=1;a&&4<=a.length&&(m=a[0],n=a[1],p=a[2],q=a[3]);p=Math.min(1.99999,p+1);q=Math.min(1.99999,q+1);a=c.get(k.VertexAttribute.POSITION).indices.length;b=g;var f=d.uv0;for(let v=0;v<a;++v)f.set(b,0,m),f.set(b,
1,n),b++,f.set(b,0,p),f.set(b,1,n),b++,f.set(b,0,p),f.set(b,1,q),b++,f.set(b,0,p),f.set(b,1,q),b++,f.set(b,0,m),f.set(b,1,q),b++,f.set(b,0,m),f.set(b,1,n),b++;C.writeColor(c.get(k.VertexAttribute.COLOR),4,d.color,g,6);const {data:y,indices:B}=c.get(k.VertexAttribute.SIZE);a=B.length;m=d.size;b=g;for(n=0;n<a;++n)for(p=y[2*B[n]],q=y[2*B[n]+1],f=0;6>f;++f)m.set(b,0,p),m.set(b,1,q),b++;C.writeBufferFloat(c.get(k.VertexAttribute.ROTATION),d.rotation,g,6);c.get(k.VertexAttribute.CENTEROFFSETANDDISTANCE)?
C.writeBufferVec4(c.get(k.VertexAttribute.CENTEROFFSETANDDISTANCE),d.centerOffsetAndDistance,g,6):C.writeBufferVec4Zeros(d.centerOffsetAndDistance,g,6*a);c.get(k.VertexAttribute.FEATUREATTRIBUTE)?C.writeBufferVec4(c.get(k.VertexAttribute.FEATUREATTRIBUTE),d.featureAttribute,g,6):C.writeBufferVec4Zeros(d.featureAttribute,g,6*a);null!=e&&(c=c.get(k.VertexAttribute.POSITION)?.indices)&&(c=c.length,d=d.getField(k.VertexAttribute.OBJECTANDLAYERIDCOLOR,ra.BufferViewVec4u8),C.writeObjectAndLayerIdColor(e,
d,c,g,6))}}O.HUDMaterial=Ea;O.Parameters=ka;Object.defineProperty(O,Symbol.toStringTag,{value:"Module"})});