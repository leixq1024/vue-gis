// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.31/esri/copyright.txt for details.
//>>built
define("exports ../../../../chunks/vec32 ../../../../core/libs/gl-matrix-2/factories/vec3f64 ../../../../core/libs/gl-matrix-2/factories/vec4f64 ../../support/buffer/InterleavedLayout ../core/shaderLibrary/ShaderOutput ../core/shaderLibrary/util/AlphaCutoff ../lib/GLMaterial ../lib/Material ../lib/RenderSlot ../lib/VertexAttribute ../shaders/MeasurementArrowTechnique ../shaders/MeasurementArrowTechniqueConfiguration".split(" "),function(x,c,m,y,K,B,z,L,C,D,f,E,M){class N extends C.Material{constructor(a){super(a,
F);this._configuration=new M.MeasurementArrowTechniqueConfiguration;this.vertexAttributeLocations=E.vertexAttributeLocations;this.produces=new Map([[D.RenderSlot.OPAQUE_MATERIAL,b=>!this._transparent&&b===B.ShaderOutput.Color],[D.RenderSlot.TRANSPARENT_MATERIAL_WITHOUT_DEPTH,b=>this._transparent&&b===B.ShaderOutput.Color]])}getConfiguration(a,b){this._configuration.polygonOffsetEnabled=this.parameters.polygonOffset;this._configuration.transparent=this._transparent;this._configuration.oitPass=b.oitPass;
return this._configuration}get visible(){const {outlineColor:a,stripeEvenColor:b,stripeOddColor:e}=this.parameters;return a[3]>=z.alphaCutoff||b[3]>=z.alphaCutoff||e[3]>=z.alphaCutoff}intersect(){}createGLMaterial(a){return new O(a)}createBufferWriter(){return new P}get _transparent(){const {parameters:a}=this;return 1>a.outlineColor[3]||1>a.stripeEvenColor[3]||1>a.stripeOddColor[3]}}class O extends L{beginSlot(a){return this.acquireTechnique(E.MeasurementArrowTechnique,a)}}class F extends C.MaterialParameters{constructor(){super(...arguments);
this.width=32;this.outlineSize=.2;this.outlineColor=y.fromValues(1,.5,0,1);this.stripeEvenColor=y.fromValues(1,1,1,1);this.stripeOddColor=y.fromValues(1,.5,0,1);this.stripeLength=1;this.polygonOffset=!1}}const Q=K.newLayout().vec3f(f.VertexAttribute.POSITION).vec3f(f.VertexAttribute.NORMAL).vec2f(f.VertexAttribute.UV0).f32(f.VertexAttribute.LENGTH),g=m.create(),n=m.create(),r=m.create(),h=m.create(),t=m.create();class P{constructor(){this.vertexBufferLayout=Q}elementCount(a){return 2*(a.get(f.VertexAttribute.POSITION).indices.length/
2+1)}write(a,b,e,p,u,G){const {data:k,indices:H}=e.get(f.VertexAttribute.POSITION),A=e.get(f.VertexAttribute.NORMAL).data;e=k.length/3;H&&H.length!==2*(e-1)&&console.warn("MeasurementArrowMaterial does not support indices");const I=u.position,J=u.normal,v=u.uv0;p=0;for(let l=0;l<e;++l){var d=3*l;c.set(g,k[d],k[d+1],k[d+2]);l<e-1&&(d=3*(l+1),c.set(n,k[d],k[d+1],k[d+2]),c.set(t,A[d],A[d+1],A[d+2]),c.normalize(t,t),c.subtract(r,n,g),c.normalize(r,r),c.cross(h,t,r),c.normalize(h,h));d=c.distance(g,n);
a&&b&&(c.transformMat4(g,g,a),c.transformMat4(n,n,a),c.transformMat4(h,h,b));const q=G+2*l,w=q+1;I.setVec(q,g);I.setVec(w,g);J.setVec(q,h);J.setVec(w,h);v.set(q,0,p);v.set(q,1,-1);v.set(w,0,p);v.set(w,1,1);l<e-1&&(p+=d)}a=u.length;for(b=0;b<2*e;++b)a.set(G+b,p)}}x.MeasurementArrowMaterial=N;x.Parameters=F;Object.defineProperty(x,Symbol.toStringTag,{value:"Module"})});