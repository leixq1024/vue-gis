// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.31/esri/copyright.txt for details.
//>>built
define("exports ../../../../../chunks/tslib.es6 ../../../../../core/accessorSupport/decorators/property ../../../../../core/has ../../../../../core/Logger ../../../../../core/RandomLCG ../../../../../core/accessorSupport/decorators/subclass ../../../../../core/libs/gl-matrix-2/factories/vec4f64 ../../../webgl/formats ../../../webgl/RenderNode ../../core/shaderLibrary/util/AlphaCutoff ../../core/shaderModules/interfaces ../../lib/DefaultVertexAttributeLocations ../../../../webgl/enums".split(" "),
function(h,q,t,F,G,H,z,A,w,B,C,p,D,g){h.RenderNodeVisualizerNode=class extends B{constructor(a){super(a);this.destroyedCB=null;this.produces="final-color";this.consumes={required:["final-color"]};this.clearColor=A.ZEROS;this._focusedFBOType=0;this._program=new Map}destroy(){this._program.forEach(a=>a.dispose());this._program.clear();this.destroyedCB()}render(a){a=a.find(({name:k})=>"final-color"===k);if(!this._focusedFBO)return a;const b=this.renderingContext;b.bindFramebuffer(a.fbo);b.setClearColor(0,
0,0,0);b.clear(g.FramebufferBit.COLOR);const e=this._ensureShader(b,!1,0);b.useProgram(e);b.bindTexture(this._focusedFBO.getTexture(),0);e.setUniform1i("colorTex",0);e.setUniform1i("inputType",this._focusedFBOType);3===this._focusedFBOType&&e.setUniform2fv("nearFar",this.camera.nearFar);b.screen.draw();return a}getDownscaledFBO(a,b,e,k,c,l){e===h.FocusState.ON&&(c=a.width,l=a.height);const d=this.renderingContext;var f=a.depthStencilTexture;const m=this._ensureShader(d,null!=f,b),r=this.fboCache.acquire(c,
l,"fbo visualizer"),x=!a.colorTexture?.descriptor.hasMipmap;x&&a.colorTexture?.generateMipmap();d.useProgram(m);d.bindFramebuffer(r.fbo);let n=0;const u=[g.ColorAttachment.COLOR_ATTACHMENT0],E=null!=f;d.bindTexture(a.colorTexture,n);m.setUniform1i("colorTex",n);f&&(n++,d.bindTexture(f,n),m.setUniform1i("depthTex",n),f=g.ColorAttachment.COLOR_ATTACHMENT0+n,r.acquireColor(f,w.ColorFormat.RGBA,"depth to color"),u.push(f));for(f=0;f<b;f++){n++;const v=g.ColorAttachment.COLOR_ATTACHMENT0+n,y=E?1:0;d.bindTexture(a.getColorTexture(v-
y),n);m.setUniform1i(`colorTex${n-y-1}`,n);r.acquireColor(v,w.ColorFormat.RGBA);u.push(v)}d.gl.drawBuffers(u);b=d.getViewport();d.setViewport(0,0,c,l);d.setClearColor(0,0,0,0);d.clear(g.FramebufferBit.COLOR);d.setBlendingEnabled(!0);d.setBlendFunction(g.BlendFactor.ONE,g.BlendFactor.ONE_MINUS_SRC_ALPHA);k="linear-depth"===k||k.includes("shadow");c=a.colorTexture?.descriptor.internalFormat;c=k?3:c===g.SizedPixelFormat.R16F||c===g.SizedPixelFormat.R32F||c===g.SizedPixelFormat.R8?1:c===g.SizedPixelFormat.RG8?
2:c===g.SizedPixelFormat.RGBA16F?4:0;m.setUniform1i("inputType",c);k&&m.setUniform2fv("nearFar",this.camera.nearFar);d.screen.draw();d.bindFramebuffer(null);d.setViewport(b.x,b.y,b.width,b.height);e===h.FocusState.ON&&(this._focusedFBO=r,this._focusedFBOType=c);x&&a.colorTexture?.clearMipmap();return r}clearFocusedFBO(){this._focusedFBO=null}getPreviewContent(a,b,e,k){if(!e)return null;const c=this.renderingContext,l=this.fboCache.acquire(a,b,"fbo visualizer");c.bindFramebuffer(l?.fbo);c.setClearColor(this.clearColor[0],
this.clearColor[1],this.clearColor[2],this.clearColor[3]);c.clear(g.FramebufferBit.COLOR);c.setBlendingEnabled(!0);c.setBlendFunction(g.BlendFactor.ONE,g.BlendFactor.ONE_MINUS_SRC_ALPHA);c.setViewport(0,0,a,b);const d=this._ensureShader(c,!1,0);c.useProgram(d);c.bindTexture(e.getColorTexture(k),0);d.setUniform1i("colorTex",0);d.setUniform1i("inputType",0);c.screen.draw();e=new ImageData(new Uint8ClampedArray(a*b*4),a,b);c.gl.readPixels(0,0,a,b,g.PixelFormat.RGBA,g.DataType.UNSIGNED_BYTE,new Uint8Array(e.data.buffer));
c.bindFramebuffer(null);l?.release();return e}_ensureShader(a,b,e){const k={hasDepth:b,attachments:e},c=this._program.get(k);if(c)return c;b=`#version 300 es\n      precision highp float;\n\n      in vec2 uv;\n      uniform sampler2D colorTex;\n      layout(location = 0) out vec4 fragColor;\n      ${p.If(b,"layout(location \x3d 1) out vec4 fragDepth;\n         uniform sampler2D depthTex;")}\n      ${((l,d)=>{let f="";l=l?2:1;for(let m=0;m<d;m++)f+=`layout(location = ${p.glsl.int(l+m)}) out vec4 fragColor${p.glsl.int(m)};\n                uniform sampler2D colorTex${p.glsl.int(m)};`;
return f})(b,e)}\n      uniform int inputType;\n      uniform vec2 nearFar;\n\n      // Factors to convert rgba back to float\n      const vec4 RGBA_2_FLOAT_FACTORS = vec4(\n        255.0 / (256.0),\n        255.0 / (256.0 * 256.0),\n        255.0 / (256.0 * 256.0 * 256.0),\n        255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n      );\n\n\n      float rgba2float(vec4 rgba) {\n        // Convert components from 0->1 back to 0->255 and then add the components together with their corresponding\n        // fixed point factors, i.e. (256^1, 256^2, 256^3, 256^4)\n        return dot(rgba, RGBA_2_FLOAT_FACTORS);\n      }\n\n      float linearDepthFromFloat(float depth) {\n        depth = pow(depth, 0.2);\n        return -(depth * (nearFar[1] - nearFar[0]) + nearFar[0]);\n      }\n\n      float linearDepthFromRGBA(vec4 depth) {\n        return linearDepthFromFloat(rgba2float(depth));\n      }\n\n      float linearDepthFromTexture(sampler2D depthTex, vec2 uv) {\n        ivec2 iuv = ivec2(uv * vec2(textureSize(depthTex, 0)));\n        return linearDepthFromRGBA(texelFetch(depthTex, iuv, 0));\n      }\n\n      void main() {\n        vec4 color;\n        if(inputType == 1) {\n          color = vec4(vec3(texture(colorTex, uv).r), 1.0);\n        } else if(inputType == 2) {\n          color = vec4(texture(colorTex, uv).rg, 0.0, 1.0);\n        } else if(inputType == 3) {\n          float depth = 1.0 - (-linearDepthFromTexture(colorTex, uv) / (nearFar[1] - nearFar[0]));\n          color = vec4(vec3(depth), depth >= 0.999 ? 0.0 : 1.0);\n        } else if(inputType == 4) {\n          color = texture(colorTex, uv);\n          color = vec4(color.rgb / color.a, color.a);\n        } else {\n          color = texture(colorTex, uv);\n        }\n\n\n        if(color.a < ${p.glsl.float(C.alphaCutoff)})\n          discard;\n        else {\n          fragColor = color;\n          ${p.If(b,
"float depth \x3d 1.0 - pow(texture(depthTex, uv).r, 10.0);\n             fragDepth \x3d vec4(vec3(depth), depth \x3c 0.000001 ? 0.0 : 1.0);")}\n          ${p.If(0<e,(l=>{let d="";for(let f=0;f<l;f++)d+=`fragColor${p.glsl.int(f)} = texture(colorTex${p.glsl.int(f)}, uv);`;return d})(e))}\n        }\n      }`;this._program.set(k,a.programCache.acquire("#version 300 es\n      in vec2 position;\n      out vec2 uv;\n\n      void main() {\n        gl_Position \x3d vec4(position, 0.0, 1.0);\n        uv \x3d position * 0.5 + vec2(0.5);\n      }",
b,D.Default3D));return this._program.get(k)}};q.__decorate([t.property()],h.RenderNodeVisualizerNode.prototype,"destroyedCB",void 0);q.__decorate([t.property()],h.RenderNodeVisualizerNode.prototype,"produces",void 0);q.__decorate([t.property()],h.RenderNodeVisualizerNode.prototype,"consumes",void 0);q.__decorate([t.property()],h.RenderNodeVisualizerNode.prototype,"clearColor",void 0);h.RenderNodeVisualizerNode=q.__decorate([z.subclass("esri.views.3d.webgl-engine.effects.debug.RenderNodeVisualizerNode")],
h.RenderNodeVisualizerNode);h.FocusState=void 0;(function(a){a[a.ON=0]="ON";a[a.OFF=1]="OFF"})(h.FocusState||(h.FocusState={}));Object.defineProperty(h,Symbol.toStringTag,{value:"Module"})});