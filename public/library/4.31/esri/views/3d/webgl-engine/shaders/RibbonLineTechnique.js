// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.31/esri/copyright.txt for details.
//>>built
define("require exports ../../../../core/has ../core/shaderLibrary/ShaderOutput ../core/shaderTechnique/ReloadableShaderModule ../core/shaderTechnique/ShaderTechnique ../lib/OITPass ../lib/OrderIndependentTransparency ../lib/RenderSlot ../lib/StencilUtils ../lib/VertexAttribute ../../../../chunks/RibbonLine.glsl ../../../webgl/enums ../../../webgl/renderState".split(" "),function(u,n,C,h,v,w,p,k,q,b,c,x,g,e){class y extends w.ShaderTechnique{constructor(a,d,f){super(a,d,new v.ReloadableShaderModule(x.RibbonLine,
()=>new Promise((l,m)=>u(["./RibbonLine.glsl"],l,m))),f,r);this.primitiveType=d.wireframe?g.PrimitiveType.LINES:g.PrimitiveType.TRIANGLE_STRIP}_makePipelineState(a,d){const {oitPass:f,output:l,hasOccludees:m,hasPolygonOffset:z}=a,A=f===p.OITPass.NONE,B=f===p.OITPass.FrontFace;return e.makePipelineState({blending:a.output===h.ShaderOutput.Color?k.blending(f):null,depthTest:{func:k.oitDepthTest(f)},depthWrite:k.depthWrite(a),drawBuffers:l===h.ShaderOutput.Depth?{buffers:[g.SpecialDrawBuffers.NONE]}:
k.getDrawBuffers(f,l),colorWrite:e.defaultColorWrite,stencilWrite:m?b.stencilWriteMaskOn:null,stencilTest:m?d?b.stencilToolMaskBaseParams:b.stencilBaseAllZerosParams:null,polygonOffset:A||B?z?t:null:k.OITPolygonOffset})}initializePipeline(a){if(a.occluder){const d=a.hasPolygonOffset?t:null;this._occluderPipelineTransparent=e.makePipelineState({blending:e.premultipliedAlphaToPremultipliedAlpha,polygonOffset:d,depthTest:b.depthCompareAlways,depthWrite:null,colorWrite:e.defaultColorWrite,stencilWrite:null,
stencilTest:b.stencilToolTransparentOccluderParams,drawBuffers:a.output===h.ShaderOutput.Depth?{buffers:[g.SpecialDrawBuffers.NONE]}:null});this._occluderPipelineOpaque=e.makePipelineState({blending:e.premultipliedAlphaToPremultipliedAlpha,polygonOffset:d,depthTest:b.depthCompareAlways,depthWrite:null,colorWrite:e.defaultColorWrite,stencilWrite:b.stencilWriteMaskOff,stencilTest:b.stencilToolMaskOccluderParams,drawBuffers:a.output===h.ShaderOutput.Depth?{buffers:[g.SpecialDrawBuffers.NONE]}:null});
this._occluderPipelineMaskWrite=e.makePipelineState({blending:null,polygonOffset:d,depthTest:b.depthCompareLess,depthWrite:null,colorWrite:null,stencilWrite:b.stencilWriteMaskOn,stencilTest:b.stencilToolMaskBaseParams,drawBuffers:a.output===h.ShaderOutput.Depth?{buffers:[g.SpecialDrawBuffers.NONE]}:null})}this._occludeePipeline=this._makePipelineState(a,!0);return this._makePipelineState(a,!1)}getPipeline(a,d){if(a)return this._occludeePipeline;switch(d){case q.RenderSlot.TRANSPARENT_OCCLUDER_MATERIAL:return this._occluderPipelineTransparent??
super.getPipeline();case q.RenderSlot.OCCLUDER_MATERIAL:return this._occluderPipelineOpaque??super.getPipeline();default:case void 0:case null:return this._occluderPipelineMaskWrite??super.getPipeline()}}}const t={factor:0,units:-4},r=new Map([[c.VertexAttribute.POSITION,0],[c.VertexAttribute.PREVPOSITION,1],[c.VertexAttribute.NEXTPOSITION,2],[c.VertexAttribute.SUBDIVISIONFACTOR,3],[c.VertexAttribute.UV0,4],[c.VertexAttribute.COLOR,5],[c.VertexAttribute.COLORFEATUREATTRIBUTE,5],[c.VertexAttribute.SIZE,
6],[c.VertexAttribute.SIZEFEATUREATTRIBUTE,6],[c.VertexAttribute.OPACITYFEATUREATTRIBUTE,7],[c.VertexAttribute.OBJECTANDLAYERIDCOLOR,8]]);n.RibbonLineTechnique=y;n.vertexAttributeLocations=r;Object.defineProperty(n,Symbol.toStringTag,{value:"Module"})});