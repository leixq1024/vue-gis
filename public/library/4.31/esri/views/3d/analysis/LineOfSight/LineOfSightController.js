// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.31/esri/copyright.txt for details.
//>>built
define("exports ../../../../chunks/tslib.es6 ../../../../geometry ../../../../analysis/featureReferenceUtils ../../../../core/Accessor ../../../../core/asyncUtils ../../../../core/Evented ../../../../core/Handles ../../../../core/handleUtils ../../../../core/Logger ../../../../core/maybe ../../../../core/promiseUtils ../../../../core/reactiveUtils ../../../../core/accessorSupport/decorators/property ../../../../core/has ../../../../core/RandomLCG ../../../../core/accessorSupport/decorators/subclass ../../../../chunks/vec32 ../../../../core/libs/gl-matrix-2/factories/vec3f64 ../../../../core/support/UpdatingHandles ../../../../geometry/projection ../../../../geometry/projection/projectBoundingRect ../../../../geometry/support/aaBoundingRect ../../../../geometry/support/ray ../../../../support/elevationInfoUtils ../LineOfSightAnalysisResult ./LineOfSightComputation ./LineOfSightRayIntersector ../support/projectionUtils ../../webgl-engine/lib/IntersectorInterfaces ../../webgl-engine/lib/intersectorUtilsConversions ../../../support/Scheduler ../../../../geometry/Point".split(" "),
function(k,m,ea,F,P,Q,R,S,x,G,H,T,A,p,fa,ha,U,g,y,V,B,W,C,I,J,X,Y,Z,K,aa,L,t,ba){function M(a,b){return a.hasZ?b??{mode:"absolute-height",offset:0}:{mode:"on-the-ground",offset:0}}function ca({computation:a,interpolationInfo:b}){const {computationResult:c,inputPoints:f}=a,{start:h,end:d,intersection:e}=c,{originalIntersection:n,originalObserver:q,originalTarget:l}=b;g.copy(e,n);f.isValid?(a=D,b=g.dist(q,n)/g.dist(q,l),g.sub(a,h,q),g.scale(a,a,1-b),g.add(e,e,a),g.sub(a,d,l),g.scale(a,a,b),g.add(e,
e,a),c.isValid=!0):(a.result=null,c.isValid=!1,c.isTargetVisible=!1)}k.LineOfSightController=class extends R.EventedMixin(P){constructor(a){super(a);this.updateOnCameraChange=!0;this._observerGroundOffsetRenderSpace=0;this._effectiveObserverElevationMode="absolute-height";this._observerFeatureId=null;this._updatingHandles=new V.UpdatingHandles;this._frameTask=t.ImmediateTask;this._computationHandles=new S;this._externalObserverUpdate=!0}initialize(){const a=this.view.resourceController?.scheduler;
this._frameTask=a?a.registerTask(t.TaskPriority.LINE_OF_SIGHT_TOOL):t.ImmediateTask;this._intersector=new Z.LineOfSightRayIntersector({view:this.view});this.addHandles([this._connectObserver(),this._connectComputations(),this._connectTargets()])}destroy(){this._computationHandles.destroy();this._computations.removeAll();this._updatingHandles.destroy()}get updating(){return this._frameTask.updating||this._updatingHandles.updating}get priority(){return this._frameTask.priority}set priority(a){this._frameTask.priority=
a}get _computations(){return this.analysisViewData.computations}get _elevationAlignedObserverPositionRenderSpace(){return this.analysisViewData.observerEngineLocation}set _elevationAlignedObserverPositionRenderSpace(a){this.analysisViewData.observerEngineLocation=a}get _screenPixelSize(){return this.view.state.camera.computeScreenPixelSizeAt(this._elevationAlignedObserverPositionRenderSpace)}_computeResult(a){const b=a.computation,{inputPoints:c,computationResult:f}=b,{observerAdjusted:h,targetAdjusted:d}=
c,{start:e,end:n}=f;g.copy(e,h);g.copy(n,d);this._canCompute(b)?this._computeIntersection(a):ca(a);b.notifyResultChanged();this.emit("result-changed",{target:a.computation.target,result:b.result})}_adjustStartEndPositions(a){var {view:b}=this;({inputPoints:a}=a);const {observer:c,target:f,observerAdjusted:h,targetAdjusted:d}=a;g.copy(h,c);g.copy(d,f);F.updatePointsFromFeatureReference(b,this._intersector.intersector,a);const {observerSurfaceNormal:e,targetSurfaceNormal:n}=a,q=this._screenPixelSize;
a=D;null!=e?g.copy(a,e):g.subtract(a,d,h);g.normalize(a,a);g.scale(a,a,Math.min(q,1));g.add(h,h,a);null!=n?g.copy(a,n):g.subtract(a,h,d);b=b.state.camera.computeScreenPixelSizeAt(d);g.normalize(a,a);g.scale(a,a,Math.min(b,1));g.add(d,d,a)}_computeIntersection({computation:a,interpolationInfo:b}){const {view:c}=this,{sceneIntersectionHelper:f,renderCoordsHelper:h}=c;if(null!=f){var d=this._intersector.intersector,{computationResult:e,inputPoints:n}=a,{observer:q,target:l}=n,{start:u,end:v}=e,w=I.fromPoints(u,
v,da);d.options.store=aa.StoreResults.MIN;f.intersectToolIntersectorRay(w,d);d=d.results.min;w=e.intersection;var N=D,r=!0;null!=d&&d.getIntersectionPoint(w)&&(g.copy(b.originalIntersection,w),g.copy(b.originalObserver,u),g.copy(b.originalTarget,v),h.fromRenderCoords(w,N,c.spatialReference),b=1-g.dist(v,l)/g.dist(u,l),r=g.dist(q,w)>=b*g.dist(q,l));b=new ba(N,c.spatialReference);var {result:z,target:O}=a;null!=z?(z.target=O,z.intersectedGraphic=r?null:L.toGraphic(d,c),z.intersectedLocation=r?null:
b,z.visible=r):a.result=new X({target:O,elevationAlignedTargetLocation:a.elevationAlignedTargetLocation,intersectedGraphic:r?null:L.toGraphic(d,c),intersectedLocation:r?null:b,visible:r});e.isValid=n.isValid=!0;e.isTargetVisible=r}}_canCompute(a){var b=this.view.frustum;if(null==this.analysisViewData.elevationAlignedObserver||null==a.elevationAlignedTargetLocation||null==b)return!1;const {observerAdjusted:c,targetAdjusted:f}=a.inputPoints;a=b.intersectsPoint(c);b=b.intersectsPoint(f);return a&&b}_onObserverPositionChange(a,
b,c,f,h){this._externalObserverUpdate=h;if(null==a)this._observerFeatureId=this.analysisViewData.elevationAlignedObserver=null;else if(null==b)K.logFailedGeometryProjectionError(this.analysis,a.spatialReference,G.getLogger(this)),this.analysisViewData.elevationAlignedObserver=null;else{a=M(b,c);var {absoluteZ:d,elevation:e}=J.zValueInAbsoluteHeightMode(b.x,b.y,b.z,this.view.spatialReference,this.view,a);b=b.clone();b.z=d;this._effectiveObserverElevationMode=a.mode;this.analysisViewData.elevationAlignedObserver=
b;a=y.create();this.view.renderCoordsHelper.toRenderCoords(b,a);this._elevationAlignedObserverPositionRenderSpace=a;this._observerGroundOffsetRenderSpace=d-e;this._observerFeatureId=F.getFeatureId(f);this.priority=t.TaskPriority.LINE_OF_SIGHT_TOOL_INTERACTIVE}}_onObserverRenderSpacePositionChangeForComputation(a,b,c,f,h){const {inputPoints:d}=a;g.copy(d.observer,b);d.observerFeatureId=h;d.observerSurfaceNormal=null;switch(f){case "on-the-ground":case "relative-to-ground":b=this._intersector.updateFromGroundIntersection(d.observer,
c,d.observer),null==d.observerFeatureId&&(d.observerSurfaceNormal=b)}this._adjustStartEndPositions(a);a.notifyInputPointsChanged();this.priority=t.TaskPriority.LINE_OF_SIGHT_TOOL_INTERACTIVE}_onTargetPositionChange(a,b,c,f,h,d=!0){const e=a.inputPoints;d&&(e.isValid=!1);if(null==c)null!=b&&K.logFailedGeometryProjectionError(this.analysis,b.spatialReference,G.getLogger(this)),a.elevationAlignedTargetLocation=null,a.notifyInputPointsChanged();else{b=M(c,f);var {absoluteZ:n,elevation:q}=J.zValueInAbsoluteHeightMode(c.x,
c.y,c.z,this.view.spatialReference,this.view,b);c=c.clone();c.z=n;a.elevationAlignedTargetLocation=c;this.view.renderCoordsHelper.toRenderCoords(a.elevationAlignedTargetLocation,e.target);e.targetFeatureId=F.getFeatureId(h);e.targetSurfaceNormal=null;switch(b.mode){case "on-the-ground":case "relative-to-ground":h=this._intersector.updateFromGroundIntersection(e.target,n-q,e.target),null==e.targetFeatureId&&(e.targetSurfaceNormal=h)}this._adjustStartEndPositions(a);a.notifyInputPointsChanged();this.priority=
t.TaskPriority.LINE_OF_SIGHT_TOOL_INTERACTIVE}}_connectComputationToTarget(a){return x.handlesGroup([this._updatingHandles.add(()=>({computation:a,targetPosition:a.target.position,targetElevationInfo:a.target.elevationInfo,targetFeatureInfo:a.target.feature,projectedTargetPosition:B.projectOrLoad(a.target.position,this.view.spatialReference)}),({computation:b,targetPosition:c,targetElevationInfo:f,targetFeatureInfo:h,projectedTargetPosition:d})=>{null!=d.pending?this._updatingHandles.addPromise(d.pending):
this._onTargetPositionChange(b,c,d.geometry,f,h)},A.initial)])}_connectComputationToObserver(a){return this._updatingHandles.add(()=>({computation:a,observer:this.analysisViewData.elevationAlignedObserver}),({computation:b})=>{this._externalObserverUpdate&&(b.inputPoints.isValid=!1,b.notifyInputPointsChanged())},A.initial)}_connectComputationToRenderSpaceObserver(a){return this._updatingHandles.add(()=>({computation:a,observer:this._elevationAlignedObserverPositionRenderSpace,observerGroundOffset:this._observerGroundOffsetRenderSpace,
observerElevationMode:this._effectiveObserverElevationMode,observerFeatureId:this._observerFeatureId}),({computation:b,observer:c,observerGroundOffset:f,observerElevationMode:h,observerFeatureId:d})=>{this._onObserverRenderSpacePositionChangeForComputation(b,c,f,h,d)},A.initial)}_connectComputationToCamera(a){return this._updatingHandles.add(()=>({camera:this.view.state.camera,isDirty:this._isCameraDirty}),({isDirty:b})=>{!this.updateOnCameraChange||a.inputPoints.isValid&&!b||a.notifyInputPointsChanged()})}_connectComputationToSlicePlane(a){return this._updatingHandles.add(()=>
this.view.slicePlane,()=>{a.inputPoints.isValid=!1;a.notifyInputPointsChanged()})}_connectComputationToElevation(a){const b=(c,f)=>{const h=this.analysis.observer,d=a.target;var e=null;let n=null,q=null;var l=null;let u=null,v=null;if(null!=h?.position){e=B.projectOrLoad(h.position,this.view.spatialReference);if(null!=e.pending){this._updatingHandles.addPromise(e.pending);e.pending.finally(()=>b(c,f));return}e=e.geometry;n=h.elevationInfo;q=h.feature}if(null!=d.position){l=B.projectOrLoad(d.position,
this.view.spatialReference);if(null!=l.pending){this._updatingHandles.addPromise(l.pending);l.pending.finally(()=>b(c,f));return}l=l.geometry;u=d.elevationInfo;v=d.feature}if(null!=e||null!=l)W.projectBoundingRect(c,f,E,this.view.spatialReference),null!=e&&C.containsPointObject(E,e)&&this._onObserverPositionChange(null!=h?h.position:null,e,n,q,!1),null!=l&&C.containsPointObject(E,l)&&this._onTargetPositionChange(a,d.position,l,u,v,!1),null!=e&&null!=l&&C.intersectsSegment(E,e,l)&&a.notifyInputPointsChanged()};
return this.view.elevationProvider.on("elevation-change",({extent:c,spatialReference:f})=>b(c,f))}_connectComputationToTask(a){let b=null;const c={computation:a,interpolationInfo:{originalIntersection:y.create(),originalObserver:y.create(),originalTarget:y.create()}};return x.handlesGroup([this._updatingHandles.add(()=>a.inputPoints,()=>{b=H.abortMaybe(b);b=Q.createTask(async f=>{await T.ignoreAbortErrors(this._frameTask.schedule(()=>this._computeResult(c),f))})},{initial:!0,equals:()=>!1}),x.makeHandle(()=>
b=H.abortMaybe(b))])}_connectComputation(a){const b=this._computationHandles;b.has(a)||b.add([this._connectComputationToTarget(a),this._connectComputationToObserver(a),this._connectComputationToRenderSpaceObserver(a),this._connectComputationToCamera(a),this._connectComputationToSlicePlane(a),this._connectComputationToElevation(a),this._connectComputationToTask(a)],a)}_disconnectComputation(a){this._computationHandles.remove(a)}_onComputationCollectionChange({added:a,removed:b}){for(const c of b)this._disconnectComputation(c);
for(const c of a)this._connectComputation(c)}_onTargetCollectionChange({added:a,removed:b}){for(const c of b)this._removeTarget(c);for(const c of a)this._addTarget(c)}_onCursorTargetChange(a,b){null!=b&&this._removeTarget(b);null!=a&&this._addTarget(a)}_addTarget(a){this._computations.some(b=>b.target===a)||this._computations.add(new Y.LineOfSightComputation({target:a}))}_removeTarget(a){const b=this._computations.findIndex(c=>c.target===a);this._computations.removeAt(b)}_connectObserver(){return x.handlesGroup([this._updatingHandles.add(()=>
({observerPosition:null!=this.analysis.observer?this.analysis.observer.position:null,projectedObserverPosition:B.projectOrLoad(null!=this.analysis.observer?this.analysis.observer.position:null,this.view.spatialReference),observerElevationInfo:null!=this.analysis.observer?this.analysis.observer.elevationInfo:null,observerFeatureInfo:null!=this.analysis.observer?this.analysis.observer.feature:null}),({observerPosition:a,projectedObserverPosition:b,observerElevationInfo:c,observerFeatureInfo:f})=>{null!=
b.pending?this._updatingHandles.addPromise(b.pending):this._onObserverPositionChange(a,b.geometry,c,f,!0)},A.initial)])}_connectComputations(){return this._updatingHandles.addOnCollectionChange(()=>this._computations,a=>this._onComputationCollectionChange(a),{initial:!0,final:!0})}_connectTargets(){return x.handlesGroup([this._updatingHandles.addOnCollectionChange(()=>this.analysis.targets,a=>this._onTargetCollectionChange(a),{initial:!0,final:!0}),this._updatingHandles.add(()=>this.analysisViewData.cursorTarget,
(a,b)=>{this._onCursorTargetChange(a,b)})])}get _isCameraDirty(){var a=this.analysisViewData.elevationAlignedObserver;const {view:b}=this,{renderCoordsHelper:c}=b;if(null==a||null==c)return!1;const f=D;c.toRenderCoords(a,f);a=b.state.camera.computeScreenPixelSizeAt(f);return.1<Math.abs((a-this._screenPixelSize)/this._screenPixelSize)}};m.__decorate([p.property({constructOnly:!0})],k.LineOfSightController.prototype,"analysis",void 0);m.__decorate([p.property({constructOnly:!0})],k.LineOfSightController.prototype,
"analysisViewData",void 0);m.__decorate([p.property({constructOnly:!0})],k.LineOfSightController.prototype,"view",void 0);m.__decorate([p.property()],k.LineOfSightController.prototype,"updating",null);m.__decorate([p.property()],k.LineOfSightController.prototype,"priority",null);m.__decorate([p.property()],k.LineOfSightController.prototype,"updateOnCameraChange",void 0);m.__decorate([p.property()],k.LineOfSightController.prototype,"_computations",null);m.__decorate([p.property()],k.LineOfSightController.prototype,
"_elevationAlignedObserverPositionRenderSpace",null);m.__decorate([p.property()],k.LineOfSightController.prototype,"_observerGroundOffsetRenderSpace",void 0);m.__decorate([p.property()],k.LineOfSightController.prototype,"_effectiveObserverElevationMode",void 0);m.__decorate([p.property()],k.LineOfSightController.prototype,"_observerFeatureId",void 0);m.__decorate([p.property()],k.LineOfSightController.prototype,"_screenPixelSize",null);m.__decorate([p.property({readOnly:!0})],k.LineOfSightController.prototype,
"_updatingHandles",void 0);m.__decorate([p.property()],k.LineOfSightController.prototype,"_frameTask",void 0);m.__decorate([p.property()],k.LineOfSightController.prototype,"_isCameraDirty",null);k.LineOfSightController=m.__decorate([U.subclass("esri.views.3d.analysis.LineOfSight.LineOfSightController")],k.LineOfSightController);const D=y.create(),da=I.create(),E=C.empty();Object.defineProperty(k,Symbol.toStringTag,{value:"Module"})});