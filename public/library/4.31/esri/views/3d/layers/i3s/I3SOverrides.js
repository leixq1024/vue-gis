// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.31/esri/copyright.txt for details.
//>>built
define("exports ../../../../chunks/tslib.es6 ../../../../request ../../../../core/Accessor ../../../../core/arrayUtils ../../../../core/asyncUtils ../../../../core/byteSizeEstimations ../../../../core/Collection ../../../../core/handleUtils ../../../../core/has ../../../../core/Logger ../../../../core/maybe ../../../../core/promiseUtils ../../../../core/ReactiveSet ../../../../core/reactiveUtils ../../../../core/accessorSupport/decorators/property ../../../../core/accessorSupport/decorators/subclass ../../../../geometry/support/spatialReferenceUtils ../../../../intl/number ../../../../layers/support/featureQueryAll ../../../../rest/support/meshFeatureSet ../../../../support/requestUtils ../../../ViewingMode".split(" "),
function(l,n,I,J,K,x,A,B,L,T,t,y,C,D,E,p,M,N,O,F,G,P,Q){function z(a,c,b,e){return`Displaying the edits of a SceneLayer with a${e===r.Mode?a.isGeographic?" geographic ":" projected ":" "}spatial reference (wkid:${a.wkid}) in ${b} viewing mode${e===r.SpatialReference?` with spatial reference (wkid:${c.wkid}) `:" "}is not supported. No geometry edits will be displayed for this layer.\nPlease consider re-caching the scene service or changing the ${e===r.Mode?"viewing mode":"view spatial reference"} to display edits.`}
l.I3SOverrides=class extends J{constructor(a){super(a);this._warnMaximumChangedObjectsExceeded=!1;this._maximumNumberOfEditOVerrides=5E4;this._definitionExpressionDirty=!0;this._interactiveEditingSessions=new B;this.geometryOverrides=new B;this._clientGeometryCache=new Map;this._attributeChangedObjectIds=new D;this._geometryChangedObjectIds=new D;this._pendingFetchChangedObjectIds=null;this._pendingFetchAbortController=new AbortController;this._applyGeometryOverridesTask=null;this._featureIdLocks=
new Map}initialize(){this._memCache=this.memoryController.newCache(`i3s-attribute-overrides-${this.layer.uid}`);this.addHandles(E.watch(()=>this.layer.definitionExpression,async()=>{this._definitionExpressionDirty=!0;this._pendingFetchChangedObjectIds||(this._applyGeometryOverridesTask=y.abortMaybe(this._applyGeometryOverridesTask),this._applyGeometryOverridesTask=x.createTask(a=>this._queryAndAddGeometryOverrides(a)),await this._applyGeometryOverridesTask.promise)},E.sync));this._pendingFetchChangedObjectIds=
this._fetchChangedObjectIds(this._pendingFetchAbortController?.signal);this._pendingFetchChangedObjectIds.finally(()=>{this._pendingFetchChangedObjectIds=this._pendingFetchAbortController=null})}destroy(){this._set("layer",null);this._memCache=y.destroyMaybe(this._memCache);this._pendingFetchAbortController=y.abortMaybe(this._pendingFetchAbortController);this._pendingFetchChangedObjectIds=null;this._featureIdLocks.clear()}get is3DOFL(){return null!=this._associatedLayer?.infoFor3D}get sortedGeometryChangedObjectIds(){return this.is3DOFL?
[...this._geometryChangedObjectIds].sort((a,c)=>a-c):[]}get _associatedLayer(){return null==this.layer?null:this.layer.associatedLayer}get hasGeometryChanges(){return 0<this._geometryChangedObjectIds.size}get updating(){return this.is3DOFL?this._pendingFetchChangedObjectIds||this._applyGeometryOverridesTask&&!this._applyGeometryOverridesTask.finished?!0:!1:!1}get isEmpty(){return null==this._pendingFetchChangedObjectIds&&0===this._attributeChangedObjectIds.size&&0===this._geometryChangedObjectIds.size}featureHasGeometryChanges(a){return this._geometryChangedObjectIds.has(a)}featureHasAttributeChanges(a){return this._attributeChangedObjectIds.has(a)}createInteractiveEditSession(a){this._attributeChangedObjectIds.add(a);
const c=this._interactiveEditingSessions,b=new R(a,()=>{c.remove(b)});c.unshift(b);return b}async applyAttributeOverrides(a,c,b,e=[]){this._pendingFetchChangedObjectIds&&await C.whenOrAbort(this._pendingFetchChangedObjectIds,b);if(null!=c){var {attributeData:d,loadedAttributes:g}=c;if(null!=g&&null!=d&&0!==this._attributeChangedObjectIds.size){c=new Set;for(var f of g)c.add(f.index);for(const h of e)c.has(h.index)||(g.push(h),d[h.name]=Array(a.length));e=await this._lockFeatureIds(a);try{f={attributeData:d,
loadedAttributes:g};const h=this._getOverridesFromCache(a,f,this._attributeChangedObjectIds),{objectIds:m,fieldNames:q}=h;if(0!==m.length&&0!==q.length){var k=await this._queryAttributeOverridesFromAssociatedLayer(m,q,b);null!=k&&this._processOverridesFromAssociatedLayer(a,k,q,f)}}finally{e.remove()}}}}updateGeometry(a,c){this._geometryChangedObjectIds.add(a);const b=this._clientGeometryCache.get(a);null!=b&&(this.geometryOverrides.remove(b),this._clientGeometryCache.delete(a));null!=c&&(c={oid:a,
mesh:c},this.geometryOverrides.add(c),this._clientGeometryCache.set(a,c))}updateAttributeValue(a,c,b){this._attributeChangedObjectIds.add(a);this._cacheAttributeValue(a,c,b)}featureAdded(a){this.is3DOFL&&this._geometryChangedObjectIds.add(a);this._attributeChangedObjectIds.add(a)}_cacheAttributeValue(a,c,b){this._memCache.put(this._getAttributeCacheKey(a,c),b,this._memCacheAttributeValueSize(b))}_getOverridesFromCache(a,{loadedAttributes:c,attributeData:b},e){const d=new Set,g=[];for(var f of c)g[f.index]=
b[f.name];b=new Set;for(f=0;f<a.length;f++){const k=a[f];if(e.has(k))for(const h of c){const m=this._attributeFromCache(k,h.index);void 0!==m?g[h.index][f]=m:(d.add(k),b.add(h.name))}}return{objectIds:Array.from(d),fieldNames:Array.from(b)}}_attributeFromCache(a,c){const b=this._fromInteractiveEditingSession(a,c);if(void 0!==b)return b;a=this._getAttributeCacheKey(a,c);return this._memCache.get(a)}_fromInteractiveEditingSession(a,c){if(null!=this._interactiveEditingSessions)for(const b of this._interactiveEditingSessions){if(b.objectId!==
a)continue;const e=b.getAttribute(c);if(void 0!==e)return e}}_getAttributeCacheKey(a,c){return`${a}-${c}`}async _queryAttributeOverridesFromAssociatedLayer(a,c,b){if(0===a.length)return null;this._logWarningIfMaximumObjectsExceeded();const {associatedLayer:e}=this.layer;if(null==e)return null;const d=e.createQuery(),{objectIdField:g}=e;c=[g,...c];d.where=this.layer.definitionExpression||"1\x3d1";d.returnGeometry=!1;d.outFields=c;d.cacheHint=!0;a=await this._executeBatchQuery(e,a,d,b);b=[];for(const f of a)if(f.ok)for(const k of f.value.features)b.push(k);
return b}async _queryGeometryOverridesFromAssociatedLayer(a,c){if(0===a.length||!this.is3DOFL)return null;var b=this.layer.associatedLayer;const e=b.infoFor3D,{spatialReference:d}=b,{state:{viewingMode:g},spatialReference:f}=this.view;var k=g===Q.ViewingMode.Global,h=d.isGeographic;if(k&&!h)return t.getLogger(this).warn("unsupported-pcs-edits-in-global-view",this.layer.title,z(d,f,this.view.viewingMode,r.Mode)),null;if(!k&&h)return t.getLogger(this).warn("unsupported-gcs-edits-in-local-view",this.layer.title,
z(d,f,this.view.viewingMode,r.Mode)),null;if(!(N.equals(d,f)||k&&f.isWebMercator&&d.isWGS84))return t.getLogger(this).warn("unsupported-mismatched-spatial-reference-edits",this.layer.title,z(d,f,this.view.viewingMode,r.SpatialReference)),null;this._logWarningIfMaximumObjectsExceeded();const {objectIdField:m,globalIdField:q}=b;k=[m,...(null!=q?[q]:[])];h=b.createQuery();h.where=this.layer.definitionExpression||"1\x3d1";h.returnGeometry=!0;h.outFields=k;h.cacheHint=!0;h.returnZ=b.hasZ;h.returnM=b.hasM;
c=await this._executeBatchQuery(b,a,h,c);a=[];for(const u of c){if(!u.ok)continue;const {assetMaps:v,features:w,globalIdFieldName:S}=u.value;if(null!=v){c=G.assetMapFromAssetMapsJSON(e,v);for(const H of w)b=G.extractMesh(H,S,d,e,c),k=H,null==b?k.geometry=null:(k.geometry=b,a.push(k))}}return a}_logWarningIfMaximumObjectsExceeded(){if(this._warnMaximumChangedObjectsExceeded){this._warnMaximumChangedObjectsExceeded=!1;var a=`The number of edited objects that are not yet cached in the scene service exceeds the maximum limit. Attribute changes will only be available for the first ${O.formatNumber(this._maximumNumberOfEditOVerrides)} objects. Please consider re-caching the scene service`,
c=this.layer.portalItem;a=c?.loaded?a+` (${c.portal.url}/home/item.html?id=${c.id}#settings)`:a+` (${this.layer.parsedUrl.path})`;t.getLogger(this).warn("#queryOverrides()",this.layer.title,`${a}.`)}}async _executeBatchQuery(a,c,b,e){if(0===c.length)return[];const d=F.getMaximumQuerySize(a);c=[...c].sort((g,f)=>g-f);c=K.splitIntoChunks(c,d).map(g=>{const f=b.clone();f.objectIds=g;return x.resultOrAbort(F.queryAllJSON(a,f,{signal:e}))});return Promise.all(c)}_processOverridesFromAssociatedLayer(a,
c,b,{loadedAttributes:e,attributeData:d}){var g=this._associatedLayer;if(null!=g){g=g.objectIdField;var f=b.map(m=>{m in d||(d[m]=Array(a.length));return d[m]}),k=new Map(e.map(m=>[m.name,m.index]));e=b.map(m=>k.get(m));var h=new Map(Array.from(a,(m,q)=>[m,q]));for(const m of c){c=m.attributes[g];for(let q=0;q<b.length;q++){const u=e[q],v=h.get(c),w=m.attributes[b[q]];f[q][v]=w;this._cacheAttributeValue(c,u,w)}}}}_memCacheAttributeValueSize(a){return"string"===typeof a?A.estimateStringByteSize(a):
A.estimateNumberByteSize()}async _fetchChangedObjectIds(a){var c=this.layer;await c.load({signal:a});this._geometryChangedObjectIds.clear();this._attributeChangedObjectIds.clear();var {associatedLayer:b}=c;if(null!=b&&b.capabilities?.operations?.supportsChangeTracking){var e=this._getFetchChangedObjectIdsServerGen();if(null!=e){var d=b.layerId;c=this.is3DOFL;e={f:"json",returnIdsOnly:!0,layers:`[${d}]`,returnUpdates:!0,returnDeletes:c,returnInserts:c,layerServerGens:JSON.stringify([{id:d,serverGen:e}])};
c&&(d=b.infoFor3D,e.fieldsToCompare=JSON.stringify({fields:[...Object.values(d.transformFieldRoles),d.sourceHashField]}));b=await x.result(I(`${b.url}/extractChanges`,{method:"post",query:e,timeout:1E4,signal:a}));!b.ok&&P.isTimeoutError(b.error)&&(e=this.layer.title,t.getLogger(this).warn("extractChanges:timeout",e,`${e} could not obtain edited features that are not cached in the scene service. Display of features may not be up to date with the latest edits. Consider re-caching the scene service.`));
if(b.ok&&1===b.value.data?.edits?.length){e=b.value.data.edits[0];b=e?.objectIds;d=b?.adds??[];const g=b?.updates??[],f=b?.deletes??[];b=[...d,...g,...f];c=c?[...d,...(e?.fieldUpdates??g),...f]:[];e=Math.min(this._maximumNumberOfEditOVerrides,b.length);e<b.length&&(this._warnMaximumChangedObjectsExceeded=!0);b=b.sort((k,h)=>k-h);for(d=0;d<e;++d)this._attributeChangedObjectIds.add(b[d]);for(const k of c)this._geometryChangedObjectIds.add(k);for(;this._definitionExpressionDirty;)await this._queryAndAddGeometryOverrides(a)}}}}async _queryAndAddGeometryOverrides(a){this._definitionExpressionDirty=
!1;const {associatedLayer:c}=this.layer;if(null!=c&&c.capabilities?.operations?.supportsChangeTracking&&this.is3DOFL&&0<this._geometryChangedObjectIds.size&&(a=await this._queryGeometryOverridesFromAssociatedLayer(Array.from(this._geometryChangedObjectIds),a),null!=a))for(const b of a)null!=b.geometry&&this.updateGeometry(b.attributes[c.objectIdField],b.geometry)}_getFetchChangedObjectIdsServerGen(){var a=this.layer;if(null!=a.serviceUpdateTimeStamp?.lastUpdate)return a.serviceUpdateTimeStamp.lastUpdate;
a=a.associatedLayer;return null!=a?.serverGens?.minServerGen?a.serverGens.minServerGen:null}async _lockFeatureIds(a){const c=this._featureIdLocks;for(var b=!0;b;){const d=[];for(const g of a){const f=c.get(g);f&&d.push(f)}0===d.length?b=!1:await Promise.all(d)}const e=C.createResolver();b=e.promise;for(const d of a)c.set(d,b);return L.makeHandle(()=>{for(const d of a)c.delete(d);e.resolve()})}get test(){}};n.__decorate([p.property({constructOnly:!0})],l.I3SOverrides.prototype,"view",void 0);n.__decorate([p.property({constructOnly:!0})],
l.I3SOverrides.prototype,"layer",void 0);n.__decorate([p.property({readOnly:!0})],l.I3SOverrides.prototype,"is3DOFL",null);n.__decorate([p.property()],l.I3SOverrides.prototype,"_interactiveEditingSessions",void 0);n.__decorate([p.property({readOnly:!0})],l.I3SOverrides.prototype,"sortedGeometryChangedObjectIds",null);n.__decorate([p.property({readOnly:!0})],l.I3SOverrides.prototype,"geometryOverrides",void 0);n.__decorate([p.property()],l.I3SOverrides.prototype,"_clientGeometryCache",void 0);n.__decorate([p.property()],
l.I3SOverrides.prototype,"_associatedLayer",null);n.__decorate([p.property({constructOnly:!0})],l.I3SOverrides.prototype,"memoryController",void 0);n.__decorate([p.property()],l.I3SOverrides.prototype,"_attributeChangedObjectIds",void 0);n.__decorate([p.property()],l.I3SOverrides.prototype,"_geometryChangedObjectIds",void 0);n.__decorate([p.property()],l.I3SOverrides.prototype,"hasGeometryChanges",null);n.__decorate([p.property()],l.I3SOverrides.prototype,"_pendingFetchChangedObjectIds",void 0);n.__decorate([p.property()],
l.I3SOverrides.prototype,"_pendingFetchAbortController",void 0);n.__decorate([p.property()],l.I3SOverrides.prototype,"_applyGeometryOverridesTask",void 0);n.__decorate([p.property()],l.I3SOverrides.prototype,"updating",null);n.__decorate([p.property()],l.I3SOverrides.prototype,"isEmpty",null);l.I3SOverrides=n.__decorate([M.subclass("esri.views.3d.layers.i3s.I3SOverrides")],l.I3SOverrides);class R{constructor(a,c){this.objectId=a;this._remove=c;this._updates=new Map;this._isActive=!0}getAttribute(a){return this._updates.get(a)}setAttribute(a,
c){this.isActive&&this._updates.set(a,c)}remove(){this.isActive&&(this._isActive=!1,this._remove())}get isActive(){return this._isActive}}var r;(function(a){a[a.Mode=0]="Mode";a[a.SpatialReference=1]="SpatialReference"})(r||={});Object.defineProperty(l,Symbol.toStringTag,{value:"Module"})});