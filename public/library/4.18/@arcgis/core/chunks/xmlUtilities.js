/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{_ as e}from"./tslib.es6.js";import"./object.js";import{L as t,i,u as r}from"./Logger.js";import{property as n}from"../core/accessorSupport/decorators/property.js";import{create as o,all as s,resolve as a,createAbortController as l,onAbort as c}from"../core/promiseUtils.js";import u from"../core/Error.js";import"./ensureType.js";import{subclass as d}from"../core/accessorSupport/decorators/subclass.js";import{a as m}from"./JSONSupport.js";import{a as h}from"./Promise.js";import"../core/urlUtils.js";import{aliasOf as f}from"../core/accessorSupport/decorators/aliasOf.js";import"./resourceExtension.js";import p,{g as y}from"../geometry/SpatialReference.js";import g from"../request.js";import x from"../geometry/Point.js";import b from"../geometry/Extent.js";import"../geometry.js";import{rasterRendererTypes as I}from"../rasterRenderers.js";import{b as v}from"./arcgisLayerUrl.js";import{u as w}from"./commonProperties2.js";import R from"../layers/support/TileInfo.js";import _ from"../layers/support/DimensionalDefinition.js";import{b as k,a as M,c as S,R as C}from"./rasterRendererHelper.js";import{R as J,d as H}from"./RasterSymbolizer.js";import{m as D,i as j}from"./pixelUtils.js";import{g as P,a as T,p as B,d as N,b as O}from"./RawBlockCache.js";import{l as z,p as F,s as L,a as E,b as U,g as W}from"./rasterProjectionHelper.js";const $=t.getLogger("esri.layers.mixins.ImageryTileMixin"),q=t=>{let r=class extends t{constructor(){super(...arguments),this._rasterJobHandler={instance:null,refCount:0,connectionPromise:null},this.bandIds=null,this.copyright=null,this.fullExtent=null,this.interpolation="nearest",this.raster=null,this.rasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.tileInfo=null,this.symbolizer=null}set multidimensionalDefinition(e){this.raster&&(this._sliceId=this.raster.getSliceIndex(e)),this._set("multidimensionalDefinition",e)}set url(e){this._set("url",v(e,$))}set renderer(e){this._set("renderer",e),this.updateRenderer()}async updateRenderer(){if(!this.loaded)return;if(JSON.stringify(this._cachedRendererJson)===JSON.stringify(this.renderer))return;const e=this._rasterJobHandler.instance;e&&(this.symbolizer.rendererJSON=this.renderer.toJSON(),this.symbolizer.bind(),await e.updateSymbolizer(this.symbolizer),this._cachedRendererJson=this.renderer.toJSON())}async applyRenderer(e,t){const i=e&&e.pixelBlock;if(!(i&&i.pixels&&i.pixels.length>0))return null;let r;this.updateRenderer();const n=this._rasterJobHandler.instance,{bandIds:o}=this;return r=n?await n.symbolize({...e,simpleStretchParams:t,bandIds:o}):this.symbolizer.symbolize({...e,simpleStretchParams:t,bandIds:o}),r}getTileUrl(e,t,i){return"RasterTileServer"===this.raster.datasetFormat?`${this.url}/tile/${e}/${t}/${i}`:""}getCompatibleTileInfo(e,t){if(!this.loaded)return null;const i=y(e);return R.create({size:256,spatialReference:e,origin:i?{x:i.origin[0],y:i.origin[1]}:{x:t.xmin,y:t.ymax}})}getCompatibleFullExtent(e){return this.loaded?(this._compatibleFullExtent&&this._compatibleFullExtent.spatialReference.equals(e)||(this._compatibleFullExtent=this.raster.computeExtent(e)),this._compatibleFullExtent):null}async fetchTile(e,t,i,r={}){if(r.requestAsImageElement){const n=this.getTileUrl(e,t,i);return g(n,{responseType:"image",query:{sliceId:this._sliceId,_ts:r.timestamp},signal:r.signal}).then((e=>e.data))}if(await this._initJobHandler(),this.multidimensionalDefinition){const e=this._sliceId;r={multidimensionalDefinition:this.multidimensionalDefinition,sliceId:e,...r}}return"raster-shaded-relief"===this.renderer.type&&(r={buffer:{cols:1,rows:1},...r}),this.raster.fetchTile(e,t,i,r)}async fetchPixels(e,t,i,r){if(await this._initJobHandler(),this.multidimensionalDefinition){const e=this._sliceId;r={multidimensionalDefinition:this.multidimensionalDefinition,sliceId:e,...r}}return this.raster.fetchPixels(e,t,i,r)}identify(e,t={}){return this.multidimensionalDefinition&&!t.multidimensionalDefinition&&(t={...t,multidimensionalDefinition:this.multidimensionalDefinition}),this.raster.identify(e,t)}increaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount++}decreaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount--,this._rasterJobHandler.refCount<=0&&this._shutdownJobHandler()}_configDefaultSettings(){this._configDefaultInterpolation(),this._configDefaultSlice(),this._configDefaultRenderer()}_initJobHandler(){if(null!=this._rasterJobHandler.connectionPromise)return this._rasterJobHandler.connectionPromise;const e=new C;return this._rasterJobHandler.connectionPromise=e.initialize().then((()=>{this._rasterJobHandler.instance=e,this.raster.rasterJobHandler=e,this.renderer&&this.updateRenderer()})).catch((()=>null)),this._rasterJobHandler.connectionPromise}_shutdownJobHandler(){this._rasterJobHandler.instance&&this._rasterJobHandler.instance.destroy(),this._rasterJobHandler.instance=null,this._rasterJobHandler.connectionPromise=null,this._rasterJobHandler.refCount=0,this.raster.rasterJobHandler=null}_configDefaultInterpolation(){if(null==this.interpolation){var e;const t=k(this.rasterInfo,this.raster.tileType,null==(e=this.sourceJSON)?void 0:e.defaultResamplingMethod);this._set("interpolation",t)}}_configDefaultSlice(){const{multidimensionalInfo:e}=this.raster.rasterInfo;if(i(e)){if(!this.multidimensionalDefinition){const t=e.variables[0],i=[];t.dimensions.forEach((e=>{i.push(new _({variableName:t.name,dimensionName:e.name,values:e.hasRegularIntervals?e.extent[0]:e.values[0],isSlice:!0}))})),this.multidimensionalDefinition=i}this._sliceId=this.raster.getSliceIndex(this.multidimensionalDefinition)}}_configDefaultRenderer(){const e=this.raster.rasterInfo;var t;(this.bandIds||(this.bandIds=M(e)),this.renderer)||(this.renderer=S(e,{bandIds:this.bandIds,variableName:null==(t=this.multidimensionalDefinition)?void 0:t[0].variableName}));this.symbolizer?(this.symbolizer.rendererJSON=this.renderer.toJSON(),this.symbolizer.rasterInfo=e):this.symbolizer=new J({rendererJSON:this.renderer.toJSON(),rasterInfo:e}),this.symbolizer.bind()||$.warn("imagery-tile-mixin","The given renderer is not supported by the layer.")}};return e([n()],r.prototype,"_cachedRendererJson",void 0),e([n()],r.prototype,"_sliceId",void 0),e([n()],r.prototype,"_compatibleFullExtent",void 0),e([n()],r.prototype,"_rasterJobHandler",void 0),e([n()],r.prototype,"bandIds",void 0),e([n()],r.prototype,"copyright",void 0),e([n({type:b}),f("rasterInfo.extent")],r.prototype,"fullExtent",void 0),e([n()],r.prototype,"interpolation",void 0),e([n({type:[_]})],r.prototype,"multidimensionalDefinition",null),e([n()],r.prototype,"raster",void 0),e([n({readOnly:!0}),f("raster.rasterInfo")],r.prototype,"rasterInfo",void 0),e([n()],r.prototype,"sourceJSON",void 0),e([n({type:p}),f("rasterInfo.spatialReference")],r.prototype,"spatialReference",void 0),e([n({type:R,dependsOn:["rasterInfo"]}),f("rasterInfo.storageInfo.tileInfo")],r.prototype,"tileInfo",void 0),e([n(w)],r.prototype,"url",null),e([n({types:I})],r.prototype,"renderer",null),e([n()],r.prototype,"symbolizer",void 0),r=e([d("esri.layers.ImageryTileMixin")],r),r};let A=class extends m{constructor(){super(...arguments),this.blockWidth=void 0,this.blockHeight=void 0,this.compression=null,this.origin=null,this.firstPyramidLevel=null,this.maximumPyramidLevel=null,this.pyramidScalingFactor=2,this.pyramidBlockWidth=null,this.pyramidBlockHeight=null,this.isVirtualTileInfo=!1,this.tileInfo=null,this.blockBoundary=null}};e([n({type:Number,json:{write:!0}})],A.prototype,"blockWidth",void 0),e([n({type:Number,json:{write:!0}})],A.prototype,"blockHeight",void 0),e([n({type:String,json:{write:!0}})],A.prototype,"compression",void 0),e([n({type:x,json:{write:!0}})],A.prototype,"origin",void 0),e([n({type:Number,json:{write:!0}})],A.prototype,"firstPyramidLevel",void 0),e([n({type:Number,json:{write:!0}})],A.prototype,"maximumPyramidLevel",void 0),e([n()],A.prototype,"pyramidScalingFactor",void 0),e([n({type:Number,json:{write:!0}})],A.prototype,"pyramidBlockWidth",void 0),e([n({type:Number,json:{write:!0}})],A.prototype,"pyramidBlockHeight",void 0),e([n({type:Boolean,json:{write:!0}})],A.prototype,"isVirtualTileInfo",void 0),e([n({json:{write:!0}})],A.prototype,"tileInfo",void 0),e([n()],A.prototype,"blockBoundary",void 0),A=e([d("esri.layers.support.RasterStorageInfo")],A);var V=A;let Y=class extends(h(m)){constructor(){super(...arguments),this.rasterJobHandler=null,this.datasetName=null,this.datasetFormat=null,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}async init(){const e=z();this.addResolvingPromise(e),await this.when()}normalizeCtorArgs(e){return e&&e.ioConfig&&(e={...e,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:R.create(),...e.ioConfig}}),e}set url(e){this._set("url",v(e,t.getLogger(this.declaredClass)))}async open(e){throw new u("BaseRaster:open-not-implemented","open() is not implemented")}async fetchTile(e,t,r,n={}){var o;const{tileInfo:s}=n,a=s.lodAt(e),l=new x({x:a.resolution,y:a.resolution,spatialReference:s.spatialReference}),c=this.getTileExtent(l,t,r,s);return null!=(o=n.multidimensionalDefinition)&&o.length&&i(this.rasterInfo.multidimensionalInfo)&&null==n.sliceId&&(n={...n,sliceId:this.getSliceIndex(n.multidimensionalDefinition)||0}),this.fetchPixels(c,s.size[0],s.size[1],n)}async identify(e,t={}){const{spatialReference:r,extent:n}=this.rasterInfo,{datumTransformation:o}=t,s=F(e,r,o);if(!n.intersects(s))return{location:s,value:null};let a=0;if(t.srcResolution){a=L(t.srcResolution,this.rasterInfo,this.ioConfig.sampling).pyramidLevel}else if(a=await this.computeBestPyramidLevelForLocation(e,t),null==a)return{location:s,value:null};const l=this.identifyPixelLocation(s,a,null);if(null===l)return{location:s,value:null};const{row:c,col:u,rowOffset:d,colOffset:m}=l,h=P(this.url,t.sliceId),f=`${a}/${c}/${u}`;let p=T(h,null,f);i(p)||(p=this.fetchRawTile(a,c,u,t),B(h,null,f,p));const y=await p;if(!(y&&y.pixels&&y.pixels.length>0))return{location:s,value:null};const g=d*this.rasterInfo.storageInfo.blockHeight+m;return{location:s,value:!y.mask||y.mask[g]?y.pixels.map((e=>e[g])):null,pyramidLevel:a}}async fetchPixels(e,t,i,n={}){const o=e.clone().normalize();e=o[0];const s=this.rasterInfo.spatialReference,a=!e.spatialReference.equals(s),{datumTransformation:l}=n,c=new x({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/i,spatialReference:e.spatialReference}),u=n.srcResolution||(a?E(c,s,e,l):c);if(!u)return null;const{pyramidLevel:d,pyramidResolution:m,excessiveReading:h}=L(u,this.rasterInfo,this.ioConfig.sampling);if(h)return null;const f=this.rasterInfo.storageInfo;let p=a?U(e,s,l):e;const y=r(this.rasterInfo.transform);if(y&&(p=y.inverseTransform(p)),null==p)return null;const g={x:Math.floor((p.xmin-f.origin.x)/m.x+.1),y:Math.floor((f.origin.y-p.ymax)/m.y+.1)},b=Math.ceil((p.xmax-p.xmin)/m.x-.1),I=Math.ceil((p.ymax-p.ymin)/m.y-.1);if(b/t>8||I/i>8)return null;const v=await this.fetchRawPixels(d,g,{width:b,height:I},n);if(!v)return null;const w=d>0?f.pyramidBlockWidth:f.blockWidth,R=d>0?f.pyramidBlockHeight:f.blockHeight;if(!a&&1===v.pixelBlocks.length&&w===t&&R===i&&u.x===c.x&&u.y===c.y)return{extent:e,srcExtent:p,pixelBlock:v.pixelBlocks[0],transformGrid:null};const _=W(e,v.extent,c,l,y);let k;const M=!n.requestRawData,S={rows:_.spacing[0],cols:_.spacing[1]},{pixelBlocks:C,mosaicSize:J,isPartiallyFilled:H}=v;if(this.rasterJobHandler)k=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:C,srcMosaicSize:J,destDimension:M?{width:t,height:i}:null,coefs:M?_.coefficients:null,sampleSpacing:M?S:null,interpolation:n.interpolation},n);else{const e=D(C,J);k=M?j(e,{width:t,height:i},_.coefficients,S,n.interpolation):e}return{srcExtent:p,pixelBlock:k,transformGrid:_,extent:e,isPartiallyFilled:H}}async fetchRawPixels(e,t,i,r){const{origin:n,blockBoundary:a}=this.rasterInfo.storageInfo,l=e>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,c=e>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight;let{x:u,y:d}=t,{width:m,height:h}=i;r.buffer&&(u-=r.buffer.cols,d-=r.buffer.rows,m+=2*r.buffer.cols,h+=2*r.buffer.rows);const f=Math.floor(u/l),p=Math.floor(d/c),y=Math.floor((u+m-1)/l),g=Math.floor((d+h-1)/c),x=a[e];if(!x)return null;const{minRow:I,minCol:v,maxCol:w,maxRow:R}=x;if(g<I||y<v||p>R||f>w)return null;const _=[];let k,M=!1;for(let t=p;t<=g;t++)for(let i=f;i<=y;i++)t>=I&&i>=v&&R>=t&&w>=i?(k=this._fetchRawTile(e,t,i,r),this.ioConfig.allowPartialFill&&(k=o((e=>{k.then((t=>e(t))).catch((()=>{M=!0,e(null)}))}))),_.push(k)):_.push(null);if(0===_.length)return null;const S=await s(_),C={height:(g-p+1)*l,width:(y-f+1)*c},{nativePixelSize:J,spatialReference:H}=this.rasterInfo,D=J.x*Math.pow(2,e),j=J.y*Math.pow(2,e);return{extent:new b({xmin:n.x+f*l*D,xmax:n.x+(y+1)*l*D,ymin:n.y-(g+1)*c*j,ymax:n.y-p*c*j,spatialReference:H}),pixelBlocks:S,mosaicSize:C,isPartiallyFilled:M}}async fetchRawTile(e,t,i,r){throw new u("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(e){return U(this.rasterInfo.extent,e)}decodePixelBlock(e,t){return!this.rasterJobHandler||t.useCanvas?H(e,t):this.rasterJobHandler.decode({data:e,options:t})}async request(e,t,i){var r,n;const{customFetchParameters:o}=this.ioConfig,{range:s,query:a,headers:l}=t;i=null!=(r=null!=(n=i)?n:t.retryCount)?r:this.ioConfig.retryCount;const c=s?{Range:`bytes=${s.from}-${s.to}`}:null;try{return await g(e,{...t,query:{...a,...o},headers:{...l,...c}})}catch(r){if(i>0)return i--,this.request(e,t,i);throw r}}getSliceIndex(e){const{multidimensionalInfo:t}=this.rasterInfo;if(!i(t)||null==e||!e.length)return null;let r=0;const n=e[0].variableName;for(let i=0;i<t.variables.length;i++){const o=t.variables[i],s=o.dimensions;if(o.name!==n){r+=s.map((e=>this._getDimensionValuesCount(e))).reduce(((e,t)=>e+t));break}const a=s.map((e=>this._getDimensionValuesCount(e))),l=s.length;for(let t=0;t<l;t++){const i=e.filter((e=>e.dimensionName===s[t].name))[0];if(null==i)return null;const n=Array.isArray(i.values[0])?i.values[0][0]:i.values[0],o=this._getIndexFromDimensions(n,s[t]);if(-1===o)return null;a.shift(),r+=t===l-1?o:o*a.reduce(((e,t)=>e+t))}}return r}updateTileInfo(){const{storageInfo:e,spatialReference:t,extent:i,pixelSize:r}=this.rasterInfo;if(!e.tileInfo){const n=[],o=e.maximumPyramidLevel||0;let s=Math.max(r.x,r.y),a=1/.0254*96*s;for(let e=0;e<=o;e++)n.push({level:o-e,resolution:s,scale:a}),s*=2,a*=2;const l=new x({x:i.xmin,y:i.ymax,spatialReference:t});e.tileInfo=new R({origin:l,size:[e.blockWidth,e.blockHeight],spatialReference:t,lods:n}),e.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(e,t=512,i=512,r){const{width:n,height:o,nativeExtent:s,pixelSize:a,spatialReference:l}=e,c=new x({x:s.xmin,y:s.ymax,spatialReference:l});null==r&&(r=Math.max(0,Math.round(Math.log(Math.max(n,o))/Math.LN2-8)));const u=this._computeBlockBoundary(s,a,r,512,512);e.storageInfo=new V({blockWidth:t,blockHeight:i,pyramidBlockWidth:t,pyramidBlockHeight:i,origin:c,firstPyramidLevel:1,maximumPyramidLevel:r,blockBoundary:u})}async computeBestPyramidLevelForLocation(e,t={}){return 0}identifyPixelLocation(e,t,i){const{spatialReference:r,pixelSize:n,extent:o}=this.rasterInfo,{blockWidth:s,blockHeight:a,maximumPyramidLevel:l,pyramidScalingFactor:c,origin:u}=this.rasterInfo.storageInfo,d=F(e,r,i);if(!o.intersects(d))return null;if(t<0||t>l)return null;const m=Math.pow(c,t),h=m*n.x,f=m*n.y,p=(u.y-d.y)/f/a,y=(d.x-u.x)/h/s,g=Math.min(a-1,Math.floor((p-Math.floor(p))*a)),x=Math.min(s-1,Math.floor((y-Math.floor(y))*s));return{pyramidLevel:t,row:Math.floor(p),col:Math.floor(y),rowOffset:g,colOffset:x,srcLocation:d}}getTileExtent(e,t,i,r){const{origin:n,spatialReference:o}=r,s=r.size[0],a=r.size[1],l=n.x+i*s*e.x,c=l+s*e.x,u=n.y-t*a*e.y,d=u-a*e.y;return new b({xmin:l,xmax:c,ymin:d,ymax:u,spatialReference:o})}_computeBlockBoundary(e,t,i,r,n){let{x:o,y:s}=t;const a=e.xmin,l=e.ymax,c=[{minCol:Math.floor((e.xmin-a+.1*o)/r/o),maxCol:Math.floor((e.xmax-a-.1*o)/r/o),minRow:Math.floor((l-e.ymax+.1*s)/n/s),maxRow:Math.floor((l-e.ymin-.1*s)/n/s)}];if(i>0)for(let t=0;t<i;t++)o*=2,s*=2,c.push({minCol:Math.floor((e.xmin-a+.1*o)/r/o),maxCol:Math.floor((e.xmax-a-.1*o)/r/o),minRow:Math.floor((l-e.ymax+.1*s)/n/o),maxRow:Math.floor((l-e.ymin-.1*s)/n/o)});return c}_fetchRawTile(e,t,r,n){const o=this.rasterInfo.storageInfo.blockBoundary[e];if(!o)return a(null);const{minRow:s,minCol:u,maxCol:d,maxRow:m}=o;if(t<s||r<u||t>m||r>d)return a(null);const h=P(this.url,n.sliceId),f=`${e}/${t}/${r}`;let p=T(h,n.registryId,f);if(!i(p)){const i=l();p=this.fetchRawTile(e,t,r,{...n,signal:i.signal}),B(h,n.registryId,f,p,i),p.catch((()=>{N(h,n.registryId,f)}))}return n.signal&&c(n,(()=>{O(h,n.registryId,f)})),p}_getIndexFromDimensions(e,t){const{extent:i,interval:r,unit:n,values:o}=t;if(null!=o&&o.length)return Array.isArray(o[0])?o.findIndex((t=>t[0]<=e&&t[1]>=e)):o.indexOf(e);if(e>i[1])return-1;const s=i[0];let a=-1;if("ISO8601"===n){var l;switch((null==(l=t.intervalUnit)?void 0:l.toLowerCase())||"seconds"){case"seconds":a=Math.round((e-s)/1e3/r);break;case"minutes":a=Math.round((e-s)/6e4/r);break;case"hours":a=Math.round((e-s)/36e5/r);break;case"days":a=Math.round((e-s)/864e5/r);break;case"years":a=Math.round((new Date(e).getUTCFullYear()-new Date(s).getUTCFullYear())/r);break;case"decades":a=Math.round((new Date(e).getUTCFullYear()-new Date(s).getUTCFullYear())/10/r)}return a}return Math.round((e-s)/r)}_getDimensionValuesCount(e){const{extent:t,interval:i,unit:r,values:n}=e;let o=(null==n?void 0:n.length)||0;if(o)return o;const s=t[0];if(0===o&&"ISO8601"===r){var a;switch((null==(a=e.intervalUnit)?void 0:a.toLowerCase())||"seconds"){case"seconds":o=Math.round((t[1]-t[0])/1e3/i);break;case"minutes":o=Math.round((t[1]-t[0])/6e4/i);break;case"hours":o=Math.round((t[1]-t[0])/36e5/i);break;case"days":o=Math.round((t[1]-t[0])/864e5/i);break;case"years":o=Math.round((new Date(t[1]).getUTCFullYear()-new Date(s).getUTCFullYear())/i);break;case"decades":o=Math.round((new Date(t[1]).getUTCFullYear()-new Date(s).getUTCFullYear())/10/i)}return o}return Math.round((t[1]-t[0])/i)}};e([n(w)],Y.prototype,"url",null),e([n({type:String,json:{write:!0}})],Y.prototype,"datasetName",void 0),e([n({type:String,json:{write:!0}})],Y.prototype,"datasetFormat",void 0),e([n()],Y.prototype,"rasterInfo",void 0),e([n()],Y.prototype,"ioConfig",void 0),e([n()],Y.prototype,"sourceJSON",void 0),Y=e([d("esri.layers.support.rasterDatasets.BaseRaster")],Y);var G=Y;function K(e,t){if(!e||!t)return[];let i=t;t.indexOf("/")>-1?(i=t.slice(0,t.indexOf("/")),t=t.slice(t.indexOf("/")+1)):t="";const r=[];if(t){const n=K(e,i);for(let e=0;e<n.length;e++){K(n[e],t).forEach((e=>r.push(e)))}return r}const n=e.getElementsByTagNameNS("*",i);if(!n||0===n.length)return[];for(let e=0;e<n.length;e++)r.push(n[e]||n.item[e]);return r}function Q(e,t){if(!e||!t)return null;let i=t;t.indexOf("/")>-1?(i=t.slice(0,t.indexOf("/")),t=t.slice(t.indexOf("/")+1)):t="";const r=K(e,i);return r.length>0?t?Q(r[0],t):r[0]:null}function X(e,t=null){const i=t?Q(e,t):e;let r;return i?(r=i.textContent||i.nodeValue,r?r.trim():null):null}function Z(e,t){const i=K(e,t),r=[];let n;for(let e=0;e<i.length;e++)n=i[e].textContent||i[e].nodeValue,n&&(n=n.trim(),""!==n&&r.push(n));return r}function ee(e,t=null){return X(e,t).split(" ").map((e=>Number(e)))}function te(e,t){return Z(e,t).map((e=>Number(e)))}function ie(e,t){const i=X(e,t);return Number(i)}function re(e,t){var i;const r=null==e||null==(i=e.nodeName)?void 0:i.toLowerCase(),n=t.toLowerCase();return r.slice(r.lastIndexOf(":")+1)===n}function ne(e){return e.nodeName.slice(e.nodeName.lastIndexOf(":")+1)}export{G as B,q as I,V as R,K as a,Q as b,ie as c,te as d,ee as e,Z as f,X as g,ne as h,re as i};
