/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{_ as e}from"./tslib.es6.js";import"./object.js";import{i as t,L as a,u as i}from"./Logger.js";import{property as r}from"../core/accessorSupport/decorators/property.js";import{p as n}from"../core/scheduling.js";import{throwIfAborted as s,resolve as o,reject as l,createAbortController as u,timeout as c,eachAlways as m}from"../core/promiseUtils.js";import d from"../core/Error.js";import"./ensureType.js";import{subclass as p}from"../core/accessorSupport/decorators/subclass.js";import{a as h}from"./JSONSupport.js";import{L as f}from"./Loadable.js";import"../core/urlUtils.js";import"./resourceExtension.js";import{m as y,g}from"../geometry/SpatialReference.js";import F from"../request.js";import v from"../geometry/Point.js";import"../geometry.js";import{l as x}from"./arcadeOnDemand.js";import{isNumericField as w,numericTypes as S,isDateField as _,getField as b}from"../layers/support/fieldUtils.js";import V from"../Graphic.js";import{fromJSON as z}from"../renderers/support/jsonUtils.js";import{whenFalseOnce as E}from"../core/watchUtils.js";import{d as T}from"./arcgisLayerUrl.js";import q from"../tasks/support/FeatureSet.js";import{D as L}from"./DataLayerSource.js";import M,{Q as C}from"../tasks/support/Query.js";import I from"../tasks/support/StatisticDefinition.js";import{C as k,a as j}from"./ClassBreaksDefinition.js";import B from"../tasks/Task.js";import D from"../tasks/QueryTask.js";import{g as Q,i as N,c as R,a as A}from"./utils5.js";import{t as O,q as U}from"./quantizationUtils.js";import{g as G,a as P,n as W}from"./predominanceUtils.js";import{c as H,a as J}from"./heatmapUtils.js";function $(e,t){return Number(e.toFixed(t))}function Y(e){const{normalizationTotal:t}=e;return{classBreaks:function(e){const t=e.definition,{classificationMethod:a,breakCount:i,normalizationType:r}=t,n=[];let s=e.values;if(0===s.length)return[];s=s.sort(((e,t)=>e-t));const o=s[0],l=s[s.length-1];if("equal-interval"===a)if(s.length>=i){const e=(l-o)/i;let t=o;for(let a=1;a<i;a++){const i=$(o+a*e,6);n.push({minValue:t,maxValue:i,label:Z(t,i,r)}),t=i}n.push({minValue:t,maxValue:l,label:Z(t,l,r)})}else s.forEach((e=>{n.push({minValue:e,maxValue:e,label:Z(e,e,r)})}));else if("natural-breaks"===a){const e=X(s),t=function(e,t,a){const i=e.length,r=[];a>i&&(a=i);for(let e=0;e<a;e++)r.push(Math.round(e*i/a-1));r.push(i-1);let n=K(r,e,t,a);(function(e,t,a,i,r,n){let s=0,o=0,l=0,u=0,c=!0;for(let m=0;m<2&&c;m++){0===m&&(c=!1);for(let m=0;m<n-1;m++)for(;a[m+1]+1!==a[m+2];){a[m+1]=a[m+1]+1;const n=ee(m,a,i,r);l=n.sbMean,s=n.sbSdcm;const d=ee(m+1,a,i,r);if(u=d.sbMean,o=d.sbSdcm,!(s+o<t[m]+t[m+1])){a[m+1]=a[m+1]-1;break}t[m]=s,t[m+1]=o,e[m]=l,e[m+1]=u,c=!0}for(let m=n-1;m>0;m--)for(;a[m]!==a[m-1]+1;){a[m]=a[m]-1;const n=ee(m-1,a,i,r);l=n.sbMean,s=n.sbSdcm;const d=ee(m,a,i,r);if(u=d.sbMean,o=d.sbSdcm,!(s+o<t[m-1]+t[m])){a[m]=a[m]+1;break}t[m-1]=s,t[m]=o,e[m-1]=l,e[m]=u,c=!0}}return c})(n.mean,n.sdcm,r,e,t,a)&&(n=K(r,e,t,a));return r}(e.uniqueValues,e.valueFrequency,i);let a=o;for(let s=1;s<i;s++)if(e.uniqueValues.length>s){const i=$(e.uniqueValues[t[s]],6);n.push({minValue:a,maxValue:i,label:Z(a,i,r)}),a=i}n.push({minValue:a,maxValue:l,label:Z(a,l,r)})}else if("quantile"===a)if(s.length>=i&&o!==l){let e=o,t=Math.ceil(s.length/i),a=0;for(let o=1;o<i;o++){let l=t+a-1;l>s.length&&(l=s.length-1),l<0&&(l=0),n.push({minValue:e,maxValue:s[l],label:Z(e,s[l],r)}),e=s[l],a+=t,t=Math.ceil((s.length-a)/(i-o))}n.push({minValue:e,maxValue:l,label:Z(e,l,r)})}else{let e=-1;for(let t=0;t<s.length;t++){const a=s[t];a!==e&&(e=a,n.push({minValue:e,maxValue:a,label:Z(e,a,r)}),e=a)}}else if("standard-deviation"===a){const e=function(e){let t=0;for(let a=0;a<e.length;a++)t+=e[a];return t/=e.length,t}(s),t=function(e,t){let a=0;for(let i=0;i<e.length;i++){const r=e[i];a+=(r-t)*(r-t)}a/=e.length;return Math.sqrt(a)}(s,e);if(0===t)n.push({minValue:s[0],maxValue:s[0],label:Z(s[0],s[0],r)});else{const a=function(e,t,a,i,r){const n=Math.max(i-e,t-i);let s=n/r/a;s=s>=1?1:s>=.5?.5:.25;return s}(o,l,i,e,t)*t;let s=0,u=o;for(let t=i;t>=1;t--){const i=$(e-(t-.5)*a,6);n.push({minValue:u,maxValue:i,label:Z(u,i,r)}),u=i,s++}let c=$(e+.5*a,6);n.push({minValue:u,maxValue:c,label:Z(u,c,r)}),u=c,s++;for(let t=1;t<=i;t++)c=s===2*i?l:$(e+(t+.5)*a,6),n.push({minValue:u,maxValue:c,label:Z(u,c,r)}),u=c,s++}}return n}(e),normalizationTotal:t}}function Z(e,t,a){let i=null;return i=e===t?a&&"percent-of-total"===a?e+"%":e.toString():a&&"percent-of-total"===a?e+"% - "+t+"%":e+" - "+t,i}function X(e){const t=[],a=[];let i=Number.MIN_VALUE,r=1,n=-1;for(let s=0;s<e.length;s++){const o=e[s];o===i?(r++,a[n]=r):null!==o&&(t.push(o),i=o,r=1,a.push(r),n++)}return{uniqueValues:t,valueFrequency:a}}function K(e,t,a,i){let r=[],n=[],s=[],o=0;const l=[],u=[];for(let r=0;r<i;r++){const i=ee(r,e,t,a);l.push(i.sbMean),u.push(i.sbSdcm),o+=u[r]}let c,m=o,d=!0;for(;d||o<m;){d=!1,r=[];for(let t=0;t<i;t++)r.push(e[t]);for(let a=0;a<i;a++)for(let r=e[a]+1;r<=e[a+1];r++)if(c=t[r],a>0&&r!==e[a+1]&&Math.abs(c-l[a])>Math.abs(c-l[a-1]))e[a]=r;else if(a<i-1&&e[a]!==r-1&&Math.abs(c-l[a])>Math.abs(c-l[a+1])){e[a+1]=r-1;break}m=o,o=0,n=[],s=[];for(let r=0;r<i;r++){n.push(l[r]),s.push(u[r]);const i=ee(r,e,t,a);l[r]=i.sbMean,u[r]=i.sbSdcm,o+=u[r]}}if(o>m){for(let t=0;t<i;t++)e[t]=r[t],l[t]=n[t],u[t]=s[t];o=m}return{mean:l,sdcm:u}}function ee(e,t,a,i){let r=0,n=0;for(let s=t[e]+1;s<=t[e+1];s++){const e=i[s];r+=a[s]*e,n+=e}n<=0&&console.log("Exception in Natural Breaks calculation");const s=r/n;let o=0;for(let r=t[e]+1;r<=t[e+1];r++)o+=i[r]*Math.pow(a[r]-s,2);return{sbMean:s,sbSdcm:o}}function te(e){const t=e.field,a=e.normalizationType,i=e.normalizationField;let r;return"log"===a?r="(NOT "+t+" = 0)":"field"===a&&(r="(NOT "+i+" = 0)"),r}function ae(e,t){return new d(e,t)}function ie(e,t,a){const i=null!=t?e+" >= "+t:"",r=null!=a?e+" <= "+a:"";let n="";return n=i&&r?se(i,r):i||r,n?"("+n+")":""}function re(e,t,a,i){let r=null;return t?t.name!==e.objectIdField&&-1!==i.indexOf(t.type)||(r=ae(a,"'field' should be one of these types: "+i.join(","))):r=ae(a,"'field' is not defined in the layer schema"),r}function ne(e,t,a){let i;return t?t.name!==e.objectIdField&&w(t)||(i=ae(a,"'field' should be one of these numeric types: "+S.join(","))):i=ae(a,"'field' is not defined in the layer schema"),i}function se(e,a){let i=t(e)?e:"";return t(a)&&a&&(i=i?"("+i+") AND ("+a+")":a),i}function oe(e,t,a){const i=function(e){const t=e.layer;return e.fields.filter((e=>!t.getField(e)))}({layer:e,fields:t});if(i.length)return ae(a,"Unknown fields: "+i.join(", ")+". You can only use fields defined in the layer schema");const r=function(e){const t=e.layer;return e.fields.filter((e=>{const a=t.getFieldUsageInfo(e);return!a||!a.supportsStatistics}))}({layer:e,fields:t});return r.length?ae(a,"Unsupported fields: "+r.join(", ")+". You can only use fields that can be fetched i.e. AdapterFieldUsageInfo.supportsStatistics must be true"):void 0}let le=class extends f{constructor(e){super(e)}};e([r({constructOnly:!0})],le.prototype,"layer",void 0),e([r()],le.prototype,"geometryType",void 0),e([r()],le.prototype,"objectIdField",void 0),e([r()],le.prototype,"supportsSQLExpression",void 0),e([r()],le.prototype,"hasQueryEngine",void 0),e([r()],le.prototype,"minScale",void 0),e([r()],le.prototype,"maxScale",void 0),e([r()],le.prototype,"fullExtent",void 0),le=e([p("esri.smartMapping.support.adapters.LayerAdapter")],le);var ue=le;const ce=/_value$/i,me=/\s*(\+|-)?((\d+(\.\d+)?)|(\.\d+))\s*/gi,de=Math.LOG10E,pe=["min","max","avg","stddev","count","sum","variance"];let he=null;async function fe(e,t,a){const i=[];if(t)for(const r of t){const t=e.getField(r);"availableFields"in a&&-1===a.availableFields.indexOf(t.name)&&i.push(t.name)}return i}function ye(e,t){const a=e&&e.features,i=a&&a[0]&&a[0].attributes,r={};for(const e in i)r[e.replace(ce,"").toLowerCase()]=i[e];return r.min===r.max&&null!=r.min&&null==r.stddev&&(r.stddev=r.variance=0),t&&(["min","max","avg","stddev","sum","variance"].forEach((e=>{null!=r[e]&&(r[e]=Math.ceil(r[e]))})),r.min===r.max&&null!=r.min&&(r.avg=r.min,r.stddev=r.variance=0)),r}async function ge(e,t,a){let i=await ve(e,t);i=Fe(i,e.minValue,e.maxValue);const r=function(e,t){let a=Number.POSITIVE_INFINITY,i=Number.NEGATIVE_INFINITY,r=null,n=null,s=null,o=null;for(const t of e)r+=t,a=Math.min(a,t),i=Math.max(i,t);const l=e.length;if(l){n=r/l;let a=0;for(const t of e)a+=Math.pow(t-n,2);o=t?l>1?a/(l-1):0:l>0?a/l:0,s=Math.sqrt(o)}else a=null,i=null;return{avg:n,count:l,max:i,min:a,stddev:s,sum:r,variance:o}}(i,!e.normalizationType);return a&&["avg","stddev","variance"].forEach((e=>{null!=r[e]&&(r[e]=Math.ceil(r[e]))})),r}function Fe(e,t,a){return t=null==t?-1/0:t,a=null==a?1/0:a,e.filter((e=>null!=e&&De(e)&&e>=t&&e<=a))}async function ve(e,t){const a=e.field,i="function"==typeof a,r=e.valueExpression,n=e.normalizationType,s=e.normalizationField,o=e.normalizationTotal,l=[],u=e.view;let c=null,m=null;if(r){if(!he){const{arcadeUtils:e}=await x();he=e}c=he.createFunction(r),m=u&&he.getViewInfo({viewingMode:"2d"===u.type?"map":u.viewingMode,scale:u.scale,spatialReference:u.spatialReference})}return t?(t.forEach((e=>{const t=e.attributes;let u;if(r){const t=he.createExecContext(e,m);u=he.executeFunction(c,t)}else i?u=a.call(null,e):t&&(u=t[a]);if(n&&null!=u&&De(u)){const e=t&&parseFloat(t[s]);"log"===n&&0!==u?u=Math.log(u)*Math.LOG10E:"percent-of-total"===n&&De(o)&&0!==o?u=u/o*100:"field"===n&&De(e)&&0!==e&&(u/=e)}l.push(u)})),l):l}function xe(e){let t;for(t in e)pe.indexOf(t)>-1&&(De(e[t])||(e[t]=null));return e}function we(e){const t=e.field,a=e.classificationMethod||"equal-interval",i=e.normalizationType,r=e.normalizationField,n=new k;return n.classificationField=t,n.breakCount=e.breakCount,n.classificationMethod=a,n.standardDeviationInterval="standard-deviation"===a?e.standardDeviationInterval||1:void 0,n.normalizationType=i,n.normalizationField="field"===i?r:void 0,n}async function Se(e,t){const a=e.normalizationTotal,i=we({field:e.field,normalizationType:e.normalizationType,normalizationField:e.normalizationField,classificationMethod:e.classificationMethod,standardDeviationInterval:e.standardDeviationInterval,breakCount:e.numClasses||5});let r=await ve(e,t);r=Fe(r,e.minValue,e.maxValue);return _e(e,Y({definition:i,values:r,normalizationTotal:a}))}function _e(e,t){let a=t.classBreaks;const i=a.length,r=a[0].minValue,n=a[i-1].maxValue,s="standard-deviation"===e.classificationMethod,o=me;return a=a.map((e=>{const t=e.label,a={minValue:e.minValue,maxValue:e.maxValue,label:t};if(s&&t){const e=t.match(o).map((e=>+e.trim()));2===e.length?(a.minStdDev=e[0],a.maxStdDev=e[1],e[0]<0&&e[1]>0&&(a.hasAvg=!0)):1===e.length&&(t.indexOf("<")>-1?(a.minStdDev=null,a.maxStdDev=e[0]):t.indexOf(">")>-1&&(a.minStdDev=e[0],a.maxStdDev=null))}return a})),{minValue:r,maxValue:n,classBreakInfos:a,normalizationTotal:t.normalizationTotal}}function be(e,t,a){const i=(t-e)/a,r=[];let n,s=e;for(let e=1;e<=a;e++)n=s+i,n=Number(n.toFixed(16)),r.push([s,n]),s=n;return r}function Ve(e){const t=[],a=e.classBreaks,i=a[0].minValue,r=a[a.length-1].maxValue;a.forEach((e=>{t.push([e.minValue,e.maxValue])}));const n={field:e.field,normalizationType:e.normalizationType,normalizationField:e.normalizationField,normalizationTotal:e.normalizationTotal,layer:e.layer};return{min:i,max:r,intervals:t,sqlExpr:ze(n),excludeZerosExpr:e.where,normTotal:e.normalizationTotal}}function ze(e){const{field:t,normalizationType:a,normalizationField:i,normalizationTotal:r,layer:n}=e,s=N(n,t);let o=t;return"percent-of-total"===a?o=`((${s?R(t):t} / ${r}) * 100)`:"log"===a?o=`(log(${t}) * ${de})`:"field"===a&&(o=`(${s?R(t):t} / ${i})`),o}async function Ee(e,t,a){const{min:i,max:r,normTotal:n}=t,s=e.numBins||10,o=t.intervals||be(i,r,s),l=o.map(((e,t)=>({minValue:o[t][0],maxValue:o[t][1],count:0}))),u=await ve(e,a);for(const e of u)if(null!=e&&e>=i&&e<=r){const t=Te(o,e);t>-1&&l[t].count++}return{bins:l,minValue:i,maxValue:r,normalizationTotal:n}}function Te(e,t){let a=-1;for(let i=e.length-1;i>=0;i--){if(t>=e[i][0]){a=i;break}}return a}function qe(e,t){let a;if(t=t.toLowerCase(),e)for(const i in e)if(i.toLowerCase()!==t){a=e[i];break}return a}function Le(e,t){let a;if(t=t.toLowerCase(),e)for(const i in e)if(i.toLowerCase()===t){a=e[i];break}return a}function Me(e,t,a,i,r){const n={},s="countOFExpr";e&&e.features&&e.features.forEach((e=>{const t=e.attributes,a=qe(t,s),i=Le(t,s);0!==a&&(n[a]=i)}));const o=[];return be(t,a,i).forEach(((e,t)=>{const a=(t+1).toString();o.push({minValue:e[0],maxValue:e[1],count:n.hasOwnProperty(a)?n[a]:0})})),{bins:o,minValue:t,maxValue:a,normalizationTotal:r}}function Ce(e,t,a,i,r){const n=e&&e.features,l="countOF"+(a||"Expr"),u={};let c=!1;if(n.forEach((e=>{const t=e.attributes,i=Le(t,l);let r=a?Le(t,a):qe(t,l);null===r&&0===i&&(c=!0),(null==r||"string"==typeof r&&""===r.trim())&&(r=null),null==u[r]?u[r]={count:i,data:r}:u[r].count=u[r].count+i})),a&&c){const e=a+" is NULL";return t.queryFeatureCount(e,r).then((e=>(e=e||0,u.null.count=u.null.count+e,Ie(u,i)))).catch((()=>(s(r),Ie(u,i))))}return o(Ie(u,i))}function Ie(e,t){if(t)for(const a in e)e[a].label=t[a];return{count:e}}function ke(e,t,a){const i=e.count,r=[];if(a&&t&&"coded-value"===t.type){t.codedValues.forEach((e=>{const t=e.code;i.hasOwnProperty(t)||(i[t]={data:t,count:0})}))}for(const e in i){const t=i[e];r.push({value:t.data,count:t.count,label:t.label})}return{uniqueValueInfos:r}}async function je(e,t,a){const i=await ve(e,t),r={};for(let e of i)(null==e||"string"==typeof e&&""===e.trim())&&(e=null),null==r[e]?r[e]={count:1,data:e}:r[e].count++;return ke({count:r},a,e.returnAllCodedValues)}function Be(e,t){return Q(e,new Date(0),t,"milliseconds").sqlExpression}function De(e){return"number"==typeof e&&!isNaN(e)&&e!==1/0&&e!==-1/0}let Qe=class extends B{constructor(e){super(e),this._field=null,this.checkValueRange=null,this.gdbVersion=null,this.source=null}get parsedUrl(){const e=this._parseUrl(this.url);return e.path+="/generateRenderer",e}execute(e,t){const{classificationDefinition:a}=e,i={...e.toJSON(),f:"json"};if("esri.tasks.support.ClassBreaksDefinition"===a.declaredClass?this._field=a.classificationField:this._field=a.attributeField,this.source){var r;const e={source:null==(r=this.source)?void 0:r.toJSON()};i.layer=JSON.stringify(e)}this.gdbVersion&&(i.gdbVersion=this.gdbVersion),i.classificationDef&&(i.classificationDef=JSON.stringify(i.classificationDef));let n={query:i};return(this.requestOptions||t)&&(n={...this.requestOptions,...t,...n}),F(this.parsedUrl.path,n).then((e=>this._handleExecuteResponse(e)))}_handleExecuteResponse(e){const t=e&&e.data;if(!t)return;if(!this.checkValueRange){const e=this._processRendererJSON(t);return o(e)}const a=new D({url:this.url}),i=new I({statisticType:"min",onStatisticField:this._field}),r=new I({statisticType:"max",onStatisticField:this._field}),n=new M({outStatistics:[i,r]});return a.execute(n).then((e=>{const a=e.features[0].attributes;let i=null,r=null;for(const e in a)0===e.toLowerCase().indexOf("min")?i=a[e]:r=a[e];return this._processRendererJSON(t,i,r)}))}_processRendererJSON(e,t,a){if("classBreaks"===e.type){const i=z(e);return{classBreaks:i.classBreakInfos.map(((e,r)=>(0===r&&null!=t&&(e.minValue=t),r===i.classBreakInfos.length-1&&null!=a&&(e.maxValue=a),{minValue:e.minValue,maxValue:e.maxValue,label:e.label}))),normalizationTotal:i.normalizationTotal}}return{uniqueValues:e.uniqueValueInfos.map(((i,r)=>(0===r&&null!=t&&(i.value=t),r===e.uniqueValueInfos.length-1&&null!=a&&(i.value=a),{count:i.count,value:i.value,label:i.label})))}}};e([r()],Qe.prototype,"checkValueRange",void 0),e([r()],Qe.prototype,"gdbVersion",void 0),e([r({type:L})],Qe.prototype,"source",void 0),e([r({readOnly:!0,dependsOn:["url"]})],Qe.prototype,"parsedUrl",null),Qe=e([p("esri.tasks.GenerateRendererTask")],Qe);var Ne=Qe;let Re=class extends h{constructor(){super(...arguments),this.classificationDefinition=null,this.where=null}};e([r({type:j,json:{read:{source:"classificationDef"},write:{target:"classificationDef"}}})],Re.prototype,"classificationDefinition",void 0),e([r({type:String,json:{write:!0}})],Re.prototype,"where",void 0),Re=e([p("esri.tasks.support.GenerateRendererParameters")],Re);var Ae=Re;let Oe=class extends j{constructor(){super(...arguments),this.attributeField=null,this.attributeField2=null,this.attributeField3=null,this.fieldDelimiter=null,this.type="unique-value-definition"}get uniqueValueFields(){const e=[];return this.attributeField&&e.push(this.attributeField),this.attributeField2&&e.push(this.attributeField2),this.attributeField3&&e.push(this.attributeField3),e}};e([r()],Oe.prototype,"attributeField",void 0),e([r()],Oe.prototype,"attributeField2",void 0),e([r()],Oe.prototype,"attributeField3",void 0),e([r({json:{write:!0}})],Oe.prototype,"fieldDelimiter",void 0),e([r({dependsOn:["attributeField","attributeField2","attributeField3"],json:{write:!0}})],Oe.prototype,"uniqueValueFields",null),e([r()],Oe.prototype,"type",void 0),Oe=e([p("esri.tasks.support.UniqueValueDefinition")],Oe);var Ue=Oe;const Ge=a.getLogger("esri.smartMapping.support.adapters.FeatureLayerAdapter");let Pe=class extends ue{constructor(e){super(e)}destroy(){this._hasLocalSource=null}_isStatsSupportedOnService(){const e=this.layer;return!e.get("capabilities.query.supportsStatistics")||"multipatch"===this.geometryType&&!T(e.url)&&e.version<10.5?l(new d("feature-layer-adapter:not-supported","Layer does not support statistics query")):o()}async _fetchFeaturesFromMemory(e,t,a){const i=this.layer;if(this._hasLocalSource){return(await i.queryFeatures(t)).features}if(!e)throw new d("feature-layer-adapter:insufficient-data","layerView is required to fetch the features");const r=u(),n=E(e,"updating",r.signal);await c(n,5e3,r).catch((e=>{throw Ge.warn("LayerView is taking too long to update. Aborting fetch from layerView."),e}));return(await e.queryFeatures(t,{signal:a})).features}_fetchFeaturesFromService(e,t){return this.layer.queryFeatures(e,{signal:t}).then((e=>e&&e.features))}_fetchFeaturesForStats(e){return A({field:e.field,normalizationField:e.normalizationField,valueExpression:e.valueExpression}).then((t=>this.getSampleFeatures({sampleSize:-1,view:e.view,returnGeometry:e.returnGeometry,requiredFields:t,signal:e.signal})))}_summaryStatsFromGenRend(e){const t=e.normalizationType,a=e.normalizationField;return this.classBreaks({field:e.field,numClasses:5,classificationMethod:"standard-deviation",standardDeviationInterval:.25,normalizationType:t,normalizationField:"field"===t?a:void 0,minValue:e.minValue,maxValue:e.maxValue,signal:e.signal}).then((e=>{let t,a,i;if(e.classBreakInfos.some((e=>(e.hasAvg&&(t=e),!!t))),t){const e=t.maxValue-t.minValue;a=t.minValue+e/2,i=4*e}return xe({min:e.minValue,max:e.maxValue,avg:a,stddev:i})}))}_getSummaryStatsQuery(e,t){const{field:a,normalizationType:i,normalizationField:r,normalizationTotal:n}=e,s=this.supportsSQLExpression&&t?Be(this,a):e.sqlExpression,o=ze({field:a,normalizationType:i,normalizationField:r,normalizationTotal:n,layer:this}),l=s||o,u=l?ie(l,e.minValue,e.maxValue):null,c=te({field:a,normalizationField:r,normalizationType:i}),m=se(e.sqlWhere,c),d=se(m,u),p=this.layer.createQuery();return p.where=se(p.where,d),p.sqlFormat=s?"standard":null,p.outStatistics=pe.map((e=>{const t=new I;return t.statisticType="variance"===e?"var":e,t.onStatisticField=l,t.outStatisticFieldName=e+"_value",t})),p}async _summaryStatsFromServiceQuery(e,t){await this._isStatsSupportedOnService(),"percent-of-total"===e.normalizationType&&(e.normalizationTotal=await this._getNormalizationTotal(e.field,e.normalizationType));const a=this._getSummaryStatsQuery(e,t);return xe(ye(await this.layer.queryFeatures(a,{signal:e.signal}),t))}async _summaryStatsFromClientQuery(e,t){const a=this._getSummaryStatsQuery(e,t);return xe(ye(await this.layer.queryFeatures(a,{signal:e.signal}),t))}async _summaryStatsFromMemory(e,t){const a=e.field,i=e.valueExpression,r=e.view,n={field:a,valueExpression:i,normalizationField:e.normalizationField,view:r,signal:e.signal},s=e.features||await this._fetchFeaturesForStats(n);if(!(s&&s.length))throw new d("feature-layer-adapter:insufficient-data","No features are available to calculate statistics");const o={...e};if("percent-of-total"===o.normalizationType){const e=(await ge({field:a},s)).sum;if(null==e)throw new d("feature-layer-adapter:invalid","invalid normalizationTotal");o.normalizationTotal=e}return xe(await ge(o,s,t))}_uvFromGenRenderer(e,t){const a=e.field,i=new Ue;i.attributeField=a;const r=new Ae;return r.classificationDefinition=i,this.generateRenderer(r,e.signal).then((e=>{const t={},i=this.getField(a);return e.uniqueValues.forEach((e=>{let a=e.value;null!=a&&""!==a&&("string"!=typeof a||""!==a.trim()&&"<null>"!==a.toLowerCase())||(a=null),null==t[a]?t[a]={count:e.count,data:w(i)&&a?Number(a):a}:t[a].count=t[a].count+e.count})),{count:t}})).then((a=>ke(a,t,e.returnAllCodedValues)))}_getUVQuery(e){const t=e.field,a=e.sqlExpression,i="countOF"+(t||"Expr"),r=new I;r.statisticType="count",r.onStatisticField=a?"1":t,r.outStatisticFieldName=i;const n=this.layer.createQuery();return n.where=se(n.where,e.sqlWhere),n.sqlFormat=a?"standard":null,n.outStatistics=[r],n.groupByFieldsForStatistics=[t||a],n}_uvFromServiceQuery(e,t){return this._isStatsSupportedOnService().then((()=>this.layer.queryFeatures(this._getUVQuery(e),{signal:e.signal}))).then((t=>Ce(t,this,e.field,null,e.signal))).then((a=>ke(a,t,e.returnAllCodedValues)))}async _uvFromClientQuery(e,t){const{signal:a}=e,i=this._getUVQuery(e),r=await this.layer.queryFeatures(i,{signal:a});return ke(await Ce(r,this,e.field,null,a),t,e.returnAllCodedValues)}async _uvFromMemory(e,t){const{field:a,valueExpression:i,view:r,signal:n}=e,s={field:a,valueExpression:i,view:r,signal:n};return je(e,e.features?e.features:await this._fetchFeaturesForStats(s),t)}_calcBinsSQL(e,t){const a=[],i=t.length;return t.forEach(((t,r)=>{const n=t[0],s=t[1],o=se(e+" >= "+n,e+(r===i-1?" <= ":" < ")+s);a.push("WHEN ("+o+") THEN "+(r+1))})),["CASE",a.join(" "),"ELSE 0","END"].join(" ")}_getNormalizationTotal(e,t,a){return e&&"percent-of-total"===t?this.summaryStatistics({field:e,signal:a}).then((e=>e.sum)):o(null)}_getQueryParamsForExpr(e,t){const a=e.valueExpression||e.sqlExpression,i=e.signal;if(!a){const a=e.field,r=a?this.getField(a):null,n=_(r),s={field:a,normalizationType:e.normalizationType,normalizationField:e.normalizationField,normalizationTotal:t,layer:this};return{sqlExpression:n?Be(this,a):ze(s),sqlWhere:n?null:e.sqlWhere||te(e),signal:i}}return{valueExpression:e.valueExpression,sqlExpression:e.sqlExpression,sqlWhere:e.sqlWhere,signal:i}}_getDataRange(e,t,a){return null!=t&&null!=a?o({min:t,max:a}):this.summaryStatistics(e).then((e=>({min:e.min,max:e.max})))}_histogramForExpr(e){return this._getNormalizationTotal(e.field,e.normalizationType,e.signal).then((t=>{const a=this._getQueryParamsForExpr(e,t);return this._getDataRange(a,e.minValue,e.maxValue).then((i=>{const{min:r,max:n}=i,s=e.numBins||10,o=be(r,n,s),l=this._calcBinsSQL(a.sqlExpression,o),u=new I({statisticType:"count",outStatisticFieldName:"countOFExpr",onStatisticField:"1"}),c=this.layer.createQuery();return c.where=se(c.where,a.sqlWhere),c.sqlFormat="standard",c.outStatistics=[u],c.groupByFieldsForStatistics=[l],c.orderByFields=[l],this._isStatsSupportedOnService().then((()=>this.layer.queryFeatures(c,{signal:a.signal}))).then((e=>Me(e,r,n,s,t)))}))}))}_histogramForField(e){let t=null;return t=null!=e.minValue&&null!=e.maxValue?o({min:e.minValue,max:e.maxValue}):this.summaryStatistics(e).then((e=>{if(!e.count)throw new d("feature-layer-adapter:insufficient-data","Either the layer has no features or none of the features have data for the field");return{min:e.min,max:e.max}})),t.then((t=>this._getBins({min:t.min,max:t.max},e.field,e.numBins,e.signal)))}_getBins(e,t,a=10,i){const{min:r,max:n,normTotal:s,excludeZerosExpr:o}=e,l=e.intervals||be(r,n,a),u=e.sqlExpr||t;return this._queryBins(l,u,o,i).then((e=>({bins:e.map(((e,t)=>({minValue:l[t][0],maxValue:l[t][1],count:e.value}))),minValue:r,maxValue:n,normalizationTotal:s})))}_queryBins(e,t,a,i){const r=[],n=e.length;for(let i=0;i<n;i++){const s=se(a,se(t+" >= "+e[i][0],null!==e[i][1]?t+(i===n-1?" <= ":" < ")+e[i][1]:""));r.push(s)}return m(r.map((e=>this.queryFeatureCount(e,i))))}_binParamsFromGenRend(e,t){const{field:a,normalizationType:i,normalizationField:r,signal:n}=e,s=te({field:a,normalizationType:i,normalizationField:r}),o=new Ae({classificationDefinition:we({field:a,normalizationType:i,normalizationField:r,classificationMethod:e.classificationMethod,standardDeviationInterval:e.standardDeviationInterval,breakCount:e.numBins||10}),where:se(s,t)});return this.generateRenderer(o,n).then((e=>{const{normalizationTotal:t,classBreaks:n}=e;return Ve({field:a,normalizationType:i,normalizationField:r,normalizationTotal:t,classBreaks:n,where:s,layer:this})}))}_histogramFromMemory(e){const{field:t,normalizationField:a,normalizationType:i,valueExpression:r,classificationMethod:n,minValue:s,maxValue:u,view:c,signal:m}=e,p={field:t,valueExpression:r,normalizationField:a,view:c,signal:m};return(e.features?o(e.features):this._fetchFeaturesForStats(p)).then((a=>{if(!(a&&a.length))throw new d("feature-layer-adapter:insufficient-data","No features are available to calculate histogram");let p=null;if((!n||"equal-interval"===n)&&!i)p=null!=s&&null!=u?o({min:s,max:u,source:"parameters"}):this.summaryStatistics({field:t,valueExpression:r,features:a,view:c,signal:m}).then((e=>e.count?{min:e.min,max:e.max}:l(new d("feature-layer-adapter:insufficient-data","No features are available to calculate histogram"))));else{const t={...e};t.features=a,p=this._getBinParamsFromMemory(t)}return p.then((t=>Ee(e,t,a)))}))}async _getBinParamsFromMemory(e){const{field:t,valueExpression:a,classificationMethod:i,standardDeviationInterval:r,normalizationType:n,normalizationField:s,minValue:o,maxValue:l,features:u,view:c,signal:m}=e;return this._classBreaksFromMemory({field:t,valueExpression:a,normalizationType:n,normalizationField:s,classificationMethod:i,standardDeviationInterval:r,minValue:o,maxValue:l,numClasses:e.numBins,features:u,view:c,signal:m}).then((e=>{const a=e.normalizationTotal,i=e.classBreakInfos,r=te({field:t,normalizationType:n,normalizationField:s});return Ve({field:t,normalizationType:n,normalizationField:s,normalizationTotal:a,classBreaks:i,where:r,layer:this})}))}_classBreaksFromGenRend(e){const{field:t,normalizationType:a,normalizationField:i,normalizationTotal:r,signal:n}=e,s=te({field:t,normalizationType:a,normalizationField:i}),o=ie(ze({field:t,normalizationType:a,normalizationField:i,normalizationTotal:r,layer:this}),e.minValue,e.maxValue),l=we({field:t,normalizationType:a,normalizationField:i,classificationMethod:e.classificationMethod,standardDeviationInterval:e.standardDeviationInterval,breakCount:e.numClasses||5}),u=new Ae;return u.classificationDefinition=l,u.where=se(s,o),this.generateRenderer(u,n).then((t=>_e(e,t)))}_classBreaksFromInterpolation(e){const{minValue:t,maxValue:a}=e,i=e.numClasses||5,r=[],n=(a-t)/i;for(let e=0;e<i;e++){const a=t+e*n;r.push({minValue:a,maxValue:a+n})}r[i-1].maxValue=a;const s=_e(e,{classBreaks:r,normalizationTotal:e.normalizationTotal});return o(s)}async _classBreaksFromMemory(e){const{field:t,normalizationField:a,valueExpression:i,view:r,signal:n}=e,s={field:t,valueExpression:i,normalizationField:a,view:r,signal:n},o=e.features||await this._fetchFeaturesForStats(s);if(!(o&&o.length))throw new d("feature-layer-adapter:insufficient-data","No features are available to calculate statistics");const l={...e};if("percent-of-total"===l.normalizationType){const e=(await ge({field:t},o)).sum;if(null==e)throw new d("feature-layer-adapter:invalid","invalid normalizationTotal");l.normalizationTotal=e}return Se(l,o)}async _heatmapStatsFromMemory(e,t){const{blurRadius:a,field:i,view:r,signal:n}=e,{resolution:s,size:o}=r.state,l=new C({extent:r.extent,tolerance:s}),u=this._quantizeFeatures(e.features||await this._fetchFeaturesForStats({field:i,view:r,returnGeometry:!0,signal:n}),l,r);if(!u||!u.length)return{count:0,min:null,max:null,avg:null,stddev:null};const c=function(e,t=10,a,i,r,n){const s=new Float64Array(r*n),o=H(t),l=Math.round(3*t);let u=Number.POSITIVE_INFINITY,c=Number.NEGATIVE_INFINITY,m=0,d=0,p=0,h=0;const f=J(i,a);for(const{geometry:t,attributes:a}of e){const e=t.x-l,i=t.y-l,y=Math.max(0,e),g=Math.max(0,i),F=Math.min(n,t.y+l),v=Math.min(r,t.x+l),x=+f(a);for(let t=g;t<F;t++){const a=o[t-i];for(let i=y;i<v;i++){const n=o[i-e],l=t*r+i,f=s[l];m=s[l]+=a*n*x;const y=m-f;d+=y,p+=y*y,m<u&&(u=m),m>c&&(c=m),h++}}}if(!h)return{mean:0,stddev:0,min:0,max:0,mid:0,count:0};const y=(c-u)/2;return{mean:d/h,stdDev:Math.sqrt((p-d*d/h)/h),min:u,max:c,mid:y,count:h}}(u,a,t,i,o[0],o[1]);if(c)return{count:c.count,min:c.min,max:c.max,avg:c.mean,stddev:c.stdDev};throw new d("feature-layer-adapter:invalid","unable to calculate heatmap statistics")}_quantizeFeatures(e,t,a){const r=O(t),{spatialReference:n,size:s}=a,o=y(n)?g(n):null,l=o?Math.round((o.valid[1]-o.valid[0])/r.scale[0]):null;return e.map((e=>{const t=new v(i(e.geometry));return U(r,t,t,t.hasZ,t.hasM),e.geometry=o?this._wrapPoint(t,l,s[0]):t,e}))}_wrapPoint(e,t,a){return e.x<0?e.x+=t:e.x>a&&(e.x-=t),e}getField(e=""){return this.layer.getField(e)}getFieldUsageInfo(e){return this.getField(e)?{supportsLabelingInfo:!0,supportsRenderer:!0,supportsPopupTemplate:!0,supportsLayerQuery:!0,supportsStatistics:!0}:null}getFieldDomain(e,t){return this.layer.getFieldDomain(e,t)}summaryStatistics(e){const t=e.field,a=t?this.getField(t):null,i=_(a),r=e.valueExpression||e.sqlExpression,n=r&&!e.sqlExpression,o=this._hasLocalSource||e.features,u=e.view,c=u&&"3d"===u.type;if(o||n)return n||e.features||c?this._summaryStatsFromMemory(e,i):this._summaryStatsFromClientQuery(e,i);if(!this.supportsSQLExpression&&(i||r))return l(new d("feature-layer-adapter:not-supported","Layer does not support standardized SQL expression for queries"));return(e.normalizationType&&!this.supportsSQLExpression?this._summaryStatsFromGenRend(e):this._summaryStatsFromServiceQuery(e,i)).catch((()=>(s(e.signal),this._summaryStatsFromMemory(e,i))))}uniqueValues(e){const{field:t,valueExpression:a,sqlExpression:i,signal:r}=e,n=(t?this.getField(t):null)&&this.getFieldDomain(t),o=a&&(!i||!this.supportsSQLExpression),l=this._hasLocalSource||e.features||o,u=e.view,c=u&&"3d"===u.type;return l?o||e.features||c?this._uvFromMemory(e,n):this._uvFromClientQuery(e,n):this._uvFromServiceQuery(e,n).catch((t=>(s(r),e.field?this._uvFromGenRenderer(e,n):t))).catch((()=>(s(r),o||e.features||c?this._uvFromMemory(e,n):this._uvFromClientQuery(e,n))))}histogram(e){const{field:t,normalizationType:a,normalizationField:i,classificationMethod:r,signal:n}=e,s=t?this.getField(t):null,o=_(s),u=e.valueExpression||e.sqlExpression,c=u&&!e.sqlExpression,m=this._hasLocalSource||e.features||c,p=this.supportsSQLExpression,h=!r||"equal-interval"===r,f=e.minValue,y=e.maxValue,g=null!=f&&null!=y,F=e.numBins||10;return m?this._histogramFromMemory(e):(u||p)&&h?u&&!p?l(new d("feature-layer-adapter:not-supported","Layer does not support standardized SQL expression for queries")):this._histogramForExpr(e):o&&h?l(new d("feature-layer-adapter:not-supported","Normalization and date field are not allowed when layer does not support standardized SQL expression for queries")):a||!h?this._binParamsFromGenRend(e).then((r=>{if(!g)return this._getBins(r,t,F,n);if(f>r.max||y<r.min)throw new d("histogram:insufficient-data","Range defined by 'minValue' and 'maxValue' does not intersect available data range of the field");if(h)return this._getBins({min:f,max:y,sqlExpr:r.sqlExpr,excludeZerosExpr:r.excludeZerosExpr},t,F,n);{const s=ie(ze({field:t,normalizationType:a,normalizationField:i,normalizationTotal:r.normTotal,layer:this}),f,y);return this._binParamsFromGenRend(e,s).then((e=>this._getBins(e,t,F,n)))}})):this._histogramForField(e)}classBreaks(e){const t=!1!==e.analyzeData,a=this._hasLocalSource||e.features||e.valueExpression;if(t&&a)return this._classBreaksFromMemory(e);return(t?this._classBreaksFromGenRend(e):this._classBreaksFromInterpolation(e)).catch((()=>(s(e.signal),this._classBreaksFromMemory(e))))}queryFeatureCount(e,t){if(this._hasLocalSource)return l(new d("feature-layer-adapter:not-supported","Layer does not support count query"));const a=this.layer,i=a.createQuery();return i.where=se(i.where,e),a.queryFeatureCount(i,{signal:t})}generateRenderer(e,t){const a=this.layer;if(this._hasLocalSource||a.version<10.1)return l(new d("feature-layer-adapter:not-supported","Layer does not support generateRenderer operation (requires ArcGIS Server version 10.1+)"));const i=new Ne({url:a.parsedUrl.path,source:a.dynamicDataSource,gdbVersion:a.gdbVersion}),r=a.createQuery();return e.where=se(e.where,r.where),i.execute(e,{signal:t})}heatmapStatistics(e){const{field:t,fieldOffset:a,signal:i}=e;return(t&&null==a?this.summaryStatistics({field:t,signal:i}):o(null)).then((t=>{let i=a||0;if(t){const{count:e,min:a,max:r}=t;e?a===r&&0===a?i=1:r<=0?i="abs":a<0&&(i=-1.01*a):i=1}return this._heatmapStatsFromMemory(e,i).then((e=>({...e,summaryStatistics:t,fieldOffset:i})))}))}async predominantCategories(e){if(!this._hasLocalSource&&!this.supportsSQLExpression)throw new d("feature-layer-adapter:not-supported","Layer does not support advanced SQL expressions and standardized queries");const{fields:t,view:a,signal:i}=e,r=G(t),n=P(t),s=(a&&this._hasLocalSource?await this._uvFromMemory({valueExpression:r,view:a,signal:i}):await this._uvFromServiceQuery({sqlExpression:n.expression,valueExpression:r,signal:i})).uniqueValueInfos,o=s.map((e=>e.value)),l=t.filter((e=>-1===o.indexOf(e)));for(const e of l)s.push({value:e,count:0});s.sort(((e,a)=>t.indexOf(e.value)-t.indexOf(a.value)));for(const e of s)e.value===W&&(e.value=null);return{predominantCategoryInfos:s}}async getSampleFeatures(e){const{view:t,sampleSize:a,requiredFields:i,returnGeometry:r,signal:o}=e,l=this.layer.createQuery();l.outSpatialReference=e.spatialReference||t&&t.spatialReference,l.returnGeometry=!!r,l.outFields=i;let u=[],c=!1;if(t)try{const e=await t.whenLayerView(this.layer);if(c=!(await fe(this,i,e)).length,c&&(u=await this._fetchFeaturesFromMemory(e,l,o),u.length&&a>0&&a<=u.length))return n(u,a,1)}catch(e){s(o)}try{if(this._hasLocalSource)return c?u:this._fetchFeaturesFromService(l,o);const i=await this.queryFeatureCount(null,o),r=this.layer.capabilities.query.maxRecordCount;let s=-1===a?i:a;if(s=r&&s>r?r:s,i<=u.length||u.length>=r)return u;const m=t.extent.width/t.width/t.scale*4e5;if(l.maxAllowableOffset=e.resolution||m,i<=s)return this._fetchFeaturesFromService(l,o);if(i<=2e4){const e=await this.layer.queryObjectIds();return l.objectIds=n(e,s,1),this._fetchFeaturesFromService(l,o)}return this.layer.get("capabilities.query.supportsPagination")&&(l.num=Math.min(s,2e4)),this._fetchFeaturesFromService(l,o)}catch(e){return s(o),u}}load(e){const t=this.layer.load(e).then((e=>{this.geometryType=e.geometryType,this.objectIdField=e.objectIdField,this.supportsSQLExpression=e.get("capabilities.query.supportsSqlExpression"),this._hasLocalSource=!e.url&&!!e.source,this.hasQueryEngine=this._hasLocalSource,this.minScale=e.minScale,this.maxScale=e.maxScale,this.fullExtent=e.fullExtent}));return this.addResolvingPromise(t),o(this)}};e([r({constructOnly:!0})],Pe.prototype,"layer",void 0),Pe=e([p("esri.smartMapping.support.adapters.FeatureLayerAdapter")],Pe);var We=Pe;function He(e){return"esri.tasks.support.ClassBreaksDefinition"===e.declaredClass}function Je(e){return"esri.tasks.support.UniqueValueDefinition"===e.declaredClass}let $e=class extends We{constructor(e){super(e)}async _createGenerateRendererResult(e,t,a,i,r){const n=e&&e.features;if(!(n&&n.length))throw new d("csv-layer-adapter:insufficient-data","No features are available to calculate statistics");let s=null;if("percent-of-total"===i){if(s=(await ge({field:t},n)).sum,null==s)throw new d("csv-layer-adapter:invalid","invalid normalizationTotal")}if(He(r)){return Y({definition:r,values:(await ve({field:t,normalizationType:i,normalizationField:a,normalizationTotal:s},n)).filter((e=>null!=e&&De(e))),normalizationTotal:s})}if(Je(r)){return function(e){const t=X(e),a=[],i=t.uniqueValues.length;for(let e=0;e<i;e++){const i=t.uniqueValues[e],r=t.valueFrequency[e],n=i.toString();a.push({value:i,count:r,label:n})}return{uniqueValues:a}}((await ve({field:t},n)).filter((e=>null!=e&&"string"==typeof e&&""!==e.trim())))}}generateRenderer(e,t){const a=e.classificationDefinition;let i=null,r=null,n=null;He(a)?(i=a.classificationField,r=a.normalizationField,n=a.normalizationType):Je(a)&&(i=a.attributeField);const s=this.layer;return A({field:i,normalizationField:r}).then((o=>{const l=s.createQuery();return l.returnGeometry=!1,l.outFields=o,l.where=se(l.where,e.where),s.queryFeatures(l,{signal:t}).then((e=>this._createGenerateRendererResult(e,i,r,n,a)))}))}load(e){const t=this.layer.load(e).then((e=>{this.geometryType=e.geometryType,this.objectIdField=e.objectIdField,this.supportsSQLExpression=!0,this._hasLocalSource=!1,this.hasQueryEngine=!0}));return this.addResolvingPromise(t),o(this)}};$e=e([p("esri.smartMapping.support.adapters.CSVLayerAdapter")],$e);var Ye=$e;let Ze=class extends ue{constructor(e){super(e)}_hasCachedStatistics(e){return this.layer.hasCachedStatistics(e)}_updateQuery(e,t=[],a=[]){if(!a.length)return e;const i=this.layer.objectIdField,r=e.clone(),n=t.filter((e=>{const t=this.layer.getField(e);return-1===a.indexOf(t.name)})),s=n.some((e=>this.layer.getField(e).name===i));return r.outFields=s?n:[...n,i],r}async _fetchFeaturesFromMemory(e,t,a){if(!e)throw new d("scene-layer-adapter:insufficient-data","view is required to fetch the features from layerView");const i=await e.whenLayerView(this.layer),r=u(),n=E(i,"updating",r.signal);await c(n,5e3,r);const s=await fe(this,a,i),o=this._updateQuery(t,a,s),l=(await i.queryFeatures(o)).features;return s.length?i.whenGraphicAttributes(l,s):l}_fetchFeaturesForStats(e){return A({field:e.field,normalizationField:e.normalizationField,valueExpression:e.valueExpression}).then((t=>this.getSampleFeatures({sampleSize:-1,view:e.view,returnGeometry:e.returnGeometry,requiredFields:t,signal:e.signal})))}_generateFeatureSetForCachedHistogram(e,t=e.minimum,a=e.maximum,i){const r=[];for(let e=0;e<i;e++)r[e]=0;const n=e.counts.length,s=e.minimum,o=e.maximum;for(let l=0;l<n;l++){const u=(l+.5)/n,c=((1-u)*s+u*o-t)/(a-t)*i;c>=0&&c<=i&&(r[c===i?i-1:Math.floor(c)]+=e.counts[l])}const l=[];r.forEach(((e,t)=>{const a=new V({attributes:{}});a.attributes.EXPR_1=t+1,a.attributes.countOFExpr=e,l.push(a)}));const u=new q;return u.features=l,u}_getCachedStatistics(e,t){const a=this.layer;return e.valueExpression||e.sqlExpression||e.sqlWhere||e.minValue||e.maxValue?l(new d("scene-layer-adapter:not-supported","This Layer does not support calculating statistics when 'valueExpression', 'sqlExpression', 'sqlWhere', 'minValue' or 'maxValue' is specified")):a.queryCachedStatistics(t&&t.name,{signal:e.signal}).then((e=>{const t=e.stats,{min:a,max:i}=t;let{avg:r,stddev:n,sum:s,variance:o,count:l}=t;return 0===a&&0===i||(r=0===r?null:r,s=0===s?null:s,n=0===n?null:n,o=0===o?null:o,l=0===l?null:l),null==l&&null!=s&&null!=r&&(l=Math.round(s/r)),{avg:r,count:l,max:i,min:a,stddev:n,sum:s,variance:o}}))}async _getSummaryStatisticsFromMemory(e,t){const a={field:e.field,valueExpression:e.valueExpression,normalizationField:e.normalizationField,view:e.view,signal:e.signal},i=e.features?e.features:await this._fetchFeaturesForStats(a);if(!(i&&i.length))throw new d("scene-layer-adapter:insufficient-data","No features are available to calculate statistics");const r=_(t),n={...e};if("percent-of-total"===n.normalizationType){const e=(await ge({field:n.field},i)).sum;if(null==e)throw new d("scene-layer-adapter:invalid","invalid normalizationTotal");n.normalizationTotal=e}return xe(await ge(n,i,r))}_getCachedStatisticsForUniqueValues(e,t){const a=this.layer,i=t&&t.name,r=t&&this.getFieldDomain(e.field);return e.valueExpression||e.sqlExpression||e.sqlWhere?l(new d("scene-layer-adapter:not-supported","This Layer does not support calculating statistics when 'valueExpression', 'sqlExpression' or 'sqlWhere' is specified")):a.queryCachedStatistics(i,{signal:e.signal}).then((r=>{const n=r.stats;if(!n.mostFrequentValues)return l();const s=r.labels&&r.labels.labels,o={},u=[],c="countOF"+i;n.mostFrequentValues.forEach((e=>{const r=new V({attributes:{}});r.attributes[i]=t&&t.name!==a.objectIdField&&(w(t)||_(t))?Number(e.value):e.value,r.attributes[c]=e.count,u.push(r)})),s&&s.forEach((e=>{o[e.value]=e.label}));const m=new q;return m.features=u,Ce(m,this,e.field,o,e.signal)})).then((t=>ke(t,r,e.returnAllCodedValues)))}_getUniqueValuesFromMemory(e,t){const a=t&&this.getFieldDomain(e.field),i={field:e.field,valueExpression:e.valueExpression,view:e.view,signal:e.signal};return(e.features?o(e.features):this._fetchFeaturesForStats(i)).then((t=>je(e,t,a)))}_getCachedStatisticsForHistogram(e,t){const a=this.layer;return e.valueExpression||e.sqlExpression||e.sqlWhere||e.normalizationType?l(new d("scene-layer-adapter:not-supported","This Layer does not support calculating statistics when 'valueExpression' or 'sqlExpression' or 'sqlWhere' or 'normalizationType' is specified")):a.queryCachedStatistics(t&&t.name,{signal:e.signal}).then((t=>{const a=t.stats,{minValue:i,maxValue:r}=e,n=null!=i?i:a.min,s=null!=r?r:a.max,o=e.numBins||10;return Me(this._generateFeatureSetForCachedHistogram(a.histogram,n,s,o),n,s,o)}))}async _getClassBreaksFromMemory(e){const t={field:e.field,valueExpression:e.valueExpression,normalizationField:e.normalizationField,view:e.view,signal:e.signal},a=e.features?e.features:await this._fetchFeaturesForStats(t);if(!(a&&a.length))throw new d("scene-layer-adapter:insufficient-data","No features are available to calculate statistics");const i={...e};if("percent-of-total"===i.normalizationType){const e=(await ge({field:i.field},a)).sum;if(null==e)throw new d("scene-layer-adapter:invalid","invalid normalizationTotal");i.normalizationTotal=e}return Se(i,a)}_getHistogramFromMemory(e){const t={field:e.field,valueExpression:e.valueExpression,normalizationField:e.normalizationField,view:e.view,signal:e.signal};return(e.features?o(e.features):this._fetchFeaturesForStats(t)).then((t=>{if(!(t&&t.length))throw new d("scene-layer-adapter:insufficient-data","No features are available to calculate histogram");const{field:a,normalizationType:i,valueExpression:r,classificationMethod:n,minValue:s,maxValue:u,view:c}=e;let m=null;if((!n||"equal-interval"===n)&&!i)m=null!=s&&null!=u?o({min:s,max:u}):this.summaryStatistics({field:a,valueExpression:r,features:t,view:c,signal:e.signal}).then((e=>e.count?{min:e.min,max:e.max}:l(new d("feature-layer-adapter:insufficient-data","No features are available to calculate histogram"))));else{const a={...e};a.features=t,m=this._getBinParamsFromMemory(a)}return m.then((a=>Ee(e,a,t)))}))}async _getBinParamsFromMemory(e){const{field:t,valueExpression:a,classificationMethod:i,standardDeviationInterval:r,normalizationType:n,normalizationField:s,minValue:o,maxValue:l,features:u,view:c}=e;return this._getClassBreaksFromMemory({field:t,valueExpression:a,normalizationType:n,normalizationField:s,classificationMethod:i,standardDeviationInterval:r,minValue:o,maxValue:l,numClasses:e.numBins,features:u,view:c}).then((e=>{const a=e.normalizationTotal,i=e.classBreakInfos,r=te({field:t,normalizationType:n,normalizationField:s});return Ve({field:t,normalizationType:n,normalizationField:s,normalizationTotal:a,classBreaks:i,where:r,layer:this})}))}getField(e=""){return this.layer.getField(e)}getFieldUsageInfo(e){const t=this.getField(e);if(!t)return null;const a=this.layer.getFieldUsageInfo(t.name);return{supportsLabelingInfo:a.supportsLabelingInfo,supportsPopupTemplate:a.supportsPopupTemplate,supportsRenderer:a.supportsRenderer,supportsLayerQuery:a.supportsLayerQuery,supportsStatistics:!0}}getFieldDomain(e,t){return this._featureLayerAdapter?this._featureLayerAdapter.getFieldDomain(e,t):null}summaryStatistics(e){const t=this.getField(e.field);return this._featureLayerAdapter?this._featureLayerAdapter.summaryStatistics(e):this._hasCachedStatistics(t&&t.name)?this._getCachedStatistics(e,t).catch((()=>(s(e.signal),this._getSummaryStatisticsFromMemory(e,t)))):this._getSummaryStatisticsFromMemory(e,t)}uniqueValues(e){const t=this.getField(e.field);return this._featureLayerAdapter?this._featureLayerAdapter.uniqueValues(e):this._hasCachedStatistics(t&&t.name)?this._getCachedStatisticsForUniqueValues(e,t).catch((()=>(s(e.signal),this._getUniqueValuesFromMemory(e,t)))):this._getUniqueValuesFromMemory(e,t)}histogram(e){const t=this.getField(e.field);return this._featureLayerAdapter?this._featureLayerAdapter.histogram(e):this._hasCachedStatistics(t&&t.name)?this._getCachedStatisticsForHistogram(e,t).catch((()=>(s(e.signal),this._getHistogramFromMemory(e)))):this._getHistogramFromMemory(e)}classBreaks(e){const t=this.getField(e.field);return this._featureLayerAdapter?this._featureLayerAdapter.classBreaks(e):this._hasCachedStatistics(t&&t.name)?l(new d("scene-layer-adapter:not-supported","Cached stats not supported")):this._getClassBreaksFromMemory(e)}queryFeatureCount(e,t){return this._featureLayerAdapter?this._featureLayerAdapter.queryFeatureCount(e,t):l(new d("scene-layer-adapter:not-supported","SceneLayer without associated FeatureLayer does not support count query"))}generateRenderer(e,t){return this._featureLayerAdapter?this._featureLayerAdapter.generateRenderer(e,t):l(new d("scene-layer-adapter:not-supported","SceneLayer without associated FeatureLayer does not support generateRenderer operation"))}heatmapStatistics(e){return this._featureLayerAdapter?this._featureLayerAdapter.heatmapStatistics(e):l(new d("scene-layer-adapter:not-supported","SceneLayer without associated FeatureLayer does not support heatmapStatistics operation"))}async predominantCategories(e){if(this._featureLayerAdapter)return this._featureLayerAdapter.predominantCategories(e);throw new d("scene-layer-adapter:not-supported","SceneLayer without associated FeatureLayer does not support predominantCategories")}async getSampleFeatures(e){const{view:t,sampleSize:a,requiredFields:i,returnGeometry:r,signal:o}=e,l=this.layer.createQuery();l.outFields=i,l.returnGeometry=!!r,l.where=null,l.num=a;let u=[];try{if(u=await this._fetchFeaturesFromMemory(t,l,i),u.length&&a>0&&a<=u.length)return n(u,a,1)}catch(e){s(o)}let c=null;if(this._featureLayerAdapter){const t={...e};delete t.view,c=await this._featureLayerAdapter.getSampleFeatures(t)}return c&&c.length?c:n(u,u.length,1)}load(e){const a=this.layer.load(e).then((a=>{const i=a.associatedLayer;if(this.geometryType=a.geometryType,t(i)){this._featureLayerAdapter=new We({layer:i});return this._featureLayerAdapter.load(e).then((()=>{this.objectIdField=this._featureLayerAdapter.objectIdField,this.supportsSQLExpression=this._featureLayerAdapter.supportsSQLExpression,this.minScale=this._featureLayerAdapter.minScale,this.maxScale=this._featureLayerAdapter.maxScale,this.fullExtent=this._featureLayerAdapter.fullExtent}))}this.objectIdField=a.objectIdField,this.supportsSQLExpression=!1,this.hasQueryEngine=!1,this.fullExtent=a.fullExtent}));return this.addResolvingPromise(a),o(this)}};e([r({constructOnly:!0})],Ze.prototype,"layer",void 0),Ze=e([p("esri.smartMapping.support.adapters.SceneLayerAdapter")],Ze);var Xe=Ze;let Ke=class extends Xe{constructor(e){super(e)}getField(e=""){return b(this.layer.fields,e)}getFieldUsageInfo(e){const t=this.getField(e);if(!t)return null;const a=this._hasCachedStatistics(t.name);return{supportsLabelingInfo:a,supportsPopupTemplate:a,supportsRenderer:a,supportsLayerQuery:!1,supportsStatistics:a}}getFieldDomain(){return null}load(e){const t=this.layer.load(e).then((()=>{this.geometryType="point",this.objectIdField=null,this.supportsSQLExpression=!1,this.hasQueryEngine=!1}));return this.addResolvingPromise(t),o(this)}};Ke=e([p("esri.smartMapping.support.adapters.PointCloudLayerAdapter")],Ke);const et={0:{adapter:Ye,type:"csv",label:"CSVLayer"},2:{adapter:We,type:"feature",label:"FeatureLayer"},1:{adapter:We,type:"geojson",label:"GeoJSONLayer"},3:{adapter:Xe,type:"scene",label:"SceneLayer"},4:{adapter:Ke,type:"point-cloud",label:"PointCloudLayer"}},tt=[0,2,1,3,4];function at(e){return e.map((e=>et[e].label))}function it(e,t=tt){if(e instanceof ue)return e;let a=null;return t.some((t=>{const i=e.type===et[t].type;if(i){const i=et[t].adapter;a=new i({layer:e})}return i})),a}export{re as a,ne as b,it as c,at as g,De as i,oe as v};
