/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{_ as t}from"./tslib.es6.js";import"./object.js";import"./Logger.js";import{property as e}from"../core/accessorSupport/decorators/property.js";import o from"../core/Accessor.js";import{debounce as i,resolve as r,all as s}from"../core/promiseUtils.js";import"./ensureType.js";import{subclass as a}from"../core/accessorSupport/decorators/subclass.js";import"../core/urlUtils.js";import"./resourceExtension.js";import{g as n}from"../geometry/SpatialReference.js";import p from"../geometry/Extent.js";import{c as m}from"./aaBoundingRect.js";import h from"../layers/support/TileInfo.js";import{T as c}from"./TileKey.js";import{T as l}from"./TileInfoView.js";import{B as d}from"./Bitmap.js";const u=Math.PI/180;function g(t,e){const o=e.rotation*u;const i=Math.abs(Math.cos(o)),r=Math.abs(Math.sin(o)),[s,a]=e.size;return t[0]=Math.round(a*r+s*i),t[1]=Math.round(a*i+s*r),t}const f=m(),x=[0,0],y=new c(0,0,0,0),M=2048,j=2048,v=!1,_=!1,R=!1;let S=class extends o{constructor(t){super(t),this._imagePromise=null,this.hidpi=R,this.imageMaxWidth=M,this.imageMaxHeight=j,this.imageRotationSupported=v,this.imageNormalizationSupported=_,this.update=i((async(t,e)=>{const o=t.state,i=n(o.spatialReference),r=this.hidpi?t.pixelRatio:1;if(!t.stationary||this.destroyed)return;this.imageRotationSupported?(x[0]=o.size[0],x[1]=o.size[1]):g(x,o);const s=Math.floor(x[0]*r)>this.imageMaxWidth||Math.floor(x[1]*r)>this.imageMaxHeight,a=i&&(o.extent.xmin<i.valid[0]||o.extent.xmax>i.valid[1]),p=!this.imageNormalizationSupported&&a,m=!s&&!p,h=this.imageRotationSupported?o.rotation:0;if(m)this._imagePromise=this._singleExport(o,x,h,r,e);else{let t=Math.min(this.imageMaxWidth,this.imageMaxHeight);p&&(t=Math.min(o.worldScreenWidth,t)),this._imagePromise=this._tiledExport(o,t,h,r,e)}return this._imagePromise.then((async t=>{this._imagePromise=null,await Promise.all(t.map((t=>(this.container.addChild(t),t.fadeIn()))));for(const e of this.container.children)t.includes(e)||e.fadeOut().then((()=>{this.container.removeChild(e)}))})).catch((t=>{throw this._imagePromise=null,t}))}),5e3)}destroy(){}get updating(){return null!==this._imagePromise}updateExports(t){for(const e of this.container.children){if(!e.visible||!e.stage)return;t(e)?console.error("ExportStrategy.updateExports doesn't support promise yet"):(e.invalidateTexture(),e.requestRender())}}_export(t,e,o,i,s,a){return r().then((()=>this.fetchSource(t,Math.floor(e*s),Math.floor(o*s),{rotation:i,pixelRatio:s,signal:a}))).then((o=>{const r=new d(o);return r.x=t.xmin,r.y=t.ymax,r.resolution=t.width/e,r.rotation=i,r.pixelRatio=s,r}))}_singleExport(t,e,o,i,r){!function(t,e,o,i){const[r,s]=e,[a,n]=i,p=.5*o;t[0]=r-p*a,t[1]=s-p*n,t[2]=r+p*a,t[3]=s+p*n}(f,t.center,t.resolution,e);const s=new p(f[0],f[1],f[2],f[3],t.spatialReference);return this._export(s,e[0],e[1],o,i,r).then((t=>[t]))}_tiledExport(t,e,o,i,r){const a=h.create({size:e,spatialReference:t.spatialReference,scales:[t.scale]}),n=new l(a),m=n.getTileCoverage(t);if(!m)return null;const c=[];return m.forEach(((s,a,m,h)=>{y.set(s,a,m,h),n.getTileBounds(f,y);const l=new p(f[0],f[1],f[2],f[3],t.spatialReference);c.push(this._export(l,e,e,o,i,r))})),s(c)}};t([e()],S.prototype,"_imagePromise",void 0),t([e()],S.prototype,"container",void 0),t([e()],S.prototype,"fetchSource",void 0),t([e()],S.prototype,"hidpi",void 0),t([e()],S.prototype,"imageMaxWidth",void 0),t([e()],S.prototype,"imageMaxHeight",void 0),t([e()],S.prototype,"imageRotationSupported",void 0),t([e()],S.prototype,"imageNormalizationSupported",void 0),t([e()],S.prototype,"requestUpdate",void 0),t([e({dependsOn:["_imagePromise"]})],S.prototype,"updating",null),S=t([a("esri.views.2d.layers.support.ExportStrategy")],S);var E=S;export{E};
