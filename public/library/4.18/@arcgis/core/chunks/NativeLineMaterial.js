/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{_ as e}from"./tslib.es6.js";import{i as t,u as i,L as s,b as r}from"./Logger.js";import{c as a}from"./vec3f64.js";import{f as n,c as o,d as l,s as p,a as c,g as u,l as d,k as h}from"./vec3.js";import{d as f}from"./screenUtils.js";import{a as m}from"./BufferView.js";import{c as g}from"./vec2.js";import{S as P,T as v,d as b,g as x,f as C,e as O,s as S,p as E,a as y,b as w,D as T,V as j,a6 as A,l as R,m as D,n as I,R as U,M as q,ae as _,E as L,G as B,F as H,t as V}from"./PiUtils.glsl.js";import{P as M}from"./Program.js";import{s as N,m as z,d as W,a as F}from"./isWebGL2Context.js";import{u as G,p as $}from"./geometryUtils.js";import{j as X,k,l as J,D as K}from"./ColorMaterial.js";import{d as Q,V as Y}from"./Util.js";import{i as Z}from"./Object3D.js";var ee=Object.freeze({__proto__:null,build:function(e){const t=new P;return t.include(v,{linearDepth:!1}),t.include(b,e),t.include(X,e),t.vertex.uniforms.add("proj","mat4").add("view","mat4"),t.attributes.add("position","vec3"),t.varyings.add("vpos","vec3"),t.vertex.code.add(x`
    void main(void) {
      vpos = position;
      forwardNormalizedVertexColor();
      gl_Position = transformPosition(proj, view, vpos);
  `),e.stippleEnabled&&(t.attributes.add("auxpos1","vec3"),t.vertex.uniforms.add("ndcToPixel","vec2"),t.vertex.code.add(x`
    vec4 vpos2 = transformPosition(proj, view, auxpos1);
    float lineSegmentPixelSize = length((vpos2.xy / vpos2.w - gl_Position.xy / gl_Position.w) * ndcToPixel);

    stipplePatternUv = lineSegmentPixelSize * stipplePatternPixelSizeInv;
    ${e.stippleIntegerRepeatsEnabled?"stipplePatternUv = floor(stipplePatternUv + 0.5);":""}

    // Cancel out perspective correct interpolation because we want this length the really represent
    // the screen distance
    stipplePatternUv *= gl_Position.w;
    `)),t.vertex.code.add(x`
  }
  `),4===e.output&&t.include(C),t.include(O,e),t.fragment.uniforms.add("constantColor","vec4").add("alphaCoverage","float"),t.fragment.code.add(x`
  void main() {
    discardBySlice(vpos);

    vec4 color = ${e.attributeColor?"vColor":"constantColor"};

    float stippleAlpha = getStippleAlpha();
    discardByStippleAlpha(stippleAlpha, STIPPLE_ALPHA_COLOR_DISCARD);

    vec4 finalColor = blendStipple(vec4(color.rgb, color.a * alphaCoverage), stippleAlpha);

    if (finalColor.a < ${x.float(S)}) {
      discard;
    }

    ${0===e.output?x`gl_FragColor = highlightSlice(finalColor, vpos);`:""}
    ${4===e.output?x`outputHighlight();`:""}
  }
  `),t}});class te extends w{constructor(e,t){super(e,t),this.stipplePattern=null,this.stippleTextureBind=null,this.stippleTextureRepository=e.stippleTextureRepository}initializeProgram(e){const t=te.shader.get(),i=this.configuration,s=t.build({output:i.output,attributeColor:i.vertexColors,slicePlaneEnabled:i.slicePlaneEnabled,sliceHighlightDisabled:i.sliceHighlightDisabled,sliceEnabledForVertexPrograms:!1,stippleEnabled:i.stippleEnabled,stippleOffColorEnabled:i.stippleOffColorEnabled,stippleUVMaxEnabled:!1,stippleIntegerRepeatsEnabled:i.stippleIntegerRepeatsEnabled});return new M(e.rctx,s.generateSource("vertex"),s.generateSource("fragment"),T)}dispose(){super.dispose(),this.stippleTextureRepository.release(this.stipplePattern),this.stipplePattern=null,this.stippleTextureBind=null}bindPass(e,s,r){if(j.bindProjectionMatrix(this.program,r.camera.projectionMatrix),this.stipplePattern!==s.stipplePattern){const e=s.stipplePattern;this.stippleTextureBind=this.stippleTextureRepository.swap(this.stipplePattern,e),this.stipplePattern=e}if(this.configuration.stippleEnabled){const i=t(this.stippleTextureBind)?this.stippleTextureBind(e,0)*r.camera.pixelRatio:1;this.program.setUniform1i("stipplePatternTexture",0),this.program.setUniform1f("stipplePatternPixelSizeInv",1/i),this.program.setUniform2f("ndcToPixel",r.camera.fullViewport[2]/2,r.camera.fullViewport[3]/2)}if(this.program.setUniform4fv("constantColor",s.color),this.program.setUniform1f("alphaCoverage",Math.min(1,s.width*r.camera.pixelRatio)),this.configuration.stippleOffColorEnabled){const e=i(s.stippleOffColor);this.program.setUniform4f("stippleOffColor",e[0],e[1],e[2],e.length>3?e[3]:1)}4===this.configuration.output&&C.bindOutputHighlight(e,this.program,r)}bindDraw(e){j.bindView(this.program,e),O.bindUniformsWithOrigin(this.program,this.configuration,e)}initializePipeline(){const e=this.configuration,t=N(770,1,771,771),i=(t,i=null,s=null)=>z({blending:i,depthTest:A,depthWrite:s,colorWrite:W,stencilWrite:e.sceneHasOcludees?R:null,stencilTest:e.sceneHasOcludees?t?D:I:null});return 0===e.output?(this._occludeePipelineState=i(!0,e.transparent||e.stippleEnabled?t:null,F),i(!1,e.transparent||e.stippleEnabled?t:null,F)):i(!1)}get primitiveType(){return 1}getPipelineState(e){return e?this._occludeePipelineState:this.pipeline}}te.shader=new U(ee,(()=>Promise.resolve().then((function(){return ee}))));class ie extends y{constructor(){super(...arguments),this.output=0,this.slicePlaneEnabled=!1,this.sliceHighlightDisabled=!1,this.vertexColors=!1,this.transparent=!1,this.stippleEnabled=!1,this.stippleOffColorEnabled=!1,this.stippleIntegerRepeatsEnabled=!1,this.sceneHasOcludees=!1}}e([E({count:8})],ie.prototype,"output",void 0),e([E()],ie.prototype,"slicePlaneEnabled",void 0),e([E()],ie.prototype,"sliceHighlightDisabled",void 0),e([E()],ie.prototype,"vertexColors",void 0),e([E()],ie.prototype,"transparent",void 0),e([E()],ie.prototype,"stippleEnabled",void 0),e([E()],ie.prototype,"stippleOffColorEnabled",void 0),e([E()],ie.prototype,"stippleIntegerRepeatsEnabled",void 0),e([E()],ie.prototype,"sceneHasOcludees",void 0);const se=s.getLogger("esri.views.3d.webgl-engine.materials.NativeLineMaterial");class re extends q{constructor(e,t){super(t,e,oe),this.techniqueConfig=new ie}getTechniqueConfig(e){this.techniqueConfig.output=e,this.techniqueConfig.slicePlaneEnabled=this.params.slicePlaneEnabled,this.techniqueConfig.vertexColors=this.params.vertexColors,this.techniqueConfig.transparent=this.params.color[3]<1||this.params.width<1;const i=t(this.params.stipplePattern);return this.techniqueConfig.stippleEnabled=i,this.techniqueConfig.stippleOffColorEnabled=i&&t(this.params.stippleOffColor),this.techniqueConfig.stippleIntegerRepeatsEnabled=i&&this.params.stippleIntegerRepeats,this.techniqueConfig.sceneHasOcludees=this.params.sceneHasOcludees,this.techniqueConfig}getPassParameters(){return this.params}intersect(e,t,i,s,r,a,n,o,l){l?_(e,s,a,1,n):this.intersectLineGeometry(e,t,i,s,n)}intersectLineGeometry(e,t,i,s,r){if(!s.options.selectionMode||Z(t))return;if(!Q(i))return void se.error("intersection assumes a translation-only matrix");const a=e.data.getVertexAttr().position.data,f=s.camera,m=ve;g(m,s.point);n(be[0],m[0]-2,m[1]+2,0),n(be[1],m[0]+2,m[1]+2,0),n(be[2],m[0]+2,m[1]-2,0),n(be[3],m[0]-2,m[1]-2,0);for(let e=0;e<4;e++)if(!f.unprojectFromRenderScreen(be[e],xe[e]))return;$.fromPoints(f.eye,xe[0],xe[1],Ce),$.fromPoints(f.eye,xe[1],xe[2],Oe),$.fromPoints(f.eye,xe[2],xe[3],Se),$.fromPoints(f.eye,xe[3],xe[0],Ee);let P=Number.MAX_VALUE;for(let e=0;e<a.length-5;e+=3){if(le[0]=a[e]+i[12],le[1]=a[e+1]+i[13],le[2]=a[e+2]+i[14],pe[0]=a[e+3]+i[12],pe[1]=a[e+4]+i[13],pe[2]=a[e+5]+i[14],$.signedDistance(Ce,le)<0&&$.signedDistance(Ce,pe)<0||$.signedDistance(Oe,le)<0&&$.signedDistance(Oe,pe)<0||$.signedDistance(Se,le)<0&&$.signedDistance(Se,pe)<0||$.signedDistance(Ee,le)<0&&$.signedDistance(Ee,pe)<0)continue;if(f.projectToRenderScreen(le,de),f.projectToRenderScreen(pe,he),de[2]<0&&he[2]>0){o(ce,le,pe);const e=f.frustum,t=-$.signedDistance(e.planes[4],le)/l(ce,$.normal(e.planes[4]));p(ce,ce,t),c(le,le,ce),f.projectToRenderScreen(le,de)}else if(de[2]>0&&he[2]<0){o(ce,pe,le);const e=f.frustum,t=-$.signedDistance(e.planes[4],pe)/l(ce,$.normal(e.planes[4]));p(ce,ce,t),c(pe,pe,ce),f.projectToRenderScreen(pe,he)}else if(de[2]<0&&he[2]<0)continue;de[2]=0,he[2]=0;const t=G.distance2(G.fromPoints(de,he,ge),m);t<P&&(P=t,u(fe,le),u(me,pe))}const v=s.rayBeginPoint,b=s.rayEndPoint;if(P<4){let e=Number.MAX_VALUE;if(G.closestLineSegmentPoint(G.fromPoints(fe,me,ge),G.fromPoints(v,b,Pe),ue)){o(ue,ue,v);const t=d(ue);p(ue,ue,1/t),e=t/h(v,b)}r(e,ue)}}computeAttachmentOrigin(e,t){const i=e.data,s="getVertexAttr"in i?i.getVertexAttr():"vertexAttr"in i?i.vertexAttr:null;if(!s)return null;const r=s[Y.POSITION];return L(r,null,!1,t)}createBufferWriter(){const e=this.params.vertexColors?k:J;return r(this.params.stipplePattern)?new K(e):new ne(e.clone().vec3f(Y.AUXPOS1))}getGLMaterial(e){return 0===e.output||4===e.output?new ae(e):void 0}}class ae extends B{constructor(e){super(e),this.updateParameters()}updateParameters(){this.technique=this.techniqueRep.acquireAndReleaseExisting(te,this.material.getTechniqueConfig(this.output),this.technique)}beginSlot(e){return 3===e}_updateOccludeeState(e){e.hasOccludees!==this.material.params.sceneHasOcludees&&(this.material.setParameterValues({sceneHasOcludees:e.hasOccludees}),this.updateParameters())}ensureParameters(e){0===this.output&&this._updateOccludeeState(e)}bind(e,t){e.bindProgram(this.technique.program),this.technique.bindPass(e,this.material.getPassParameters(),t)}getPipelineState(e,t){return this.technique.getPipelineState(t)}}class ne{constructor(e){this.vertexBufferLayout=e}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){return e.indices[Y.POSITION].length}write(e,t,i,s){H(t,this.vertexBufferLayout,e.transformation,e.invTranspTransformation,i,s),this.writeAuxpos1(e,t,i,s)}writeAuxpos1(e,t,i,s){const r=i.getField(Y.AUXPOS1,m),a=t.indices[Y.POSITION],n=t.vertexAttr[Y.POSITION].data,o=e.transformation,l=r.typedBufferStride,p=r.typedBuffer;s*=l;for(let e=0;e<a.length;e+=2){const t=3*a[e],i=n[t],r=n[t+1],c=n[t+2],u=o[0]*i+o[4]*r+o[8]*c+o[12],d=o[1]*i+o[5]*r+o[9]*c+o[13],h=o[2]*i+o[6]*r+o[10]*c+o[14];for(let e=0;e<2;++e)p[s]=u,p[s+1]=d,p[s+2]=h,s+=l}}}const oe={color:[1,1,1,1],vertexColors:!1,slicePlaneEnabled:!1,width:1,stipplePattern:null,stippleIntegerRepeats:!1,stippleOffColor:null,sceneHasOcludees:!1,...V},le=a(),pe=a(),ce=a(),ue=a(),de=f(),he=f(),fe=a(),me=a(),ge=G.create(),Pe=G.create(),ve=a(),be=[f(),f(),f(),f()],xe=[a(),a(),a(),a()],Ce=$.create(),Oe=$.create(),Se=$.create(),Ee=$.create();export{re as N};
