/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import"./object.js";import{i as e}from"./Logger.js";import{all as t}from"../core/promiseUtils.js";import s from"../core/Error.js";import{a as o,c as n}from"./number.js";import i from"../Color.js";import a from"../symbols/ExtrudeSymbol3DLayer.js";import r from"../symbols/SimpleLineSymbol.js";import l from"../symbols/FillSymbol3DLayer.js";import m from"../symbols/IconSymbol3DLayer.js";import u from"../symbols/LineSymbol3DLayer.js";import c from"../symbols/ObjectSymbol3DLayer.js";import f from"../symbols/PathSymbol3DLayer.js";import d from"../symbols/LineSymbol3D.js";import p from"../symbols/MeshSymbol3D.js";import y from"../symbols/PointSymbol3D.js";import w from"../symbols/PolygonSymbol3D.js";import h from"../symbols/SimpleFillSymbol.js";import b from"../symbols/SimpleMarkerSymbol.js";import"../symbols/support/jsonUtils.js";import{a as g}from"./PointSizeSplatAlgorithm.js";import v from"../renderers/visualVariables/SizeVariable.js";import{c as j,g as z}from"./layerUtils2.js";import{a as D}from"./scaleUtils.js";import{s as S}from"./spatialStatistics.js";import{d as x,e as V,f as U}from"./utils5.js";import{r as L}from"./numberUtils.js";import T from"../smartMapping/statistics/summaryStatistics.js";import k from"../smartMapping/statistics/classBreaks.js";import{getBackgroundColorTheme as I}from"../views/support/colorUtils.js";const M=[{size:10,width:0},{size:20,width:.5},{size:80,width:1},{size:250,width:2}];async function F(t){const{layerAdapter:o,...n}=await async function(t){const{view:o}=t;if(!(t&&o&&t.layer))throw new s("outline:missing-parameters","'view' and 'layer' parameters are required");const n=[0,2,3,1],{layer:i,...a}=t,r=j(i,n),l={layerAdapter:r,...a};if(!r)throw new s("outline:invalid-parameters","'layer' must be one of these types: "+z(n).join(", "));await o.when();const m=e(l.signal)?{signal:l.signal}:null;if(await r.load(m),"polygon"!==r.geometryType)throw new s("outline:not-supported",`outline is not supported for geometryType: ${r.geometryType}`);return l}(t),i=await o.getSampleFeatures({sampleSize:-1,returnGeometry:!0,...n}),a=await S({features:i,geometryType:o.geometryType});if(!("avgSize"in a)||!a.avgSize)throw new s("outline:insufficient-info","average polygon size is invalid");return function(e,t){const s=e.avgSize,o=D(1,t.spatialReference),n=M.map((e=>({size:e.width,value:Math.round(s/e.size*o)})));return n.sort(((e,t)=>e.value-t.value)),{visualVariables:[new v({target:"outline",valueExpression:"$view.scale",stops:n})],opacity:.25}}(a,n.view)}const B=/^(\d+(\.\d+)?)\s*(%)$/i,A=[0,0,0,.4],C=["hours","minutes","seconds"],P=[].concat(U.light).concat(U.dark);function R(e,t,s){if("string"==typeof e){const t=s.getField(e);if(t&&"date"===t.type)return t.alias||t.name}else if("number"==typeof e||e instanceof Date){const s=C.indexOf(t)>-1?"short-date-short-time":"short-date";return o(e,n(s))}return e}function q(e,t){return new s(e,t)}function E(e,t,s){return e+t>0&&0>e-t&&s<0?0:e}function O(e,t,s,o,n=!0){const i="90-10"===s&&t?{min:t.classBreakInfos[0].maxValue,max:t.classBreakInfos[t.classBreakInfos.length-1].minValue,avg:null,stddev:null}:e,{avg:a,stddev:r,min:l,max:m}=i,u=Y(i,o,n);let c=u?u[0]:l,f=u?u[1]:m;return u?{minDataValue:c,maxDataValue:f,defaultValuesUsed:!0}:("above"===s?c=E(a,r,l):"below"===s&&(f=E(a,r,l)),{minDataValue:c,maxDataValue:f,defaultValuesUsed:!1})}function Y(e,t,s){let o,n;const i=function(e){let t,s,o=e&&e.statistics;o||(o={});if(null==o.min)if(e.isDate){const e=$();t=e[0],s=e[1]}else t=0,s=100;else if(o.min===o.max)if(e.isDate){const e=$(o.min);t=e[0],s=e[1]}else o.min<0?(t=2*o.min,s=0):o.min>0?(t=0,s=2*o.min):(t=0,s=100);return{min:null!=t?t:o.min,max:null!=s?s:o.max,defaultValuesUsed:null!=t||null!=s}}({statistics:e,isDate:t});return i.defaultValuesUsed?(o=i.min,n=i.max):!s||null!=e.avg&&e.stddev||(o=e.min,n=e.max),null!=o?[o,n]:null}function $(e){const t=("number"==typeof e?new Date(e):new Date).getUTCFullYear();let s=Date.UTC(t,0,1,12,0,0,0),o=Date.UTC(t,11,31,12,0,0,0);return"number"==typeof e&&(e<s&&(s=e),e>o&&(o=e)),[s,o]}function W(e,t){const s=[],o=e.length;for(let n=0;n<t;n++)s.push(new i(e[n%o]));return s}function G(e,t,s,o=!0){const{minDataValue:n,maxDataValue:i,defaultValuesUsed:a}=e;return a||"above"===s||"below"===s||"90-10"===s?H(n,i,5):J(t,o)}function N(e){const{avg:t,stddev:s,min:o,max:n}=e;if(null==t||null==s)return H(o,n,5);const i=E(t,s,o),a=n-i,r=i-o,l=Math.max(a,r);return L([i-l,i-l/2,i,l/2+i,i+l],{strictBounds:!0})}function H(e,t,s){const o=(t-e)/(s-1),n=[e];for(let t=1;t<=s-2;t++)n.push(e+t*o);return n.push(t),L(n,{strictBounds:!0})}function J(e,t=!0){let s=e.avg,o=s-e.stddev,n=s+e.stddev;o<e.min&&(o=e.min),n>e.max&&(n=e.max),t&&(s=o+(n-o)/2);let i=L([o,n],{strictBounds:!0});return o=i[0],n=i[1],i=[o,o+(s-o)/2,s,s+(n-s)/2,n],L(i,{strictBounds:!0})}function K(e,t,s){switch(t){case"point":case"multipoint":return s?"noDataSize"in e?e.noDataSize:null:"size"in e?e.size:null;case"polyline":return s?"noDataWidth"in e?e.noDataWidth:null:"width"in e?e.width:null;case"polygon":return"size"in e?e.size:null;case"mesh":default:return}}function Q(e,t,s){switch(t){case"point":case"multipoint":case"polygon":{if(!("outline"in e))return null;const t={color:e.outline.color,width:e.outline.width};if(null!=s&&t.color){const e=t.color.clone();e.a=s,t.color=e}return t}case"polyline":case"mesh":default:return}}function X(e,t){const{type:s,size:o,color:n,outline:i}=t;let g;switch(e){case"point":case"multipoint":if("2d"===s)g=new b({color:n,size:o,outline:{color:i.color,width:i.width}});else if("3d-flat"===s)g=new y({symbolLayers:[new m({size:o,resource:{primitive:"circle"},material:{color:n},outline:{color:i.color,size:i.width}})]});else if(s.indexOf("3d-volumetric")>-1){const e="3d-volumetric-uniform"===s,i=new c({height:o,resource:{primitive:e?"sphere":"cylinder"},material:{color:n}});e||(i.width=t.widthAndDepth,i.depth=t.widthAndDepth),g=new y({symbolLayers:[i]})}break;case"polyline":"2d"===s?g=new r({color:n,width:o}):"3d-flat"===s?g=new d({symbolLayers:[new u({size:o,material:{color:n}})]}):"3d-volumetric"===s&&(g=new d({symbolLayers:[new f({size:o,material:{color:n}})]}));break;case"polygon":"2d"===s?g=new h({color:n,outline:{color:i.color,width:i.width}}):"3d-flat"===s?g=new w({symbolLayers:[new l({material:{color:n},outline:{color:i.color,size:i.width}})]}):"3d-volumetric"===s&&(g=new w({symbolLayers:[new a({size:o,material:{color:n}})]}));break;case"mesh":{const e=t.meshInfo&&t.meshInfo.colorMixMode,s=t.meshInfo&&t.meshInfo.edgesType;g=new p({symbolLayers:[new l({material:{color:n,colorMixMode:e},edges:null==s||"none"===s?null:{type:s,color:A}})]});break}}return g}function Z(e,t,s){const o=function(e){const t=e.layer;return e.fields.filter((e=>!t.getField(e)))}({layer:e,fields:t});if(o.length)return q(s,"Unknown fields: "+o.join(", ")+". You can only use fields defined in the layer schema");const n=function(e){const t=e.layer;return e.fields.filter((e=>{const s=t.getFieldUsageInfo(e);return!s||!s.supportsRenderer}))}({layer:e,fields:t});return n.length?q(s,"Unsupported fields: "+n.join(", ")+". You can only use fields that are accessible to the renderer i.e. FieldUsageInfo.supportsRenderer must be true"):void 0}async function _(e,s){const o={layer:e.layer,view:e.view,signal:e.signal},[n,i]=await t([k(e),s?F(o):null]),a=Y({min:n.minValue,max:n.maxValue,avg:null,stddev:null},!1,!1);return{result:a?await k({...e,classificationMethod:"equal-interval",numClasses:1,analyzeData:!1,minValue:a[0],maxValue:a[1],normalizationTotal:a[0]+a[1]}):n,defaultValuesUsed:!!a,outlineResult:i}}function ee(e){return T(e)}function te(e,t){let{minSize:s,maxSize:o}=e;if("height"===t){s=((o-s)/2+s)/(2*2.3),o*=2}return{minSize:s,maxSize:o}}function se(e){return B.test(e)}function oe(e){const t=e.match(B),s=Number(t[1]);if("%"===t[3])return new g({scaleFactor:s/100})}function ne(e,t,s,o){e.startTime=t instanceof Date?t.getTime():t,e.endTime=s instanceof Date?s.getTime():s,e.units=o,e.field="string"==typeof t?t:"string"==typeof s?s:null}async function ie(t,s){let o=null,n=null;if(!t&&!s)return{basemapId:o,basemapTheme:n};var i;!t&&s&&(t=s&&(null==(i=s.map)?void 0:i.basemap));if(t&&(o=x(t,P,!1),o)){const t=V(o);e(t)&&(n=t)}return o||"2d"!==(null==s?void 0:s.type)||(n=await I(s),e(n)&&(o="dark"===n?"dark-gray":"gray")),{basemapId:o,basemapTheme:n}}export{_ as a,oe as b,q as c,W as d,Y as e,R as f,ee as g,J as h,se as i,O as j,G as k,X as l,K as m,Q as n,F as o,ie as p,H as q,te as r,N as s,ne as u,Z as v};
