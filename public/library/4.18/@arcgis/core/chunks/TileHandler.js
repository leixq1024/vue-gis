/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{h as t}from"./object.js";import{i as e,b as i}from"./Logger.js";import{all as s,resolve as r,create as h,throwIfAborted as a,isAbortError as o,eachAlways as n}from"../core/promiseUtils.js";import l from"../request.js";import{b as c}from"./MemCache.js";import{I as u}from"./ItemCache.js";import{c as g}from"./aaBoundingRect.js";import{open as _}from"../core/workers/workers.js";import{P as p}from"./pbf.js";import{T as d}from"./TileKey.js";import{T as f}from"./TileIndex.js";import{R as m}from"./Rect.js";import{T as y}from"./isWebGL2Context.js";import"./RenderingContext.js";import{a as w}from"./VectorTile.js";class x{constructor(t,e){this._width=0,this._height=0,this._free=[],this._width=t,this._height=e,this._free.push(new m(0,0,t,e))}get width(){return this._width}get height(){return this._height}allocate(t,e){if(t>this._width||e>this._height)return new m;let i=null,s=-1;for(let r=0;r<this._free.length;++r){const h=this._free[r];t<=h.width&&e<=h.height&&(null===i||h.y<=i.y&&h.x<=i.x)&&(i=h,s=r)}return null===i?new m:(this._free.splice(s,1),i.width<i.height?(i.width>t&&this._free.push(new m(i.x+t,i.y,i.width-t,e)),i.height>e&&this._free.push(new m(i.x,i.y+e,i.width,i.height-e))):(i.width>t&&this._free.push(new m(i.x+t,i.y,i.width-t,i.height)),i.height>e&&this._free.push(new m(i.x,i.y+e,t,i.height-e))),new m(i.x,i.y,t,e))}release(t){for(let e=0;e<this._free.length;++e){const i=this._free[e];if(i.y===t.y&&i.height===t.height&&i.x+i.width===t.x)i.width+=t.width;else if(i.x===t.x&&i.width===t.width&&i.y+i.height===t.y)i.height+=t.height;else if(t.y===i.y&&t.height===i.height&&t.x+t.width===i.x)i.x=t.x,i.width+=t.width;else{if(t.x!==i.x||t.width!==i.width||t.y+t.height!==i.y)continue;i.y=t.y,i.height+=t.height}this._free.splice(e,1),this.release(t)}this._free.push(t)}}class b{constructor(t,e,i){this.width=0,this.height=0,this._dirties=[],this._glyphData=[],this._currentPage=0,this._glyphIndex={},this._textures=[],this._rangePromises=new Map,this.width=t,this.height=e,this._glyphSource=i,this._binPack=new x(t-4,e-4),this._glyphData.push(new Uint8Array(t*e)),this._dirties.push(!0),this._textures.push(void 0)}getGlyphItems(t,e){const i=[],r=this._glyphSource,h=new Set;for(const t of e){const e=Math.floor(.00390625*t);h.add(e)}const a=[];return h.forEach((e=>{if(e<=256){const i=t+e;if(this._rangePromises.has(i))a.push(this._rangePromises.get(i));else{const s=r.getRange(t,e).then((()=>{this._rangePromises.delete(i)}),(()=>{this._rangePromises.delete(i)}));this._rangePromises.set(i,s),a.push(s)}}})),s(a).then((()=>{let s,h=this._glyphIndex[t];h||(h={},this._glyphIndex[t]=h),s=e;for(const e of s){const s=h[e];if(s){i[e]={sdf:!0,rect:s.rect,metrics:s.metrics,page:s.page,code:e};continue}const a=r.getGlyph(t,e);if(!a||!a.metrics)continue;const o=a.metrics;let n;if(0===o.width)n=new m(0,0,0,0);else{const t=3,e=o.width+2*t,i=o.height+2*t;let s=e%4?4-e%4:4,r=i%4?4-i%4:4;1===s&&(s=5),1===r&&(r=5),n=this._binPack.allocate(e+s,i+r),n.isEmpty&&(this._dirties[this._currentPage]||(this._glyphData[this._currentPage]=null),this._currentPage=this._glyphData.length,this._glyphData.push(new Uint8Array(this.width*this.height)),this._dirties.push(!0),this._textures.push(void 0),this._binPack=new x(this.width-4,this.height-4),n=this._binPack.allocate(e+s,i+r));const h=this._glyphData[this._currentPage],l=a.bitmap;let c,u;if(l)for(let t=0;t<i;t++){c=e*t,u=this.width*(n.y+t+1)+n.x;for(let t=0;t<e;t++)h[u+t+1]=l[c+t]}}h[e]={rect:n,metrics:o,tileIDs:null,page:this._currentPage},i[e]={sdf:!0,rect:n,metrics:o,page:this._currentPage,code:e},this._dirties[this._currentPage]=!0}return i}))}removeGlyphs(t){for(const e in this._glyphIndex){const i=this._glyphIndex[e];if(!i)continue;let s;for(const e in i)if(s=i[e],s.tileIDs.delete(t),0===s.tileIDs.size){const t=this._glyphData[s.page],r=s.rect;let h,a;for(let e=0;e<r.height;e++)for(h=this.width*(r.y+e)+r.x,a=0;a<r.width;a++)t[h+a]=0;delete i[e],this._dirties[s.page]=!0}}}bind(t,e,i,s=0){this._textures[i]||(this._textures[i]=new y(t,{pixelFormat:6406,dataType:5121,width:this.width,height:this.height},new Uint8Array(this.width*this.height)));const r=this._textures[i];r.setSamplingMode(e),this._dirties[i]&&r.setData(this._glyphData[i]),t.bindTexture(r,s),this._dirties[i]=!1}dispose(){this._binPack=null;for(const t of this._textures)t&&t.dispose();this._textures.length=0}}class R{constructor(t){if(this._metrics=[],this._bitmaps=[],t)for(;t.next();)switch(t.tag()){case 1:{const e=t.getMessage();for(;e.next();)switch(e.tag()){case 3:{const t=e.getMessage();let i,s,r,h,a,o,n;for(;t.next();)switch(t.tag()){case 1:i=t.getUInt32();break;case 2:s=t.getBytes();break;case 3:r=t.getUInt32();break;case 4:h=t.getUInt32();break;case 5:a=t.getSInt32();break;case 6:o=t.getSInt32();break;case 7:n=t.getUInt32();break;default:t.skip()}t.release(),i&&(this._metrics[i]={width:r,height:h,left:a,top:o,advance:n},this._bitmaps[i]=s);break}default:e.skip()}e.release();break}default:t.skip()}}getMetrics(t){return this._metrics[t]}getBitmap(t){return this._bitmaps[t]}}class S{constructor(){this._ranges=[]}getRange(t){return this._ranges[t]}addRange(t,e){this._ranges[t]=e}}class T{constructor(t){this._glyphInfo={},this._baseURL=t}getRange(t,e){const i=this._getFontStack(t);if(i.getRange(e))return r();const s=256*e,h=s+255,a=this._baseURL.replace("{fontstack}",t).replace("{range}",s+"-"+h);return l(a,{responseType:"array-buffer"}).then((t=>{i.addRange(e,new R(new p(new Uint8Array(t.data),new DataView(t.data))))})).catch((()=>{i.addRange(e,new R)}))}getGlyph(t,e){const i=this._getFontStack(t);if(!i)return;const s=Math.floor(e/256);if(s>256)return;const r=i.getRange(s);return r?{metrics:r.getMetrics(e),bitmap:r.getBitmap(e)}:void 0}_getFontStack(t){let e=this._glyphInfo[t];return e||(e=this._glyphInfo[t]=new S),e}}class P{constructor(t,e,i=0){this._size=[],this._mosaicsData=[],this._textures=[],this._dirties=[],this._maxItemSize=0,this._currentPage=0,this._pageWidth=0,this._pageHeight=0,this._mosaicRects={},this.pixelRatio=1,(t<=0||e<=0)&&console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"),this._pageWidth=t,this._pageHeight=e,i>0&&(this._maxItemSize=i),this._binPack=new x(t-4,e-4)}getWidth(t){return t>=this._size.length?-1:this._size[t][0]}getHeight(t){return t>=this._size.length?-1:this._size[t][1]}setSpriteSource(t){if(this.dispose(),this.pixelRatio=t.devicePixelRatio,0===this._mosaicsData.length){this._binPack=new x(this._pageWidth-4,this._pageHeight-4);const t=Math.floor(this._pageWidth),e=Math.floor(this._pageHeight),i=new Uint32Array(t*e);this._mosaicsData[0]=i,this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0)}this._sprites=t}getSpriteItem(t,e=!1){let i=this._mosaicRects[t];if(i)return i;if(!this._sprites||"loaded"!==this._sprites.loadStatus)return null;const s=this._sprites.getSpriteInfo(t);if(!s||!s.width||!s.height||s.width<0||s.height<0)return null;const r=s.width,h=s.height,[a,o,n]=this._allocateImage(r,h);return a.width<=0?null:(this._copy(a,s,o,n,e),i={rect:a,width:r,height:h,sdf:s.sdf,simplePattern:!1,pixelRatio:s.pixelRatio,page:o},this._mosaicRects[t]=i,i)}preloadSpriteItems(){for(const t of this._sprites.spriteNames)this.getSpriteItem(t,!0)}getSpriteItems(t){const e={};for(const i of t)e[i]=this.getSpriteItem(i);return e}getMosaicItemPosition(t,e){const i=this.getSpriteItem(t,e),s=i&&i.rect;if(!s)return null;s.width=i.width,s.height=i.height;const r=i.width,h=i.height,a=this._size[i.page];return{size:[i.width,i.height],tl:[(s.x+2)/a[0],(s.y+2)/a[1]],br:[(s.x+2+r)/a[0],(s.y+2+h)/a[1]],page:i.page}}bind(t,e,i=0,s=0){this._textures[i]||(this._textures[i]=new y(t,{pixelFormat:6408,dataType:5121,wrapMode:33071,width:this._size[i][0],height:this._size[i][1]},new Uint8Array(this._mosaicsData[i].buffer)));const r=this._textures[i];r.setSamplingMode(e),this._dirties[i]&&r.setData(new Uint8Array(this._mosaicsData[i].buffer)),t.bindTexture(r,s),this._dirties[i]=!1}static _copyBits(t,e,i,s,r,h,a,o,n,l,c){let u=s*e+i,g=o*h+a;if(c){g-=h;for(let a=-1;a<=l;a++,u=((a+l)%l+s)*e+i,g+=h)for(let e=-1;e<=n;e++)r[g+e]=t[u+(e+n)%n]}else for(let i=0;i<l;i++){for(let e=0;e<n;e++)r[g+e]=t[u+e];u+=e,g+=h}}_copy(t,e,i,s,r,h){if(!this._sprites||"loaded"!==this._sprites.loadStatus||i>=this._mosaicsData.length)return;const a=new Uint32Array(h?h.buffer:this._sprites.image.buffer),o=this._mosaicsData[i];o&&a||console.error("Source or target images are uninitialized!");const n=h?e.width:this._sprites.width;P._copyBits(a,n,e.x,e.y,o,s[0],t.x+2,t.y+2,e.width,e.height,r),this._dirties[i]=!0}_allocateImage(t,e){t+=2,e+=2;const i=Math.max(t,e);if(this._maxItemSize&&this._maxItemSize<i){const i=new m(0,0,t,e);return this._mosaicsData.push(new Uint32Array(t*e)),this._dirties.push(!0),this._size.push([t,e]),this._textures.push(void 0),[i,this._mosaicsData.length-1,[t,e]]}let s=t%4?4-t%4:4,r=e%4?4-e%4:4;1===s&&(s=5),1===r&&(r=5);const h=this._binPack.allocate(t+s,e+r);return h.width<=0?(this._dirties[this._currentPage]||(this._mosaicsData[this._currentPage]=null),this._currentPage=this._mosaicsData.length,this._mosaicsData.push(new Uint32Array(this._pageWidth*this._pageHeight)),this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0),this._binPack=new x(this._pageWidth-4,this._pageHeight-4),this._allocateImage(t,e)):[h,this._currentPage,[this._pageWidth,this._pageHeight]]}dispose(){this._binPack=null,this._mosaicRects={};for(const t of this._textures)t&&t.dispose();this._textures.length=0}}function M(t,e,i,s,r,h){t.fillStyle=e,t.fillRect(i,s,r,h)}function I(t,e,i,s,r,h){t.strokeStyle=e,t.strokeRect(i,s,r,h)}function D(t,e){t.strokeStyle="black";const i=e.cellSize,s=e.rows,r=e.columns;for(let h=0;h<s;h++){const s=e.cells[h],a=h*i,o=(h+1)*i;for(let e=0;e<r;e++){const r=s[e],h=e*i,n=(e+1)*i;t.strokeRect(h,a,n-h,o-a),t.fillText(`cells:${r.length}`,h+4,a+12)}}}function v(t,e){const i=window.COLLISION_XRAY;for(let s=0;s<e.length;++s){const r=!e[s].unique.show;if(i||!r)for(const h of e[s].colliders){if(!h.enabled)continue;const a=!e[s].unique.parts[h.partIndex].show;if(!i&&a)continue;const o=h.xScreen,n=h.yScreen,l=h.dxScreen,c=h.dyScreen;t.globalAlpha=r||a?.2:1,M(t,"green",o-1,n-1,3,3),I(t,"red",o+l,n+c,h.width,h.height),M(t,"blue",o+l-1,n+c-1,3,3),t.globalAlpha=1}}}const k=new u(10),L=new Map;class U{constructor(t,e,i,s){this._vectorTileLayer=t,this._styleRepository=e,this.devicePixelRatio=i,this._memCache=s,this._spriteMosaic=null,this._glyphMosaic=null,this._connection=null,this._ongoingTileRequests=new Map,this._ongoingRequestToController=new Map}destroy(){this._ongoingTileRequests&&this.abortAll(),this._connection&&(this._connection.close(),this._connection=null),this._styleRepository=null,this._vectorTileLayer=null,this._spriteMosaic&&(this._spriteMosaic=null),this._glyphMosaic&&(this._glyphMosaic=null)}get spriteMosaic(){return this._spriteSourcePromise.then((()=>this._spriteMosaic))}get glyphMosaic(){return this._glyphMosaic}async start(e){const i=this._vectorTileLayer,r=i.sourceNameToSource,h=[];for(const t in r)h.push(this._fetchTileMap(r[t],e));this._spriteSourcePromise=this._vectorTileLayer.loadSpriteSource(this.devicePixelRatio,e),this._spriteSourcePromise.then((t=>{this._spriteMosaic=new P(1024,1024,250),this._spriteMosaic.setSpriteSource(t)}));const a=this._styleRepository,o=new T(a.glyphs);return this._glyphMosaic=new b(1024,1024,o),this._broadcastPromise=_("WorkerTileHandler",{client:this,scheduler:e.scheduler,signal:e.signal}).then((r=>(this._connection=r,s(this._connection.broadcast("setStyle",{style:i.currentStyleInfo.style,vectorTileLayerMaxBuffers:t("vectortilelayer-max-buffers")},e))))),s(h)}async updateStyle(t){return await this._broadcastPromise,this._broadcastPromise=h(((e,i)=>{s(this._connection.broadcast("updateStyle",t)).then(e,i)})),this._broadcastPromise}async setStyle(e,i){await this._broadcastPromise,this._styleRepository=e;const r=this._vectorTileLayer.sourceNameToSource,a=[];for(const t in r)a.push(this._fetchTileMap(r[t],null));this._spriteSourcePromise=this._vectorTileLayer.loadSpriteSource(this.devicePixelRatio,null),this._spriteSourcePromise.then((t=>{this._spriteMosaic=new P(1024,1024,250),this._spriteMosaic.setSpriteSource(t)}));const o=new T(e.glyphs);return this._glyphMosaic=new b(1024,1024,o),this._broadcastPromise=h(((e,r)=>{s(this._connection.broadcast("setStyle",{style:i,vectorTileLayerMaxBuffers:t("vectortilelayer-max-buffers")})).then(e,r)})),a.push(this._broadcastPromise),s(a)}getVectorTile(t,i,s,h){const o=new d(t,i,s,0);if(e(this._memCache)){const t=this._memCache.get(o.id);if(e(t))return t.reference(),r(t)}return this._getVectorTileData(o).then((t=>{if(a(h),e(this._memCache)){const t=this._memCache.get(o.id);if(e(t))return t.reference(),t}if(!this._vectorTileLayer)return null;const i=this._vectorTileLayer.tileInfo.getTileBounds(g(),o),s=new w(o,this._styleRepository,i,[512,512]);if(t&&t.tileData){if(s.setData(t.tileData),e(this._memCache)){s.reference();const t=s.getMemoryUsage();t>0&&this._memCache.put(s.key.id,s,t*s.referenced,c)}}else s.setData(null);return s}))}releaseVectorTile(t){i(this._memCache)||t.release()||this._memCache.updateSize(t.key.id,t,t.getMemoryUsage()*t.referenced)}fetchTileData(t,e){return this._getRefKeys(t,e).then((t=>{const i=this._vectorTileLayer.sourceNameToSource,s=[];for(const t in i)s.push(t);return this._getSourcesData(s,t,e)}))}parseTileData(e,i){const s=e&&e.data;if(!s)return r(null);const{sourceName2DataAndRefKey:h,transferList:a}=s;return 0===Object.keys(h).length?r(null):this._broadcastPromise.then((()=>this._connection.getAvailableClient().then((s=>s.invoke("createTileAndParse",{key:e.key.id,sourceName2DataAndRefKey:h,styleLayerUIDs:e.styleLayerUIDs},{...i,transferList:a}).then((e=>{if(t("esri-vector-tiles-debug")){const t={};for(const e in h)t[e]=h[e].refKey;return{tileData:e,refKeys:t}}return{tileData:e}}))))))}get updating(){return this._ongoingTileRequests.size>0}abortAll(){this._ongoingRequestToController.forEach((t=>t.abort())),this._ongoingRequestToController.clear(),this._ongoingTileRequests.clear()}async getSprites(t){return await this._spriteSourcePromise,this._spriteMosaic.getSpriteItems(t)}getGlyphs(t){return this._glyphMosaic.getGlyphItems(t.font,t.codePoints)}perfReport({key:t,milliseconds:e}){!function(t,e,i){if(!window.PERFORMANCE_RECORDING_STORAGE)return;const s=window.PERFORMANCE_RECORDING_STORAGE;s.perf=s.perf||{};const r=s.perf;r[t]=r[t]||{start:null,time:0,min:void 0,max:void 0,samples:[],unit:i},r[t].time+=e,r[t].samples.push(e),(null==r[t].min||e<r[t].min)&&(r[t].min=e),(null==r[t].max||e>r[t].max)&&(r[t].max=e)}(t,e,"ms")}async _getTilePayload(t,e,i){const s=d.pool.acquire(t.id),r=this._vectorTileLayer.sourceNameToSource[e].getSourceTileUrl(s.level,s.row,s.col);d.pool.release(s);try{return{protobuff:(await l(r,{responseType:"array-buffer",...i})).data,sourceName:e}}catch(t){if(o(t))throw t;return{protobuff:null,sourceName:e}}}async _fetchTileMap(t,e){if(t.capabilities.operations.supportsTileMap&&t.tileIndex)return r();if(!t.tileMapURL)return;const i=k.get(t.tileMapURL);if(i)return void(t.tileIndex=i);let s;if(L.has(t.tileMapURL)){try{s=await L.get(t.tileMapURL),t.tileIndex=new f(s.data)}catch(t){if(o(t))throw t}return}const h=l(t.tileMapURL,e);L.set(t.tileMapURL,h);try{s=await h,L.delete(t.tileMapURL),k.put(t.tileMapURL,t.tileIndex),t.tileIndex=new f(s.data)}catch(e){if(L.delete(t.tileMapURL),o(e))throw e}}_getRefKeys(t,e){const i=this._vectorTileLayer.sourceNameToSource,s=new Array;for(const r in i){const h=i[r].getRefKey(t,e);s.push(h)}return n(s)}_getSourcesData(t,e,i){const s=[];for(let r=0;r<e.length;r++)if(null==e[r].value||null==t[r])s.push(null);else{const h=this._getTilePayload(e[r].value,t[r],i);s.push(h)}return n(s).then((t=>{const i={},s=[];for(let r=0;r<t.length;r++)if(t[r].value&&t[r].value&&t[r].value.protobuff&&t[r].value.protobuff.byteLength>0){const h=e[r].value.id;i[t[r].value.sourceName]={refKey:h,protobuff:t[r].value.protobuff},s.push(t[r].value.protobuff)}return{sourceName2DataAndRefKey:i,transferList:s}}))}_getVectorTileData(t){const e=t.id;if(this._ongoingTileRequests.has(e))return this._ongoingTileRequests.get(e);const i=new AbortController,s={signal:i.signal},r=this._getParsedVectorTileData(t,s).then((t=>(this._ongoingTileRequests.delete(e),this._ongoingRequestToController.delete(e),t))).catch((()=>(this._ongoingTileRequests.delete(e),this._ongoingRequestToController.delete(e),null)));return this._ongoingTileRequests.set(e,r),this._ongoingRequestToController.set(e,i),r}_getParsedVectorTileData(t,e){return this.fetchTileData(t,e).then((i=>this.parseTileData({key:t,data:i},e)))}}export{U as T,v as a,D as d};
