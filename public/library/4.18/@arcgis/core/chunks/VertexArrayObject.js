/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import"./object.js";import{a as t,i as e}from"../core/lang.js";import{b as i}from"./Logger.js";class r{constructor(t,e,i,r,n){this._context=null,this._glName=null,this._bufferType=void 0,this._usage=35044,this._size=-1,this._indexType=void 0,this.id=s++,t.instanceCounter.increment(1,this),this._context=t,this._bufferType=e,this._usage=i,this._glName=this._context.gl.createBuffer(),r&&this.setData(r,n)}static createIndex(t,e,i,s){return new r(t,34963,e,i,s)}static createVertex(t,e,i){return new r(t,34962,e,i)}get glName(){return this._glName}get size(){return this._size}get usage(){return this._usage}get bufferType(){return this._bufferType}get indexType(){return this._indexType}get byteSize(){return 34962===this._bufferType?this._size:5125===this._indexType?4*this._size:2*this._size}dispose(){if(this._context){if(this._glName){this._context.gl.deleteBuffer(this._glName),this._glName=null}this._context.instanceCounter.decrement(1,this),this._context=null}}setData(i,r){if(!i)return;if("number"==typeof i){if(i<0&&console.error("Buffer size cannot be negative!"),34963===this._bufferType&&r)switch(this._indexType=r,this._size=i,r){case 5123:i*=2;break;case 5125:i*=4}}else{let r=i.byteLength;t(i)&&(r/=2,this._indexType=5123),e(i)&&(r/=4,this._indexType=5125),this._size=r}const s=this._context.getBoundVAO();this._context.bindVAO(null),this._context.bindBuffer(this);this._context.gl.bufferData(this._bufferType,i,this._usage),this._context.bindVAO(s)}setSubData(i,r=0,s=0,n){if(!i)return;(r<0||r>=this._size)&&console.error("offset is out of range!");let o=r,a=s,c=n,u=i.byteLength;t(i)&&(u/=2,o*=2,a*=2,c*=2),e(i)&&(u/=4,o*=4,a*=4,c*=4),void 0===n&&(n=u-1),s>=n&&console.error("end must be bigger than start!"),r+s-n>this._size&&console.error("An attempt to write beyond the end of the buffer!");const f=this._context.getBoundVAO();this._context.bindVAO(null),this._context.bindBuffer(this);const h=this._context.gl,l=ArrayBuffer.isView(i)?i.buffer:i;h.bufferSubData(this._bufferType,o,l.slice(a,c)),this._context.bindVAO(f)}}let s=0;function n(t,e){return t.vertexBuffers[e].size/o(t.layout[e])}function o(t){return t[0].stride}function a(t,e,i,r,s){const n=t.gl,o=t.capabilities.instancing;t.bindBuffer(i);for(const t of r){const i=e[t.name],r=(s||(0+t.baseInstance?t.baseInstance:0))*t.stride;if(void 0===i&&console.error(`There is no location for vertex attribute '${t.name}' defined.`),t.baseInstance&&!t.divisor&&console.error(`Vertex attribute '${t.name}' uses baseInstanceOffset without divisor.`),t.count<=4)n.vertexAttribPointer(i,t.count,t.type,t.normalized,t.stride,t.offset+r),n.enableVertexAttribArray(i),t.divisor&&t.divisor>0&&o&&o.vertexAttribDivisor(i,t.divisor);else if(9===t.count)for(let e=0;e<3;e++)n.vertexAttribPointer(i+e,3,t.type,t.normalized,t.stride,t.offset+12*e+r),n.enableVertexAttribArray(i+e),t.divisor&&t.divisor>0&&o&&o.vertexAttribDivisor(i+e,t.divisor);else if(16===t.count)for(let e=0;e<4;e++)n.vertexAttribPointer(i+e,4,t.type,t.normalized,t.stride,t.offset+16*e+r),n.enableVertexAttribArray(i+e),t.divisor&&t.divisor>0&&o&&o.vertexAttribDivisor(i+e,t.divisor);else console.error("Unsupported vertex attribute element count: "+t.count)}}function c(t,e,i,r){const s=t.gl,n=t.capabilities.instancing;t.bindBuffer(i);for(const t of r){const i=e[t.name];if(t.count<=4)s.disableVertexAttribArray(i),t.divisor&&t.divisor>0&&n&&n.vertexAttribDivisor(i,0);else if(9===t.count)for(let e=0;e<3;e++)s.disableVertexAttribArray(i+e),t.divisor&&t.divisor>0&&n&&n.vertexAttribDivisor(i+e,0);else if(16===t.count)for(let e=0;e<4;e++)s.disableVertexAttribArray(i+e),t.divisor&&t.divisor>0&&n&&n.vertexAttribDivisor(i+e,0);else console.error("Unsupported vertex attribute element count: "+t.count)}t.unbindBuffer(34962)}function u(t){if(i(t))return 0;if("colorAttachment"in t)return t.glName?u(t.colorAttachment)+u(t.depthStencilAttachment):0;if("descriptor"in t)return t.glName?u(t.descriptor):0;const e=t.internalFormat||"pixelFormat"in t&&t.pixelFormat;if(!e)return 0;const r="hasMipmap"in t&&t.hasMipmap?1.3:1,s=t.width*t.height;return function(t){switch(t){case 6406:case 6409:return 1;case 6410:return 2;case 6407:return 3;case 6408:case 34041:return 4;case 33325:return 2;case 33326:case 35898:case 33327:return 4;case 33328:case 34842:return 8;case 34836:return 16;case 33189:return 2;case 34041:return 4;case 32854:return 2;case 36168:return 1}return 0}(e)*s*r}class f{constructor(t,e,i,r,s){this._context=t,this._locations=e,this._layout=i,this._buffers=r,this._indexBuffer=s,this._glName=null,this.id=h++,this._initialized=!1,t.instanceCounter.increment(2,this)}get glName(){return this._glName}get vertexBuffers(){return this._buffers}get indexBuffer(){return this._indexBuffer}get size(){return Object.keys(this._buffers).reduce(((t,e)=>t+this._buffers[e].size),this._indexBuffer?this._indexBuffer.size:0)}get layout(){return this._layout}get locations(){return this._locations}dispose(t=!0){if(!this._context)return;const e=this._context.capabilities.vao;e&&this._glName&&(e.deleteVertexArray(this._glName),this._glName=null);if(this._context.getBoundVAO()===this&&this._context.bindVAO(null),t){for(const t in this._buffers)this._buffers[t].dispose(),delete this._buffers[t];this._indexBuffer&&(this._indexBuffer.dispose(),this._indexBuffer=null)}this._context.instanceCounter.decrement(2,this),this._context=null}initialize(){if(this._initialized)return;const t=this._context.capabilities.vao;if(t){const e=t.createVertexArray();t.bindVertexArray(e),this._bindLayout(),t.bindVertexArray(null),this._glName=e}this._initialized=!0}bind(){this.initialize();const t=this._context.capabilities.vao;t?t.bindVertexArray(this.glName):(this._context.bindVAO(null),this._bindLayout())}_bindLayout(){const t=this._buffers,e=!!this._context.capabilities.vao,i=this._layout,r=this._indexBuffer;t||console.error("Vertex buffer dictionary is empty!");const s=this._context.gl;for(const e in t){const r=t[e];r||console.error("Vertex buffer is uninitialized!");const s=i[e];s||console.error("Vertex element descriptor is empty!"),a(this._context,this._locations,r,s)}r&&(e?s.bindBuffer(s.ELEMENT_ARRAY_BUFFER,r.glName):this._context.bindBuffer(r))}unbind(){this.initialize();const t=this._context.capabilities.vao;t?t.bindVertexArray(null):this._unbindLayout()}_unbindLayout(){const t=this._buffers,e=this._layout;t||console.error("Vertex buffer dictionary is empty!");for(const i in t){const r=t[i];r||console.error("Vertex buffer is uninitialized!");const s=e[i];c(this._context,this._locations,r,s)}const i=this._indexBuffer;i&&this._context.unbindBuffer(i.bufferType)}}let h=0;export{r as B,f as V,o as a,a as b,u as g,c as u,n as v};
