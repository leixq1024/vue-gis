/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{b as e,i as t}from"./Logger.js";import{a as o}from"./mat3f32.js";import{C as s,F as i}from"./config.js";import{G as n,t as r}from"./VectorTile.js";function l(e,t,o,s,i,n){const{iconRotationAlignment:r,textRotationAlignment:l,iconTranslate:c,iconTranslateAnchor:a,textTranslate:h,textTranslateAnchor:y}=s;let u=0;for(const s of e.colliders){const[e,f]=0===s.partIndex?c:h,m=0===s.partIndex?a:y,b=s.minLod<=n&&n<=s.maxLod;u+=b?0:1,s.enabled=b,s.xScreen=s.xTile*i[0]+s.yTile*i[3]+i[6],s.yScreen=s.xTile*i[1]+s.yTile*i[4]+i[7],0===m?(s.xScreen+=o*e-t*f,s.yScreen+=t*e+o*f):(s.xScreen+=e,s.yScreen+=f),1===(0===s.partIndex?r:l)?(s.dxScreen=s.dxPixels,s.dyScreen=s.dyPixels):(s.dxScreen=o*(s.dxPixels+s.width/2)-t*(s.dyPixels+s.height/2)-s.width/2,s.dyScreen=t*(s.dxPixels+s.width/2)+o*(s.dyPixels+s.height/2)-s.height/2)}e.colliders.length>0&&u===e.colliders.length&&(e.unique.show=!1)}class c{constructor(e,t,i,r,l,c){this._symbols=e,this._styleRepository=r,this._zoom=l,this._currentLayerCursor=0,this._currentSymbolCursor=0,this._styleProps=new Map,this._allNeededMatrices=new Map,this._gridIndex=new n(t,i,s),this._si=Math.sin(Math.PI*c/180),this._co=Math.cos(Math.PI*c/180);for(const t of e)for(const e of t.symbols)this._allNeededMatrices.has(e.tile)||this._allNeededMatrices.set(e.tile,o(e.tile.transforms.tileUnitsToPixels))}work(e){const t=this._gridIndex;function o(e){const o=e.xScreen+e.dxScreen,s=e.yScreen+e.dyScreen,i=o+e.width,n=s+e.height,[r,l,c,a]=t.getCellSpan(o,s,i,n);for(let e=l;e<=a;e++)for(let l=r;l<=c;l++){const r=t.cells[e][l];for(const e of r){const t=e.xScreen+e.dxScreen,r=e.yScreen+e.dyScreen,l=t+e.width,c=r+e.height;if(!(i<t||o>l||n<r||s>c))return!0}}return!1}const s=performance.now();for(;this._currentLayerCursor<this._symbols.length;this._currentLayerCursor++,this._currentSymbolCursor=0){const t=this._symbols[this._currentLayerCursor],i=this._getProperties(t.styleLayerUID);for(;this._currentSymbolCursor<t.symbols.length;this._currentSymbolCursor++){if(this._currentSymbolCursor%100==99&&performance.now()-s>e)return!1;const n=t.symbols[this._currentSymbolCursor];if(!n.unique.show)continue;l(n,this._si,this._co,i,this._allNeededMatrices.get(n.tile),this._zoom);const r=n.unique;if(!r.show)continue;const{iconAllowOverlap:c,iconIgnorePlacement:a,textAllowOverlap:h,textIgnorePlacement:y}=i;for(const e of n.colliders){if(!e.enabled)continue;const t=r.parts[e.partIndex];if(!t.show)continue;!(e.partIndex?h:c)&&o(e)&&(e.hard?r.show=!1:t.show=!1)}if(r.show)for(const e of n.colliders){if(!e.enabled)continue;if(e.partIndex?y:a)continue;if(!r.parts[e.partIndex].show)continue;const t=e.xScreen+e.dxScreen,o=e.yScreen+e.dyScreen,s=t+e.width,i=o+e.height,[n,l,c,h]=this._gridIndex.getCellSpan(t,o,s,i);for(let t=l;t<=h;t++)for(let o=n;o<=c;o++){this._gridIndex.cells[t][o].push(e)}}}}return!0}_getProperties(e){const t=this._styleProps.get(e);if(t)return t;const o=this._zoom,s=this._styleRepository.getStyleLayerByUID(e),i=0!==s.getLayoutValue("symbol-placement",o);let n=s.getLayoutValue("icon-rotation-alignment",o);2===n&&(n=i?0:1);let r=s.getLayoutValue("text-rotation-alignment",o);2===r&&(r=i?0:1);const l=s.getPaintValue("icon-translate",o),c=s.getPaintValue("icon-translate-anchor",o),a=s.getPaintValue("text-translate",o),h=s.getPaintValue("text-translate-anchor",o),y={iconAllowOverlap:s.getLayoutValue("icon-allow-overlap",o),iconIgnorePlacement:s.getLayoutValue("icon-ignore-placement",o),textAllowOverlap:s.getLayoutValue("text-allow-overlap",o),textIgnorePlacement:s.getLayoutValue("text-ignore-placement",o),iconRotationAlignment:n,textRotationAlignment:r,iconTranslateAnchor:c,iconTranslate:l,textTranslateAnchor:h,textTranslate:a};return this._styleProps.set(e,y),y}}function a(e,t){if(e.priority-t.priority)return e.priority-t.priority;const o=e.tile.key,s=t.tile.key;return o.world-s.world?o.world-s.world:o.level-s.level?o.level-s.level:o.row-s.row?o.row-s.row:o.col-s.col?o.col-s.col:e.xTile-t.xTile?e.xTile-t.xTile:e.yTile-t.yTile}class h{constructor(e,t,o,s,i,n){this._visibleTiles=e,this._symbolRepository=t,this._createCollisionJob=o,this._assignTileSymbolsOpacity=s,this._symbolLayerSorter=i,this._isLayerVisible=n,this._selectionJob=null,this._selectionJobCompleted=!1,this._collisionJob=null,this._collisionJobCompleted=!1,this._opacityJob=null,this._opacityJobCompleted=!1,this._running=!0}get running(){return this._running}setScreenSize(e,t){this._screenWidth===e&&this._screenHeight===t||this.restart(),this._screenWidth=e,this._screenHeight=t}restart(){this._selectionJob=null,this._selectionJobCompleted=!1,this._collisionJob=null,this._collisionJobCompleted=!1,this._opacityJob=null,this._opacityJobCompleted=!1,this._running=!0}continue(e){if(this._selectionJob||(this._selectionJob=this._createSelectionJob()),!this._selectionJobCompleted){const t=performance.now();if(!this._selectionJob.work(e))return!1;if(this._selectionJobCompleted=!0,0===(e=Math.max(0,e-(performance.now()-t))))return!1}if(this._collisionJob||(this._collisionJob=this._createCollisionJob(this._selectionJob.sortedSymbols,this._screenWidth,this._screenHeight)),!this._collisionJobCompleted){const t=performance.now();if(!this._collisionJob.work(e))return!1;if(this._collisionJobCompleted=!0,0===(e=Math.max(0,e-(performance.now()-t))))return!1}if(this._opacityJob||(this._opacityJob=this._createOpacityJob()),!this._opacityJobCompleted){const t=performance.now();if(!this._opacityJob.work(e))return!1;if(this._opacityJobCompleted=!0,0===(e=Math.max(0,e-(performance.now()-t))))return!1}return this._running=!1,!0}_createSelectionJob(){const e=this._symbolRepository.uniqueSymbols,t=[];let o=0,s=0;const i=this._isLayerVisible;const n=this._symbolLayerSorter;return{work:function(n){let r;const l=performance.now();for(;s<e.length;s++,o=0){const c=e[s],a=c.styleLayerUID;if(!i(a)){t[s]||(t[s]={styleLayerUID:a,symbols:[]});continue}t[s]=t[s]||{styleLayerUID:a,symbols:[]};const h=t[s];for(;o<c.uniqueSymbols.length;o++){if(r=c.uniqueSymbols[o],o%100==99&&performance.now()-l>n)return!1;let e=null,t=!1,s=!1;for(const o of r.tileSymbols)if(o.selectedForRendering=!1,!s||!t){const i=o.tile;(!e||i.isCoverage||i.neededForCoverage&&!t)&&(e=o,(i.neededForCoverage||i.isCoverage)&&(s=!0),i.isCoverage&&(t=!0))}if(e.selectedForRendering=!0,s){h.symbols.push(e),r.show=!0;for(const e of r.parts)e.show=!0}else r.show=!1}}for(const e of t)e.symbols.sort(a);return!0},get sortedSymbols(){return t.sort(n)}}}_createOpacityJob(){const e=this._assignTileSymbolsOpacity,t=this._visibleTiles;let o=0;function s(t,o){const i=t.symbols;for(const[e,t]of i)y(t,o);e(t,o);for(const e of t.childrenTiles)s(e,o)}return{work(e){const i=performance.now();for(;o<t.length;o++){if(performance.now()-i>e)return!1;const n=t[o];if(n.parentTile)continue;s(n,performance.now())}return!0}}}}function y(e,t){for(const o of e){const e=o.unique;for(const o of e.parts){const s=o.targetOpacity>.5?1:-1;o.startOpacity+=s*((t-o.startTime)/i),o.startOpacity=Math.min(Math.max(o.startOpacity,0),1),o.startTime=t,o.targetOpacity=e.show&&o.show?1:0}}}class u{constructor(e,t,o){this.tileCoordRange=e,this._visibleTiles=t,this._createUnique=o,this._tiles=new Map,this._uniqueSymbolsReferences=new Map}get uniqueSymbols(){return e(this._uniqueSymbolLayerArray)&&(this._uniqueSymbolLayerArray=this._createUniqueSymbolLayerArray()),this._uniqueSymbolLayerArray}add(e,t){this._uniqueSymbolLayerArray=null;let o=this._tiles.get(e.id);o||(o={symbols:new Map},this._tiles.set(e.id,o));const s=new Map;if(t)for(const e of t)o.symbols.has(e)&&(s.set(e,o.symbols.get(e)),o.symbols.delete(e));else for(const[t,i]of e.layerData)o.symbols.has(t)&&(s.set(t,o.symbols.get(t)),o.symbols.delete(t));this._removeSymbols(s);const i=e.symbols,r=new Map;for(const[e,t]of i){let s=t.length;if(s>=32){let i=this.tileCoordRange;do{i/=2,s/=4}while(s>8&&i>64);const l=new n(this.tileCoordRange,this.tileCoordRange,i);r.set(e,{flat:t,index:l}),o.symbols.set(e,{flat:t,index:l});for(const e of t)l.getCell(e.xTile,e.yTile).push(e)}else r.set(e,{flat:t}),o.symbols.set(e,{flat:t})}this._addSymbols(e.key,i)}deleteStyleLayers(e){this._uniqueSymbolLayerArray=null;for(const[t,o]of this._tiles){const s=new Map;for(const t of e)o.symbols.has(t)&&(s.set(t,o.symbols.get(t)),o.symbols.delete(t));this._removeSymbols(s),0===o.symbols.size&&this._tiles.delete(t)}}removeTile(e){this._uniqueSymbolLayerArray=null;const t=this._tiles.get(e.id);if(!t)return;const o=new Map;for(const[s,i]of e.symbols)t.symbols.has(s)&&(o.set(s,t.symbols.get(s)),t.symbols.delete(s));this._removeSymbols(o),0===t.symbols.size&&this._tiles.delete(e.id)}_removeSymbols(e){for(const[t,{flat:o}]of e)for(const e of o){const o=e.unique,s=o.tileSymbols,i=s.length-1;for(let t=0;t<i;t++)if(s[t]===e){s[t]=s[i];break}if(s.length=i,0===i){const e=this._uniqueSymbolsReferences.get(t);e.delete(o),0===e.size&&this._uniqueSymbolsReferences.delete(t)}e.unique=null}}_addSymbols(t,o){if(0===o.size)return;const s=this._visibleTiles;for(const e of s)e.parentTile||e.key.world!==t.world||e.key.level===t.level&&!e.key.equals(t)||this._matchSymbols(e,t,o);for(const[t,s]of o)for(const o of s)if(e(o.unique)){const e=this._createUnique();o.unique=e,e.tileSymbols.push(o);let s=this._uniqueSymbolsReferences.get(t);s||(s=new Set,this._uniqueSymbolsReferences.set(t,s)),s.add(e)}}_matchSymbols(e,o,s){if(e.key.level>o.level){const t=e.key.level-o.level;if(e.key.row>>t!==o.row||e.key.col>>t!==o.col)return}if(o.level>e.key.level){const t=o.level-e.key.level;if(o.row>>t!==e.key.row||o.col>>t!==e.key.col)return}if(o.equals(e.key)){for(const t of e.childrenTiles)this._matchSymbols(t,o,s);return}const i=new Map;for(const[n,l]of s){const s=[];for(const t of l){const i=r(this.tileCoordRange,t.xTile,o.level,o.col,e.key.level,e.key.col),n=r(this.tileCoordRange,t.yTile,o.level,o.row,e.key.level,e.key.row);i>=0&&i<this.tileCoordRange&&n>=0&&n<this.tileCoordRange&&s.push({symbol:t,xTransformed:i,yTransformed:n})}const c=[],a=e.key.level<o.level?1:1<<e.key.level-o.level,h=this._tiles.get(e.id).symbols.get(n);if(h){const e=h.flat;for(const o of s){let s,i=!1;const n=o.xTransformed,r=o.yTransformed;s=t(h.index)?h.index.getCell(n,r):e;const l=o.symbol,y=l.hash;for(const e of s)if(y===e.hash&&Math.abs(n-e.xTile)<=a&&Math.abs(r-e.yTile)<=a){const t=e.unique;l.unique=t,t.tileSymbols.push(l),i=!0;break}i||c.push(l)}}c.length>0&&i.set(n,c)}for(const t of e.childrenTiles)this._matchSymbols(t,o,i)}_createUniqueSymbolLayerArray(){const e=this._uniqueSymbolsReferences,t=new Array(e.size);let o,s=0;for(const[i,n]of e){const e=new Array(n.size);o=0;for(const t of n)e[o++]=t;t[s]={styleLayerUID:i,uniqueSymbols:e},s++}return t}}export{c as C,u as S,h as a};
