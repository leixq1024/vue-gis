/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{_ as e}from"./tslib.es6.js";import"./object.js";import{clone as t}from"../core/lang.js";import{b as r,i as o}from"./Logger.js";import{property as n}from"../core/accessorSupport/decorators/property.js";import"./ensureType.js";import"../core/accessorSupport/decorators/subclass.js";import"../core/urlUtils.js";import"./resourceExtension.js";import{fixFields as s,unpackFieldNames as i}from"../layers/support/fieldUtils.js";import a from"../views/layers/LayerView.js";import{a as u}from"./attributeUtils.js";const l={setAttribute(){},rollback(){},commit(){}};function c(e,o){const n=t(o.attributes),s=new Set,i=n[e.objectIdField];if(null==i)return l;const a=e.attributeOverrides.createInteractiveEditSession(i),u=new Map;let c=0;return{setAttribute(t,n){if(0!==c)return;const l=e.fieldsIndex.get(t);if(r(l))return;const d=e.attributeStorageInfo.findIndex((e=>e.name===l.name));if(d<0)return;a.set(d,n);const f=e.attributeStorageInfo[d];let m=!1;s.add(t),e.forEachNode(((t,r)=>{const s=((e,t)=>{const r=u.get(e);if(null==r){const r=t.indexOf(i);return u.set(e,r),r}return r})(t,r);if(-1===s)return;const a=e.getAttributeData(t.index);if(a){const r=a[f.name];r&&(r[s]=n,e.setAttributeData(t.index,a,o),m=!0)}})),m&&e.clearMemCache()},rollback(){if(0===c){for(const e of s)this.setAttribute(e,n[e]);a.rollback(),c=1}},commit(){a.commit(),c=2}}}function d(e,t){const r=function(e,t){const r=t.edits.updateFeatures;if(!r||0===r.length)return new p;const o=function(e){const t=new Set;if(!e.updatedFeatures)return t;for(const r of e.updatedFeatures)null!=r.objectId&&null==r.error&&t.add(r.objectId);return t}(t),n=new p,s=new Map;for(let t=0;t<e.attributeStorageInfo.length;t++)s.set(e.attributeStorageInfo[t].name,t);const i=e.fieldsIndex,a=e.objectIdField,l=r.filter((e=>{const t=u(i,e.attributes,a);return o.has(t)}));return e.forEachNode(((t,r)=>{const o=new Set(r);for(const s of l){const l=u(i,s.attributes,a);if(!o.has(l))continue;const c=r.indexOf(l);for(const r in s.attributes){const o=e.fieldsIndex.normalizeFieldName(r),i=f(n,t.index,o),a=s.attributes[r];i.push({featureIndex:c,featureId:l,value:a})}}})),n}(e,t);if(0===r.size)return;const n=new Map;for(let t=0;t<e.attributeStorageInfo.length;t++)n.set(e.attributeStorageInfo[t].name,t);let s=!1;r.forEach(((t,r)=>{const i=e.getAttributeData(r);let a=!1;t.forEach(((t,r)=>{const u=o(i)?i[r]:null,l=n.get(r);for(const{featureIndex:r,value:o,featureId:n}of t)u&&(u[r]=o,a=!0,s=!0),e.attributeOverrides.updateValue(n,l,o)})),a&&e.setAttributeData(r,i,null)})),s&&e.clearMemCache()}function f(e,t,r){const o=function(e,t){const r=e.get(t);if(r)return r;const o=new m;return e.set(t,o),o}(e,t),n=o.get(r);if(n)return n;const s=new Array;return o.set(r,s),s}const m=Map,p=Map;function b(){return{requiredFields:{type:[String],readOnly:!0},availableFields:{type:[String],readOnly:!0,dependsOn:["layer.fields","layer.outFields","requiredFields"],get:function(){const{layer:e,layer:{fields:t},requiredFields:r}=this;return e.outFields?s(t,[...i(t,e.outFields),...r]):s(t,r)}}}}class g extends a{constructor(){super(...arguments),this.filter=null}get availableFields(){return[]}get maximumNumberOfFeatures(){return 0}set maximumNumberOfFeatures(e){throw new Error("Not implemented")}get maximumNumberOfFeaturesExceeded(){return!1}highlight(e){throw new Error("Not implemented")}queryFeatures(e,t){throw new Error("Not implemented")}queryObjectIds(e,t){throw new Error("Not implemented")}queryFeatureCount(e,t){throw new Error("Not implemented")}createQuery(){throw new Error("Not implemented")}queryExtent(e,t){throw new Error("Not implemented")}}e([n()],g.prototype,"availableFields",null),e([n()],g.prototype,"maximumNumberOfFeatures",null),e([n({readOnly:!0})],g.prototype,"maximumNumberOfFeaturesExceeded",null),e([n()],g.prototype,"filter",void 0);export{g as S,c,b as d,d as p};
