/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{L as t}from"./Logger.js";import{C as e,u as s,j as i}from"./definitions.js";import{B as r}from"./BidiText.js";import{f as o}from"./vec2f32.js";import{s as h,f as n}from"./Utils10.js";class a{constructor(){this.vertexData=new Map,this.vertexCount=0,this.indexData=[]}clear(){this.vertexData.clear(),this.vertexCount=0,this.indexData=[]}update(t,e,s){for(const e in t)this.vertexData.set(e,t[e]);for(const e in this.vertexData)null===t[e]&&this.vertexData.delete(e);this.vertexCount=e,this.indexData=s}}class u{constructor(t,e,s,i=0,r=0){this.id=t,this.geometryType=e,this.materialKey=s,this.minZoom=i,this.maxZoom=r,this.meshData=null,this.symbolLevel=0,this.zOrder=0,this.vertexFrom=0,this.vertexCount=0,this.indexFrom=0,this.indexCount=0}get sortKey(){return void 0===this._sortKey&&this._computeSortKey(),this._sortKey}clone(){return this.copy()}copy(){const t=new u(this.id,this.geometryType,this.materialKey);return t.vertexFrom=this.vertexFrom,t.vertexCount=this.vertexCount,t.indexFrom=this.indexFrom,t.indexCount=this.indexCount,t.zOrder=this.zOrder,t.symbolLevel=this.symbolLevel,t.meshData=this.meshData,t.minZoom=this.minZoom,t.maxZoom=this.maxZoom,t}setMeshDataFromBuffers(t,e,s){const i=new a;for(const s in e){const r=e[s].stride,o=e[s].data,n=[],a=h(r);for(let e=0;e<r*t.vertexCount/a;++e)n[e]=o[e+r*t.vertexFrom/a];i.vertexData.set(s,n)}i.indexData.length=0;for(let e=0;e<t.indexCount;++e)i.indexData[e]=s[e+t.indexFrom]-t.vertexFrom;i.vertexCount=t.vertexCount,this.meshData=i}readMeshDataFromBuffers(t,e){this.meshData?this.meshData.clear():this.meshData=new a;for(const e in t){const s=t[e].stride,i=t[e].data,r=[],o=h(s);for(let t=0;t<s*this.vertexCount/o;++t)r[t]=i[t+s*this.vertexFrom/o];this.meshData.vertexData.set(e,r)}this.meshData.indexData.length=0;for(let t=0;t<this.indexCount;++t)this.meshData.indexData[t]=e[t+this.indexFrom]-this.vertexFrom;this.meshData.vertexCount=this.vertexCount}writeMeshDataToBuffers(t,e,s,i){for(const s in e){const i=e[s].stride,r=this.meshData.vertexData.get(s),o=e[s].data,n=h(i);for(let e=0;e<i*this.meshData.vertexCount/n;++e)o[e+i*t/n]=r[e]}for(let e=0;e<this.meshData.indexData.length;++e)i[e+s]=this.meshData.indexData[e]+t;this.vertexFrom=t,this.vertexCount=this.meshData.vertexCount,this.indexFrom=s,this.indexCount=this.meshData.indexData.length}static writeAllMeshDataToBuffers(t,e,s){let i=0,r=0;for(const o of t)o.writeMeshDataToBuffers(i,e,r,s),i+=o.vertexCount,r+=o.indexCount}_computeSortKey(){this._sortKey=(31&this.symbolLevel)<<12|(127&this.zOrder)<<4|7&this.geometryType}serialize(t){return t.push(this.geometryType),t.push(this.materialKey),t.push(this.vertexFrom),t.push(this.vertexCount),t.push(this.indexFrom),t.push(this.indexCount),t.push(this.minZoom),t.push(this.maxZoom),t}static deserialize(t,e){const s=t.readInt32(),i=t.readInt32(),r=new u(e.id,s,i);return r.vertexFrom=t.readInt32(),r.vertexCount=t.readInt32(),r.indexFrom=t.readInt32(),r.indexCount=t.readInt32(),r.minZoom=t.readInt32(),r.maxZoom=t.readInt32(),r}}function c(t,e){if(null!==e){t.push(e.length);for(const s of e)s.serialize(t);return t}t.push(0)}function f(t,e,s){const i=t.readInt32(),r=new Array(i);for(let i=0;i<r.length;i++)r[i]=e.deserialize(t,s);return r}const d=t.getLogger("esri/views/2d/engine/webgl/collisions/Metric");class l{constructor(t,e,s,i,r){this.id=t,this.range=e,this.boxes=null,this.minZoom=-1,this.size=0,this.directionX=0,this.directionY=0,this.offsetX=0,this.offsetY=0,this.placementPadding=0,this.anchor=o(s,i),this.baseZoom=r}add(t,e,s){t.x=t.x+e,t.y=t.y+s,this.bounds?this.boxes?(this.boxes.push(t),this.bounds.extend(t)):(this.boxes=[this.bounds,t],this.bounds=this.bounds.clone(),this.bounds.extend(t)):this.bounds=t}computeIndex(){const t=this.anchor[0],s=this.anchor[1],r=Math.floor(t/e),o=Math.floor(s/e);this.xBucket=r,this.yBucket=o;const h=i/e;if(this.hasVV)return this.xOverflow=h,void(this.yOverflow=h);this.xOverflow=Math.min(h,Math.ceil(2*this.bounds.width/e)),this.yOverflow=Math.min(h,Math.ceil(2*this.bounds.height/e))}findCollisionDelta(t){const e=this.bounds.findCollisionDelta(t.bounds),i=this.boxes&&this.boxes.length,r=t.boxes&&t.boxes.length;return Math.abs(e)>s||!i&&!r?e:i&&r?this._boxesToBoxes(t):i?this._boxesToBox(t):this._boxToBoxes(t)}computeVVOffset(t,e){e||d.error("mapview-labeling",`Unable to compute label offset. Expected an evaluator function but found ${e}`);let s=this.size;if(this.hasVV){const i=e(t);s=isNaN(i)||null==i||i===1/0?this.size:i}this._computeOffset(s)}setPlacementOffset(t,e,s,i,r){this.hasVV=t,this.size=e,this.placementPadding=Math.round(s),this.directionX=i,this.directionY=r}clone(){const t=new l(this.id,this.range,this.anchor[0],this.anchor[1],this.baseZoom);return t.minZoom=this.minZoom,this.bounds&&(t.bounds=this.bounds.clone()),this.boxes&&(t.boxes=this.boxes.map((t=>t.clone()))),t.xBucket=this.xBucket,t.yBucket=this.yBucket,t.xOverflow=this.xOverflow,t.yOverflow=this.yOverflow,t.hasVV=this.hasVV,t.size=this.size,t.directionX=this.directionX,t.directionY=this.directionY,t.offsetX=this.offsetX,t.offsetY=this.offsetY,t}_boxToBoxes(t){let e=-1/0;for(const s of t.boxes){const t=this.bounds.findCollisionDelta(s);e=Math.max(t,e)}return e}_boxesToBox(t){let e=this.boxes[0].findCollisionDelta(t.bounds);for(let s=1;s<this.boxes.length;s++){const i=this.boxes[s].findCollisionDelta(t.bounds);e=Math.max(i,e)}return e}_boxesToBoxes(t){let e=-1/0;for(let s=0;s<this.boxes.length;s++){const i=this.boxes[s];for(const s of t.boxes){const t=i.findCollisionDelta(s);e=Math.max(t,e)}}return e}_computeOffset(t){this.offsetX=this.directionX*(t/2+this.placementPadding),this.offsetY=this.directionY*(t/2+this.placementPadding)}serialize(t){return t.push(this.id),this.bounds.serialize(t),t.push(this.range.from),t.push(this.range.count),t.push(this.anchor[0]),t.push(this.anchor[1]),t.push(this.baseZoom),t.push(this.hasVV?1:0),t.push(this.size),t.writeF32(this.directionX),t.writeF32(this.directionY),t.push(this.offsetX),t.push(this.offsetY),t.push(this.placementPadding),c(t,this.boxes),t}static deserialize(t){const e=t.readInt32(),s=r.deserialize(t),i={from:t.readInt32(),count:t.readInt32()},o=t.readInt32(),h=t.readInt32(),n=t.readInt32(),a=t.readInt32(),u=t.readInt32(),c=t.readF32(),d=t.readF32(),p=t.readInt32(),b=t.readInt32(),x=t.readInt32(),_=f(t,r),m=new l(e,i,o,h,n);return m.bounds=s,m.boxes=_,m.setPlacementOffset(!!a,u,x,c,d),m.offsetX=p,m.offsetY=b,m.computeIndex(),a||m._computeOffset(u),m}}class p{constructor(t){this.insertAfter=null,this.id=t,this.displayRecords=[],this.metrics=[]}copy(){const t=new p(this.id);return t.set(this),t}clone(){const t=new p(this.id);return t.displayRecords=this.displayRecords.map((t=>t.clone())),t.metrics=this.metrics.map((t=>t.clone())),t.insertAfter=this.insertAfter,t}set(t){this.id=t.id,this.displayRecords=t.displayRecords,this.metrics=t.metrics,this.insertAfter=t.insertAfter}serialize(t){return t.push(this.id),c(t,this.metrics),c(t,this.displayRecords),t}static deserialize(t){const e=t.readInt32(),s=new p(e),i={id:e},r=f(t,l);return r.length&&(s.metrics=r),s.displayRecords=f(t,u,i),s}}class b{constructor(t){this._pos=0,this._buffer=t,this._i32View=new Int32Array(this._buffer),this._f32View=new Float32Array(this._buffer)}readInt32(){return this._i32View[this._pos++]}readF32(){return this._f32View[this._pos++]}}class x{constructor(t,e){this._pos=0;const s=e?this._roundToNearest(e,t.BYTES_PER_ELEMENT):40;this._array=new ArrayBuffer(s),this._buffer=new t(this._array),this._ctor=t}get length(){return this._pos}_roundToNearest(t,e){const s=Math.round(t);return s+(e-s%e)}_ensureSize(t){if(this._pos+t>=this._buffer.length){const e=this._roundToNearest(1.5*(this._array.byteLength+t*this._buffer.BYTES_PER_ELEMENT),this._buffer.BYTES_PER_ELEMENT),s=new ArrayBuffer(e),i=new this._ctor(s);i.set(this._buffer,0),this._array=s,this._buffer=i}}writeF32(t){this._ensureSize(1);const e=this._pos;return new Float32Array(this._array,4*this._pos,1)[0]=t,this._pos++,e}push(t){this._ensureSize(1);const e=this._pos;return this._buffer[this._pos++]=t,e}writeFixed(t){this._buffer[this._pos++]=t}setValue(t,e){this._buffer[t]=e}getValue(t){return this._buffer[t]}incr(t){this._buffer[t]++}decr(t){this._buffer[t]--}writeRegion(t){this._ensureSize(t.length);const e=this._pos;return this._buffer.set(t,this._pos),this._pos+=t.length,e}buffer(){const t=this._array.slice(0,4*this._pos);return this.destroy(),t}toArray(){const t=this._array,e=[];for(let s=0;s<t.byteLength/4;s++)e.push(t[s]);return e}seek(t){this._pos=t}destroy(){this._array=null,this._buffer=null}}class _{constructor(t,e){this.vertexVectorsMap=t,this._currentIndex=-1,this._currentRecordOffset=0,this._currentMetricOffset=0,this._currentMetrics=[];const s=4*(4*e.features+1),i=4*(8*e.records+1),r=4*(20*e.metrics+1);this._bufDisplayObjects=new x(Uint32Array,s+4),this._bufDisplayRecords=new x(Uint32Array,i+4),this._bufMetrics=new x(Uint32Array,r+4),this._bufDisplayObjects.push(0),this._bufDisplayRecords.push(0),this._bufMetrics.push(0)}get vertexBuffersMap(){if(!this._vertexBuffersMap){this._vertexBuffersMap={};for(let t=0;t<this.vertexVectorsMap.length;t++)this._vertexBuffersMap[t]=this.vertexVectorsMap[t].intoBuffers();this.vertexVectorsMap=null}return this._vertexBuffersMap}get(t){return this.vertexVectorsMap[t]}currentDisplayRecordCount(){return this._bufDisplayRecords[this._currentRecordOffset]}writeDisplayObject(t,e){this._bufDisplayObjects.incr(0),this._currentIndex=this._bufDisplayObjects.push(t),this._bufDisplayObjects.push(e),this._bufDisplayObjects.push(0),this._bufDisplayObjects.push(0),this._currentRecordOffset=0,this._currentMetricOffset=0,this._currentMetrics=[]}hasDisplayRecords(){return!(0===this._currentRecordOffset)}endDisplayObject(){this.hasDisplayRecords()?this._currentMetrics&&(0===this._currentMetricOffset&&(this._bufDisplayObjects.setValue(this._currentIndex+3,this._bufMetrics.length),this._currentMetricOffset=this._bufMetrics.length),c(this._bufMetrics,this._currentMetrics)):this._rollbackDisplayObject()}writeDisplayRecord(t,e,s,i,r,o,h=0,n=0){0===this._currentRecordOffset&&(this._currentRecordOffset=this._bufDisplayRecords.push(0),this._bufDisplayObjects.setValue(this._currentIndex+2,this._currentRecordOffset)),this._bufDisplayRecords.incr(this._currentRecordOffset),this._bufDisplayRecords.push(t),this._bufDisplayRecords.push(e),this._bufDisplayRecords.push(s),this._bufDisplayRecords.push(i),this._bufDisplayRecords.push(r),this._bufDisplayRecords.push(o),this._bufDisplayRecords.push(h),this._bufDisplayRecords.push(n)}writeMetrics(t){t&&this._currentMetrics.push(...t)}static deserializeDisplayObjects(t){const{bufDisplayObjects:e,bufMetrics:s,bufRecords:i}=t,r=new b(e),o=new b(i),h=new b(s),n=[];let a=r.readInt32();for(o.readInt32(),h.readInt32();a--;){const t=r.readInt32(),e=r.readInt32(),s=r.readInt32(),i=r.readInt32(),a=new p(t);0!==e&&(a.insertAfter=e),0!==s&&(a.displayRecords=f(o,u,{id:t})),0!==i&&(a.metrics=f(h,l)),n.push(a)}return n}encode(t,e){const s={};for(let t=0;t<this.vertexVectorsMap.length;t++){const i=this.vertexVectorsMap[t];s[t]={},i.transfer(s[t],e)}t.bufDisplayObjects=this._bufDisplayObjects.buffer(),t.bufRecords=this._bufDisplayRecords.buffer(),t.bufMetrics=this._bufMetrics.buffer(),e.push(t.bufDisplayObjects),e.push(t.bufMetrics),e.push(t.bufRecords),t.vertexBuffersMap=s,this.destroy()}destroy(){this.vertexVectorsMap=null,this._bufDisplayObjects=null,this._bufDisplayRecords=null,this._bufMetrics=null}_rollbackDisplayObject(){this._bufDisplayObjects.decr(0),this._bufDisplayObjects.seek(this._bufDisplayObjects.length-4),this._currentIndex=this._bufDisplayObjects.length}}class m{constructor(t,e,s){this.data=t,this.stride=e,this.vertexCount=s}static decode(t){const e=n(t.data,t.stride),s=t.stride,i=t.vertexCount;return new m(e,s,i)}static fromVertexVector(t){const e=n(t.data.buffer(),t.stride),s=t.stride,i=t.vertexCount;return new m(e,s,i)}}class y{constructor(t,e,s){this.geometryType=t,this.indexBuffer=new Uint32Array(e),this.namedBuffers=s}static decode(t){const e=t.geometryType,s=t.indexBuffer,i={};for(const e in t.namedBuffers)i[e]=m.decode(t.namedBuffers[e]);return new y(e,s,i)}static fromVertexVectors(t){const e=t.geometryType,s=t.indexVector.buffer(),i={};for(const e in t.namedVectors)i[e]=m.fromVertexVector(t.namedVectors[e]);return new y(e,s,i)}}export{l as M,y as V,x as W,_ as a,p as b,u as c,c as s};
