/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import"./object.js";import{s as e}from"../core/lang.js";import"../config.js";import{i as t}from"./Logger.js";import"./string.js";import{create as r,reject as n,resolve as o}from"../core/promiseUtils.js";import"./Message.js";import"../core/Error.js";import"../core/urlUtils.js";import"../kernel.js";import"../request.js";import{g as s}from"./assets.js";function i(e){return s(`esri/libs/i3s/${e}`)}let f,a,u;async function c(e){await L();const t=[e.geometryBuffer];return{result:p(e,t),transferList:t}}async function l(t){var r;await L();const n=[t.geometryBuffer],{geometryBuffer:o}=t,s=o.byteLength,i=u._malloc(s),f=new Uint8Array(u.HEAPU8.buffer,i,s);f.set(new Uint8Array(o));const a=u.dracoDecompressPointCloudData(i,f.byteLength);if(u._free(i),a.error.length>0)throw`i3s.wasm: ${a.error}`;const c=(null==(r=a.featureIds)?void 0:r.length)>0?e(a.featureIds):null,l=e(a.positions);c&&n.push(c.buffer),n.push(l.buffer);return{result:{positions:l,featureIds:c},transferList:n}}async function m(e){await L(),g(e);const t={buffer:e.buffer};return{result:t,transferList:[t.buffer]}}async function y(e){await L(),h(e)}async function b(e){await L(),u.setLegacySchema(e.context,e.jsonSchema)}function d(e){w(e)}function h(e){const t=e.modifications,r=u._malloc(8*t.length),n=new Float64Array(u.HEAPU8.buffer,r,t.length);for(let e=0;e<t.length;++e)n[e]=t[e];u.setModifications(e.context,r,t.length,e.isGeodetic),u._free(r)}function p(r,n){if(!u)return null;const{context:o,localOrigin:s,globalTrafo:i,mbs:f,obb:a,elevationOffset:c,geometryBuffer:l,geometryDescriptor:m,indexToVertexProjector:y,vertexToRenderProjector:b}=r,d=u._malloc(l.byteLength),h=u._malloc(33*Float64Array.BYTES_PER_ELEMENT),p=new Uint8Array(u.HEAPU8.buffer,d,l.byteLength);p.set(new Uint8Array(l));const E=new Float64Array(u.HEAPU8.buffer,h,33);A(E,s);let g=E.byteOffset+3*E.BYTES_PER_ELEMENT,w=new Float64Array(E.buffer,g);A(w,i),g+=16*E.BYTES_PER_ELEMENT,w=new Float64Array(E.buffer,g),A(w,f),g+=4*E.BYTES_PER_ELEMENT,t(a)&&(w=new Float64Array(E.buffer,g),A(w,a.center),g+=3*E.BYTES_PER_ELEMENT,w=new Float64Array(E.buffer,g),A(w,a.halfSize),g+=3*E.BYTES_PER_ELEMENT,w=new Float64Array(E.buffer,g),A(w,a.quaternion));const L=m,_={isDraco:!1,isLegacy:!1,color:r.layouts.some((e=>e.some((e=>"color"===e.name)))),normal:r.needNormals&&r.layouts.some((e=>e.some((e=>"normalCompressed"===e.name)))),uv0:r.layouts.some((e=>e.some((e=>"uv0"===e.name)))),uvRegion:r.layouts.some((e=>e.some((e=>"uvRegion"===e.name)))),featureIndex:L.featureIndex},T=u.process(o,!!r.obb,d,p.byteLength,L,_,h,c,y,b,r.normalReferenceFrame);if(u._free(h),u._free(d),T.error.length>0)throw`i3s.wasm: ${T.error}`;if(T.discarded)return null;const j=T.componentOffsets.length>0?e(T.componentOffsets):null,I=T.featureIds.length>0?e(T.featureIds):null,P=e(T.interleavedVertedData).buffer,U=1===T.indicesType?e(new Uint16Array(T.indices.buffer,T.indices.byteOffset,T.indices.byteLength/2)):e(new Uint32Array(T.indices.buffer,T.indices.byteOffset,T.indices.byteLength/4)),B=e(T.positions),F=1===T.positionIndicesType?e(new Uint16Array(T.positionIndices.buffer,T.positionIndices.byteOffset,T.positionIndices.byteLength/2)):e(new Uint32Array(T.positionIndices.buffer,T.positionIndices.byteOffset,T.positionIndices.byteLength/4)),R={layout:r.layouts[0],interleavedVertexData:P,indices:U,hasColors:T.hasColors,hasModifications:T.hasModifications,positionData:{data:B,indices:F}};return I&&n.push(I.buffer),j&&n.push(j.buffer),n.push(P),n.push(U.buffer),n.push(B.buffer),n.push(F.buffer),{componentOffsets:j,featureIds:I,transformedGeometry:R,obb:T.obb}}function E(e){return 0===e?0:1===e?1:2===e?2:3}function g(e){const{context:t,buffer:r}=e,n=u._malloc(r.byteLength),o=r.byteLength/Float64Array.BYTES_PER_ELEMENT,s=new Float64Array(u.HEAPU8.buffer,n,o),i=new Float64Array(r);s.set(i),u.filterOBBs(t,n,o),i.set(s),u._free(n)}function w(e){u&&u.destroy(e)}function A(e,t){for(let r=0;r<t.length;++r)e[r]=t[r]}function L(){return u?o():(a||(a=(f||(f=r((e=>import("./i3s.js").then((function(e){return e.i})).then((({default:t})=>{const r=t({locateFile:i,onRuntimeInitialized:()=>e(r)});delete r.then})))).catch((e=>n(e)))),f).then((e=>{u=e,a=null}))),a)}const _={transform:p,destroy:w};export{d as destroyContext,l as dracoDecompressPointCloudData,m as filterObbsForModifications,g as filterObbsForModificationsSync,L as initialize,E as interpretObbModificationResults,c as process,b as setLegacySchema,y as setModifications,h as setModificationsSync,_ as test};
