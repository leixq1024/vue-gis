/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{_ as t}from"../chunks/tslib.es6.js";import"../chunks/ArrayPool.js";import"../chunks/object.js";import"../chunks/deprecate.js";import{clone as e}from"../core/lang.js";import"../config.js";import{L as n,b as r}from"../chunks/Logger.js";import"../chunks/string.js";import"../chunks/metadata.js";import{property as o}from"../core/accessorSupport/decorators/property.js";import"../core/Accessor.js";import"../chunks/PropertyOrigin.js";import"../core/scheduling.js";import{create as s,throwIfAborted as i}from"../core/promiseUtils.js";import"../chunks/Message.js";import a from"../core/Error.js";import"../chunks/ensureType.js";import{subclass as c}from"../core/accessorSupport/decorators/subclass.js";import"../chunks/JSONSupport.js";import"../core/urlUtils.js";import"../core/accessorSupport/decorators/cast.js";import"../chunks/jsonMap.js";import"../chunks/reader.js";import"../chunks/writer.js";import"../chunks/resourceExtension.js";import"../chunks/persistableUrlUtils.js";import"./SpatialReference.js";import"../kernel.js";import"../request.js";import"../chunks/assets.js";import l from"./Geometry.js";import p from"./Point.js";import"../chunks/Ellipsoid.js";import"./support/webMercatorUtils.js";import u from"./Extent.js";import"../chunks/mathUtils2.js";import{c as f,Z as m,f as h}from"../chunks/vec3f64.js";import"../chunks/common.js";import{t as g,n as x,g as y,i as d,s as A}from"../chunks/vec3.js";import"../chunks/colorUtils.js";import"../Color.js";import"../chunks/zmUtils.js";import"./Multipoint.js";import w from"./Polygon.js";import"../chunks/extentUtils.js";import"./Polyline.js";import{f as v,h as j,i as b,c as k}from"../chunks/unitUtils.js";import{a as F,m as M,b as R,s as T,i as E,r as S}from"../chunks/mat4.js";import"../chunks/pe.js";import"../chunks/aaBoundingRect.js";import"../chunks/geodesicConstants.js";import"./support/GeographicTransformationStep.js";import"./support/GeographicTransformation.js";import{projectPointToVector as U,computeLinearTransformation as P}from"./projection.js";import{c as z}from"../chunks/vec4f64.js";import"../chunks/screenshotUtils.js";import"./support/MeshTexture.js";import"./support/MeshMaterial.js";import"./support/MeshMaterialMetallicRoughness.js";import O,{M as C}from"./support/MeshComponent.js";import"../chunks/earcut.js";import"../chunks/deduplicate.js";import{t as G}from"../chunks/triangulationUtils.js";import{c as L,a as W,b as $}from"../chunks/quatf64.js";import{f as B,n as N}from"../chunks/mat3.js";import{B as _,a as D}from"../chunks/BufferView.js";import"../chunks/vec2.js";import"../chunks/vec4.js";import{p as I,a as V,t as q,b as J,c as Y,d as Z,e as H}from"../chunks/projection.js";import{t as K,a as Q}from"../chunks/vec32.js";import{s as X,m as tt,g as et}from"../chunks/quat.js";const nt=n.getLogger("esri.geometry.support.meshUtils.centerAt");function rt(t,e,n){if(!t.vertexAttributes||!t.vertexAttributes.position)return;const r=t.spatialReference,o=r.isWGS84||r.isWebMercator&&(!n||!1!==n.geographic),s=n&&n.origin||t.extent.center;o?function(t,e,n){const r=t.spatialReference,o=v(r),s=st,i=ot;if(!U(e,i,o))return void nt.error(`Failed to project centerAt location (wkid:${e.spatialReference.wkid}) to ECEF`);U(n,s,o)||U(t.extent.center,s,o);const a=t.vertexAttributes.position,c=t.vertexAttributes.normal,l=new Float64Array(a.length),p=new Float32Array(c?c.length:0);I(a,r,l),c&&V(c,a,l,r,p);P(o,s,it,o),P(o,i,at,o),F(it,it),M(at,at,it),q(l,at),F(at,at),R(at,at),c&&q(p,at,!0);J(l,a,r),c&&Y(p,a,l,r,c);t.clearCache()}(t,e,s):function(t,e,n){const r=st,o=ot;if(!U(e,o,t.spatialReference))return void nt.error(`Failed to project centerAt location (wkid:${e.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid})`);if(!U(n,r,t.spatialReference)){const e=t.extent.center;r[0]=e.x,r[1]=e.y,r[2]=e.z,nt.error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}). Using mesh extent.center instead`)}(function(t,e,n){if(!t)return;for(let r=0;r<t.length;r+=3)for(let o=0;o<3;o++)t[r+o]+=e[o]-n[o]})(t.vertexAttributes.position,o,r),t.clearCache()}(t,e,s)}const ot=f(),st=f(),it=L(),at=L(),ct=n.getLogger("esri.geometry.support.triangleMeshMerge");function lt(t,e){if(0===t.length)return ct.error("merge()","Must specify one more more geometries to merge"),null;const n=t[0].spatialReference;if(t.some((t=>!t.spatialReference.equals(n))))return ct.error("merge()","Geometries must all be in the same spatial reference"),null;const r=function(t){let e=0,n=0,r=0,o=0,s=0;const i=function(t){let e=!1,n=!1,r=!1,o=!1;for(const s of t){const t=s.vertexAttributes;if(t&&t.position&&(t.uv&&(e=!0),t.normal&&(n=!0),t.tangent&&(o=!0),t.color&&(r=!0),n&&e&&r&&o))break}return{normal:n,uv:e,color:r,tangent:o}}(t);for(const a of t){const t=a.vertexAttributes;t&&t.position&&(e+=t.position.length,i.uv&&(n+=t.position.length/mt.position*mt.uv),i.normal&&(r+=t.position.length/mt.position*mt.normal),i.color&&(o+=t.position.length/mt.position*mt.color),i.tangent&&(s+=t.position.length/mt.position*mt.tangent))}return{position:new Float64Array(e),uv:n?new Float32Array(n):null,normal:r?new Float32Array(r):null,tangent:s?new Float32Array(s):null,color:o?new Uint8Array(o):null}}(t),o=[],s={position:0,uv:0,normal:0,tangent:0,color:0},i=new Map,a=new Map;for(const n of t){const t=n.vertexAttributes;if(e&&e.reuseMaterials&&n.components)for(const t of n.components)t.material&&i.set(t.material,t.material);ut(n,s,i,a,o),ft("position",t,r,s,0),ft("normal",t,r,s,0),ft("tangent",t,r,s,0),ft("uv",t,r,s,0),ft("color",t,r,s,255)}return{vertexAttributes:r,components:o,spatialReference:n}}function pt(t,e,n){(function(t,e){return e.normal>0&&!t.vertexAttributes.normal})(t,e)&&"source"===n.shading&&(n.shading="flat")}function ut(t,e,n,r,o){if(t.components)for(const s of t.components){const i=s.cloneWithDeduplication(n,r);for(let t=0;t<i.faces.length;t++)i.faces[t]+=e.position/3;pt(t,e,i),o.push(i)}else if(t.vertexAttributes&&t.vertexAttributes.position){const n=t.vertexAttributes.position.length/3,r=new Uint32Array(n);for(let t=0;t<n;t++)r[t]=t+e.position;const s=new O({faces:r});pt(t,e,s),o.push(s)}}function ft(t,e,n,r,o){if(!e)return;const s=e.position;if(!s)return;const i=e[t];if(i)!function(t,e,n,r,o){for(let s=0;s<o;s++)n[r++]=t[e++]}(i,0,n[t],r[t],i.length),r[t]+=i.length;else{const e=n[t];let i=r[t];const a=mt[t];if(e){for(let t=0;t<s.length;t+=3)for(let t=0;t<a;t++)e[i++]=o;r[t]=i}}}const mt={position:3,normal:3,tangent:4,uv:2,color:4};function ht(t,e,n){if(!t.vertexAttributes||!t.vertexAttributes.position)return;const r=t.spatialReference;r.isWGS84||r.isWebMercator&&(!n||!1!==n.geographic)?function(t,e){const n=t.spatialReference,r=t.vertexAttributes.position,o=t.vertexAttributes.normal,s=t.vertexAttributes.tangent,i=new Float64Array(r.length),a=new Float32Array(o?o.length:0),c=new Float32Array(s?s.length:0),l=t.extent.center,p=xt;P(n,[l.x,l.y,l.z],yt,v(n)),B(dt,yt),g(p,e,dt),I(r,n,i),o&&V(o,r,i,n,a);s&&Z(s,r,i,n,c);gt(i,p),J(i,r,n),o&&Y(a,r,i,n,o);s&&H(c,r,i,n,s);t.clearCache()}(t,e):function(t,e){gt(t.vertexAttributes.position,e),t.clearCache()}(t,e)}function gt(t,e){if(t)for(let n=0;n<t.length;n+=3)for(let r=0;r<3;r++)t[n+r]+=e[r]}const xt=f(),yt=L(),dt=W();function At(t,e,n){return jt(e,n)?function(t,e,n){const r=e.spatialReference,o=vt(e,n,kt),s=new Float64Array(t.position.length),i=function(t,e,n,r){K(_.fromTypedArray(r),_.fromTypedArray(t),e);const o=new Float64Array(t.length);return J(r,o,n)}(t.position,o,r,s),a=N(Mt,o),c=function(t,e,n,r,o){if(!n)return null;const s=new Float32Array(n.length);return Q(D.fromTypedArray(s),D.fromTypedArray(n),r),Y(s,t,e,o,s),s}(i,s,t.normal,a,r),l=function(t,e,n,r,o){if(!n)return null;const s=new Float32Array(n.length);Q(D.fromTypedArray(s,4*Float32Array.BYTES_PER_ELEMENT),D.fromTypedArray(n,4*Float32Array.BYTES_PER_ELEMENT),r);for(let t=3;t<s.length;t+=4)s[t]=n[t];return H(s,t,e,o,s),s}(i,s,t.tangent,a,r);return{position:i,normal:c,tangent:l}}(t,e,n):function(t,e,n){const r=new Float64Array(t.position.length),o=t.position,s=e.x,i=e.y,a=e.z||0,{horizontal:c,vertical:l}=bt(n?n.unit:null,e.spatialReference);for(let t=0;t<o.length;t+=3)r[t+0]=o[t+0]*c+s,r[t+1]=o[t+1]*c+i,r[t+2]=o[t+2]*l+a;return{position:r,normal:t.normal,tangent:t.tangent}}(t,e,n)}function wt(t,e,n){return jt(e,n)?function(t,e,n){const r=e.spatialReference;vt(e,n,kt);const o=F(Ft,kt),s=new Float64Array(t.position.length),i=function(t,e,n,r){const o=I(t,e,r),s=_.fromTypedArray(o),i=new Float64Array(o.length),a=_.fromTypedArray(i);return K(a,s,n),i}(t.position,r,o,s),a=N(Mt,o),c=function(t,e,n,r,o){if(!t)return null;const s=V(t,e,n,r,new Float32Array(t.length)),i=D.fromTypedArray(s);return Q(i,i,o),s}(t.normal,t.position,s,r,a),l=function(t,e,n,r,o){if(!t)return null;const s=Z(t,e,n,r,new Float32Array(t.length)),i=D.fromTypedArray(s,4*Float32Array.BYTES_PER_ELEMENT);return Q(i,i,o),s}(t.tangent,t.position,s,r,a);return{position:i,normal:c,tangent:l}}(t,e,n):function(t,e,n){const r=new Float64Array(t.position.length),o=t.position,s=e.x,i=e.y,a=e.z||0,{horizontal:c,vertical:l}=bt(n?n.unit:null,e.spatialReference);for(let t=0;t<o.length;t+=3)r[t+0]=(o[t+0]-s)/c,r[t+1]=(o[t+1]-i)/c,r[t+2]=(o[t+2]-a)/l;return{position:r,normal:t.normal,tangent:t.tangent}}(t,e,n)}function vt(t,e,n){P(t.spatialReference,[t.x,t.y,t.z||0],n,v(t.spatialReference));const{horizontal:r,vertical:o}=bt(e?e.unit:null,t.spatialReference);return T(n,n,[r,r,o]),n}function jt(t,e){const n=t.spatialReference;return n.isWGS84||n.isWebMercator&&(!e||!1!==e.geographic)}function bt(t,e){if(r(t))return Rt;const n=e.isWGS84?1:j(e),o=e.isWGS84?1:b(e),s=k(1,t,"meters");return{horizontal:s*n,vertical:s*o}}const kt=L(),Ft=L(),Mt=W(),Rt={horizontal:1,vertical:1};const Tt={position:[-.5,-.5,0,.5,-.5,0,.5,.5,0,-.5,.5,0],normal:[0,0,1,0,0,1,0,0,1,0,0,1],uv:[0,1,1,1,1,0,0,0],faces:[0,1,2,0,2,3],facingAxisOrderSwap:{east:[3,1,2],west:[-3,-1,2],north:[-1,3,2],south:[1,-3,2],up:[1,2,3],down:[1,-2,-3]}};function Et(t,e,n){!function(t){for(let e=0;e<t.position.length;e+=3)t.position[e+2]+=.5}(t),function(t,e){if(null==e)return;const n="number"==typeof e?[e,e,e]:[null!=e.width?e.width:1,null!=e.depth?e.depth:1,null!=e.height?e.height:1];zt[0]=n[0],zt[4]=n[1],zt[8]=n[2];for(let e=0;e<t.position.length;e+=3){for(let n=0;n<3;n++)Pt[n]=t.position[e+n];g(Pt,Pt,zt);for(let n=0;n<3;n++)t.position[e+n]=Pt[n]}if(n[0]!==n[1]||n[1]!==n[2]){zt[0]=1/n[0],zt[4]=1/n[1],zt[8]=1/n[2];for(let e=0;e<t.normal.length;e+=3){for(let n=0;n<3;n++)Pt[n]=t.normal[e+n];g(Pt,Pt,zt),x(Pt,Pt);for(let n=0;n<3;n++)t.normal[e+n]=Pt[n]}}}(t,n&&n.size);const r=At(t,e,n);return{vertexAttributes:{position:r.position,normal:r.normal,uv:t.uv},components:[{faces:t.faces,material:n&&n.material||null}],spatialReference:e.spatialReference}}const St={faceDescriptions:[{axis:[0,-1,0],uvOrigin:[0,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[1,0,0],uvOrigin:[.25,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,1,0],uvOrigin:[.5,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[-1,0,0],uvOrigin:[.75,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[0,0,1],uvOrigin:[0,.375],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,0,-1],uvOrigin:[0,.875],corners:[[-1,1],[1,1],[1,-1],[-1,-1]]}],uvScales:[[0,0],[1,0],[1,1],[0,1]],faceVertexOffsets:[0,1,2,0,2,3]},Ut={south:0,east:1,north:2,west:3,up:4,down:5},Pt=f(),zt=W(),Ot=n.getLogger("esri.geometry.support.meshUtils.rotate");function Ct(t,e,n){if(!t.vertexAttributes||!t.vertexAttributes.position||0===e[3])return;const r=t.spatialReference,o=r.isWGS84||r.isWebMercator&&(!n||!1!==n.geographic),s=n&&n.origin||t.extent.center;o?function(t,e,n){const r=t.spatialReference,o=v(r),s=Vt;U(n,s,o)||U(t.extent.center,s,o);const i=t.vertexAttributes.position,a=t.vertexAttributes.normal,c=t.vertexAttributes.tangent,l=new Float64Array(i.length),p=new Float32Array(a?a.length:0),u=new Float32Array(c?c.length:0);P(o,s,Dt,o),B(It,Dt);const f=Bt;g(Bt,e,It),f[3]=e[3],I(i,r,l),a&&V(a,i,l,r,p);c&&Z(c,i,l,r,u);Wt(l,f,3,s),J(l,i,r),a&&(Wt(p,f,3),Y(p,i,l,r,a));c&&(Wt(u,f,4),H(u,i,l,r,c));t.clearCache()}(t,e,s):function(t,e,n){const r=Vt;if(!U(n,r,t.spatialReference)){const e=t.extent.center;r[0]=e.x,r[1]=e.y,r[2]=e.z,Ot.error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}). Using mesh extent.center instead`)}Wt(t.vertexAttributes.position,e,3,r),Wt(t.vertexAttributes.normal,e,3),Wt(t.vertexAttributes.tangent,e,4),t.clearCache()}(t,e,s)}function Gt(t,e,n){return y(n,t),n[3]=e,n}function Lt(t,e,n){return X(Nt,t,t[3]),X(_t,e,e[3]),tt(Nt,_t,Nt),n[3]=et(n,Nt),n}function Wt(t,e,n,r=m){if(t){E(Dt),S(Dt,Dt,e[3],e);for(let e=0;e<t.length;e+=n){for(let n=0;n<3;n++)$t[n]=t[e+n]-r[n];d($t,$t,Dt);for(let n=0;n<3;n++)t[e+n]=$t[n]+r[n]}}}const $t=f(),Bt=z(),Nt=$(),_t=$(),Dt=L(),It=W(),Vt=f(),qt=n.getLogger("esri.geometry.support.meshUtils.scale");function Jt(t,e,n){if(!t.vertexAttributes||!t.vertexAttributes.position)return;const r=t.spatialReference,o=r.isWGS84||r.isWebMercator&&(!n||!1!==n.geographic),s=n&&n.origin||t.extent.center;o?function(t,e,n){const r=t.spatialReference,o=v(r),s=Ht;U(n,s,o)||U(t.extent.center,s,o);const i=t.vertexAttributes.position,a=t.vertexAttributes.normal,c=t.vertexAttributes.tangent,l=new Float64Array(i.length),p=new Float32Array(a?a.length:0),u=new Float32Array(c?c.length:0);I(i,r,l),a&&V(a,i,l,r,p);c&&Z(c,i,l,r,u);Yt(l,e,s),J(l,i,r),a&&Y(p,i,l,r,a);c&&H(u,i,l,r,c);t.clearCache()}(t,e,s):function(t,e,n){const r=Ht;if(!U(n,r,t.spatialReference)){const e=t.extent.center;r[0]=e.x,r[1]=e.y,r[2]=e.z,qt.error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}). Using mesh extent.center instead`)}Yt(t.vertexAttributes.position,e,r),t.clearCache()}(t,e,s)}function Yt(t,e,n=m){if(t)for(let r=0;r<t.length;r+=3){for(let e=0;e<3;e++)Zt[e]=t[r+e]-n[e];A(Zt,Zt,e);for(let e=0;e<3;e++)t[r+e]=Zt[e]+n[e]}}const Zt=f(),Ht=f();var Kt;const Qt=n.getLogger("esri.geometry.Mesh");let Xt=Kt=class extends l{constructor(t){super(t),this.components=null,this.hasZ=!0,this.hasM=!1,this.vertexAttributes=new C,this.type="mesh"}get extent(){const t=this.spatialReference,e=this.vertexAttributes&&this.vertexAttributes.position;if(!e||0===e.length||this.components&&0===this.components.length)return new u({xmin:0,ymin:0,zmin:0,xmax:0,ymax:0,zmax:0,spatialReference:t});const n={xmin:1/0,xmax:-1/0,ymin:1/0,ymax:-1/0,zmin:1/0,zmax:-1/0,spatialReference:t};if(!this.components)return new u(this.extendExtent(n,e,null));for(const t of this.components){if(!t.faces){this.extendExtent(n,e,null);break}this.extendExtent(n,e,t.faces)}return new u(n)}addComponent(t){this.components||(this.components=[]),this.components.push(O.from(t)),this.clearCache()}removeComponent(t){if(this.components){const e=this.components.indexOf(t);if(-1!==e)return void(this.components=this.components.splice(e,1))}Qt.error("removeComponent()","Provided component is not part of the list of components")}rotate(t,e,n,r){return Gt(ee.x,te(t),re),Gt(ee.y,te(e),oe),Gt(ee.z,te(n),se),Lt(re,oe,re),Lt(re,se,re),Ct(this,re,r),this}offset(t,e,n,r){return ne[0]=t,ne[1]=e,ne[2]=n,ht(this,ne,r),this}scale(t,e){return Jt(this,t,e),this}centerAt(t,e){return rt(this,t,e),this}clone(){const t=this.components?new Map:null,n=this.components?new Map:null,r=this.components?this.components.map((e=>e.cloneWithDeduplication(t,n))):null;return new Kt({components:r,spatialReference:this.spatialReference,vertexAttributes:e(this.vertexAttributes)})}vertexAttributesChanged(){this.clearCache()}toJSON(t){return this.write(null,t)}forEachVertex(t,e,n){if(e)for(let r=0;r<e.length;r++){const o=3*e[r];n(t[o+0],t[o+1],t[o+2])}else for(let e=0;e<t.length;e+=3)n(t[e+0],t[e+1],t[e+2])}extendExtent(t,e,n){return this.forEachVertex(e,n,((e,n,r)=>{t.xmin=Math.min(t.xmin,e),t.xmax=Math.max(t.xmax,e),t.ymin=Math.min(t.ymin,n),t.ymax=Math.max(t.ymax,n),t.zmin=Math.min(t.zmin,r),t.zmax=Math.max(t.zmax,r)})),t}async toBinaryGLTF(t){const{toBinaryGLTF:e}=await import("../chunks/gltfexport.js");return e(this,t)}static createBox(t,e){if(!(t instanceof p))return Qt.error(".createBox()","expected location to be a Point instance"),null;const n=new Kt(Et(function(){const{faceDescriptions:t,faceVertexOffsets:e,uvScales:n}=St,r=4*t.length,o=new Float64Array(3*r),s=new Float32Array(3*r),i=new Float32Array(2*r),a=new Uint32Array(2*t.length*3);let c=0,l=0,p=0,u=0;for(let r=0;r<t.length;r++){const f=t[r],m=c/3;for(const t of e)a[u++]=m+t;const h=f.corners;for(let t=0;t<4;t++){const e=h[t];let r=0;i[p++]=.25*n[t][0]+f.uvOrigin[0],i[p++]=f.uvOrigin[1]-.25*n[t][1];for(let t=0;t<3;t++)0!==f.axis[t]?(o[c++]=.5*f.axis[t],s[l++]=f.axis[t]):(o[c++]=.5*e[r++],s[l++]=0)}}return{position:o,normal:s,uv:i,faces:a}}(),t,e));return e&&e.imageFace&&"all"!==e.imageFace?function(t,e){const n=t.components[0],r=n.faces,o=Ut[e],s=6*o,i=new Uint32Array(6),a=new Uint32Array(r.length-6);let c=0,l=0;for(let t=0;t<r.length;t++)t>=s&&t<s+6?i[c++]=r[t]:a[l++]=r[t];const p=new Float32Array(t.vertexAttributes.uv),u=4*o*2,f=[0,1,1,1,1,0,0,0];for(let t=0;t<f.length;t++)p[u+t]=f[t];return t.vertexAttributes.uv=p,t.components=[new O({faces:i,material:n.material}),new O({faces:a})],t}(n,e.imageFace):n}static createSphere(t,e){return t instanceof p?new Kt(Et(function(t=0){const e=Math.round(8*Math.pow(2,t)),n=2*e,r=(e-1)*(n+1)+2*n,o=new Float64Array(3*r),s=new Float32Array(3*r),i=new Float32Array(2*r),a=new Uint32Array((e-1)*n*2*3);let c=0,l=0,p=0,u=0;for(let t=0;t<=e;t++){const r=t/e*Math.PI+.5*Math.PI,f=Math.cos(r),m=Math.sin(r);Pt[2]=m;const h=0===t||t===e,g=h?n-1:n;for(let r=0;r<=g;r++){const m=r/g*2*Math.PI;Pt[0]=-Math.sin(m)*f,Pt[1]=Math.cos(m)*f;for(let t=0;t<3;t++)o[c]=.5*Pt[t],s[c]=Pt[t],++c;i[l++]=(r+(h?.5:0))/n,i[l++]=t/e,0!==t&&r!==n&&(t!==e&&(a[p++]=u,a[p++]=u+1,a[p++]=u-n),1!==t&&(a[p++]=u,a[p++]=u-n,a[p++]=u-n-1)),u++}}return{position:o,normal:s,uv:i,faces:a}}(e&&e.densificationFactor||0),t,e)):(Qt.error(".createSphere()","expected location to be a Point instance"),null)}static createCylinder(t,e){return t instanceof p?new Kt(Et(function(t=0){const e=Math.round(16*Math.pow(2,t)),n=4*(e+1)+2*e,r=new Float64Array(3*n),o=new Float32Array(3*n),s=new Float32Array(2*n),i=new Uint32Array(4*e*3);let a=0,c=0,l=0,p=0,u=0;for(let t=0;t<=5;t++){const n=0===t||5===t,f=t<=1||t>=4,m=2===t||4===t,h=n?e-1:e;for(let g=0;g<=h;g++){const x=g/h*2*Math.PI,y=n?0:.5;Pt[0]=y*Math.sin(x),Pt[1]=y*-Math.cos(x),Pt[2]=t<=2?.5:-.5;for(let e=0;e<3;e++)r[a++]=Pt[e],o[c++]=f?2===e?t<=1?1:-1:0:2===e?0:Pt[e]/y;s[l++]=(g+(n?.5:0))/e,s[l++]=t<=1?1*t/3:t<=3?1*(t-2)/3+1/3:1*(t-4)/3+2/3,m||0===t||g===e||(5!==t&&(i[p++]=u,i[p++]=u+1,i[p++]=u-e),1!==t&&(i[p++]=u,i[p++]=u-e,i[p++]=u-e-1)),u++}}return{position:r,normal:o,uv:s,faces:i}}(e&&e.densificationFactor||0),t,e)):(Qt.error(".createCylinder()","expected location to be a Point instance"),null)}static createPlane(t,e){return t instanceof p?new Kt(Et(function(t){const e=Tt.facingAxisOrderSwap[t],n=Tt.position,r=Tt.normal,o=new Float64Array(n.length),s=new Float32Array(r.length);let i=0;for(let t=0;t<4;t++){const t=i;for(let a=0;a<3;a++){const c=e[a],l=Math.abs(c)-1,p=c>=0?1:-1;o[i]=n[t+l]*p,s[i]=r[t+l]*p,i++}}return{position:o,normal:s,uv:new Float32Array(Tt.uv),faces:new Uint32Array(Tt.faces)}}(e&&e.facing||"up"),t,e)):(Qt.error(".createPlane()","expected location to be a Point instance"),null)}static createFromPolygon(t,e){if(!(t instanceof w))return Qt.error(".createFromPolygon()","expected polygon to be a Polygon instance"),null;const n=G(t);return new Kt({vertexAttributes:{position:n.position},components:[{faces:n.faces,shading:"flat",material:e&&e.material||null}],spatialReference:t.spatialReference})}static async createFromGLTF(t,e,n){if(!(t instanceof p))throw Qt.error(".createfromGLTF()","expected location to be a Point instance"),new a("invalid-input","Expected location to be a Point instance");return s(((r,o)=>{import("../chunks/loadGLTFMesh.js").then((async s=>{try{i(n);const o=await s.loadGLTFMesh(t,e,n);r(new Kt(lt(o.map((t=>new Kt(t))),{reuseMaterials:!0})))}catch(t){o(new a("gltf-loader-error","Failed to load glTF.",`[${t.name}] ${t.message}`))}}))}))}};function te(t){return t/180*Math.PI}t([o({dependsOn:["vertexAttributes","vertexAttributes.position","components"],json:{read:!1}})],Xt.prototype,"cache",void 0),t([o({type:[O]})],Xt.prototype,"components",void 0),t([o({readOnly:!0,dependsOn:["cache"],autoTracked:!1,json:{read:!1}})],Xt.prototype,"extent",null),t([o({readOnly:!0,json:{read:!1,write:!1}})],Xt.prototype,"hasZ",void 0),t([o({readOnly:!0,json:{read:!1,write:!1}})],Xt.prototype,"hasM",void 0),t([o({type:C,nonNullable:!0,json:{write:!0}})],Xt.prototype,"vertexAttributes",void 0),Xt=Kt=t([c("esri.geometry.Mesh")],Xt),Xt.prototype.toJSON.isDefaultToJSON=!0;const ee={x:h(1,0,0),y:h(0,1,0),z:h(0,0,1)},ne=f(),re=z(),oe=z(),se=z();var ie=Xt;export default ie;export{At as g,lt as m,wt as u};
