/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{_ as t}from"../chunks/tslib.es6.js";import"../chunks/ArrayPool.js";import"../chunks/object.js";import"../chunks/deprecate.js";import{clone as e}from"../core/lang.js";import"../config.js";import"../chunks/Logger.js";import"../chunks/string.js";import"../chunks/metadata.js";import{property as n}from"../core/accessorSupport/decorators/property.js";import"../core/Accessor.js";import"../chunks/PropertyOrigin.js";import"../core/scheduling.js";import"../core/promiseUtils.js";import"../chunks/Message.js";import"../core/Error.js";import"../chunks/ensureType.js";import{subclass as r}from"../core/accessorSupport/decorators/subclass.js";import"../chunks/JSONSupport.js";import"../core/urlUtils.js";import"../core/accessorSupport/decorators/cast.js";import"../chunks/reader.js";import{w as s}from"../chunks/writer.js";import"../chunks/resourceExtension.js";import i,{g as o}from"./SpatialReference.js";import a from"./Geometry.js";import l from"./Point.js";import"../chunks/Ellipsoid.js";import{canProject as h,project as c}from"./support/webMercatorUtils.js";import u,{i as p,p as f}from"./Extent.js";import{u as g}from"../chunks/zmUtils.js";import{a as m}from"../chunks/extentUtils.js";function y(t){if(!t)return null;if(Array.isArray(t))return t;const e=t.hasZ,n=t.hasM;if("point"===t.type)return n&&e?[t.x,t.y,t.z,t.m]:e?[t.x,t.y,t.z]:n?[t.x,t.y,t.m]:[t.x,t.y];if("polygon"===t.type)return t.rings.slice(0);if("polyline"===t.type)return t.paths.slice(0);if("multipoint"===t.type)return t.points.slice(0);if("extent"===t.type){const e=t.clone().normalize();if(!e)return null;let n=!1,r=!1;return e.forEach((t=>{t.hasZ&&(n=!0),t.hasM&&(r=!0)})),e.map((t=>{const e=[[t.xmin,t.ymin],[t.xmin,t.ymax],[t.xmax,t.ymax],[t.xmax,t.ymin],[t.xmin,t.ymin]];if(n&&t.hasZ){const n=.5*(t.zmax-t.zmin);for(let t=0;t<e.length;t++)e[t].push(n)}if(r&&t.hasM){const n=.5*(t.mmax-t.mmin);for(let t=0;t<e.length;t++)e[t].push(n)}return e}))}return null}function d(t,e){const n=e[0]-t[0],r=e[1]-t[1];if(t.length>2&&e.length>2){const s=t[2]-e[2];return Math.sqrt(n*n+r*r+s*s)}return Math.sqrt(n*n+r*r)}function x(t,e,n){const r=t[0]+n*(e[0]-t[0]),s=t[1]+n*(e[1]-t[1]);return t.length>2&&e.length>2?[r,s,t[2]+n*(e[2]-t[2])]:[r,s]}function j(t,e,n,r){const[s,i]=e,[o,a]=n[r],[l,h]=n[r+1],c=l-o,u=h-a,p=c*c+u*u,f=(s-o)*c+(i-a)*u,g=Math.min(1,Math.max(0,f/p));return t[0]=o+c*g,t[1]=a+u*g,t}function R(t,e){return x(t,e,.5)}function M(t){const e=t.length;let n=0;for(let r=0;r<e-1;++r)n+=d(t[r],t[r+1]);return n}function k(t,e){if(e<=0)return t[0];const n=t.length;let r=0;for(let s=0;s<n-1;++s){const n=d(t[s],t[s+1]);if(e-r<n){const i=(e-r)/n;return x(t[s],t[s+1],i)}r+=n}return t[n-1]}function v(t,e,n){const r=t.length;let s=0,i=0,o=0;for(let a=0;a<r;a++){const l=t[a],h=t[(a+1)%r];let c=2;s+=l[0]*h[1]-h[0]*l[1],l.length>2&&h.length>2&&n&&(i+=l[0]*h[2]-h[0]*l[2],c=3),l.length>c&&h.length>c&&e&&(o+=l[0]*h[c]-h[0]*l[c])}return s<=0&&i<=0&&o<=0}function w(t){if("rings"in t){for(const e of t.rings)e.length<3||e[0][0]===e[e.length-1][0]&&e[0][1]===e[e.length-1][1]||e.push([e[0][0],e[0][1]]);if(t.rings.length>0){if(!v(t.rings[0],t.hasM,t.hasZ))for(let e=0;e<t.rings.length;++e)t.rings[e]=t.rings[e].reverse()}}}function Z(t){if("rings"in t)for(const e of t.rings)e.length<3||e[0][0]===e[e.length-1][0]&&e[0][1]===e[e.length-1][1]||e.push([e[0][0],e[0][1]])}function A(t){if("polygon"!==t.type&&"polyline"!==t.type)return t;return z("polygon"===t.type?t.rings:t.paths,t.spatialReference),t}function z(t,e){const n=o(e);if(!n)return;const r=n.valid[0],s=n.valid[1],i=s-r;for(const e of t){let t=1/0,n=-1/0;e.forEach((e=>{let o=e[0];for(;o<r;)o+=i;for(;o>s;)o-=i;t=Math.min(t,o),n=Math.max(n,o),e[0]=o}));const o=n-t;i-o<o&&e.forEach((t=>{t[0]<0&&(t[0]+=i)}))}}function O(t){return t?S(t.rings,t.hasZ):null}function S(t,e){if(!t||!t.length)return null;const n=[],r=[],s=e?[1/0,-1/0,1/0,-1/0,1/0,-1/0]:[1/0,-1/0,1/0,-1/0];for(let n=0,i=t.length;n<i;n++){const i=N(t[n],e,s);i&&r.push(i)}if(r.sort(((t,n)=>{let r=t[2]-n[2];return 0===r&&e&&(r=t[4]-n[4]),r})),r.length){let t=6*r[0][2];n[0]=r[0][0]/t,n[1]=r[0][1]/t,e&&(t=6*r[0][4],n[2]=0!==t?r[0][3]/t:0),(n[0]<s[0]||n[0]>s[1]||n[1]<s[2]||n[1]>s[3]||e&&(n[2]<s[4]||n[2]>s[5]))&&(n.length=0)}if(!n.length){const r=t[0]&&t[0].length?function(t,e){const n=e?[0,0,0]:[0,0],r=e?[0,0,0]:[0,0];let s=0,i=0,o=0,a=0;for(let l=0,h=t.length;l<h-1;l++){const h=t[l],c=t[l+1];if(h&&c){n[0]=h[0],n[1]=h[1],r[0]=c[0],r[1]=c[1],e&&h.length>2&&c.length>2&&(n[2]=h[2],r[2]=c[2]);const t=d(n,r);if(t){s+=t;const n=R(h,c);i+=t*n[0],o+=t*n[1],e&&n.length>2&&(a+=t*n[2])}}}if(s>0)return e?[i/s,o/s,a/s]:[i/s,o/s];if(t.length)return t[0];return null}(t[0],e):null;if(!r)return null;n[0]=r[0],n[1]=r[1],e&&r.length>2&&(n[2]=r[2])}return n}function N(t,e,n){let r=0,s=0,i=0,o=0,a=0;for(let l=0;l<t.length;l++){const h=t[l],[c,u,p]=h,f=t[(l+1)%t.length],[g,m,y]=f;let d=c*m-g*u;o+=d,r+=(c+g)*d,s+=(u+m)*d,e&&h.length>2&&f.length>2&&(d=c*y-g*p,i+=(p+y)*d,a+=d),c<n[0]&&(n[0]=c),c>n[1]&&(n[1]=c),u<n[2]&&(n[2]=u),u>n[3]&&(n[3]=u),e&&(p<n[4]&&(n[4]=p),p>n[5]&&(n[5]=p))}if(o>0&&(o*=-1),a>0&&(a*=-1),!o)return null;const l=[r,s,.5*o];return e&&(l[3]=i,l[4]=.5*a),l}var E;function I(t){return!Array.isArray(t[0])}let P=E=class extends a{constructor(...t){super(...t),this.rings=[],this.type="polygon"}static fromExtent(t){const e=t.clone().normalize(),n=t.spatialReference;let r=!1,s=!1;e.map((t=>{t.hasZ&&(r=!0),t.hasM&&(s=!0)}));const i={rings:e.map((function(t){const e=[[t.xmin,t.ymin],[t.xmin,t.ymax],[t.xmax,t.ymax],[t.xmax,t.ymin],[t.xmin,t.ymin]];if(r&&t.hasZ){const n=t.zmin+.5*(t.zmax-t.zmin);for(let t=0;t<e.length;t++)e[t].push(n)}if(s&&t.hasM){const n=t.mmin+.5*(t.mmax-t.mmin);for(let t=0;t<e.length;t++)e[t].push(n)}return e})),spatialReference:n};return r&&(i.hasZ=!0),s&&(i.hasM=!0),new E(i)}normalizeCtorArgs(t,e){let n,r,s=null,o=null;return t&&!Array.isArray(t)?(s=t.rings?t.rings:null,e||(t.spatialReference?e=t.spatialReference:t.rings||(e=t)),n=t.hasZ,r=t.hasM):s=t,s=s||[],e=e||i.WGS84,s.length&&s[0]&&null!=s[0][0]&&"number"==typeof s[0][0]&&(s=[s]),o=s[0]&&s[0][0],o&&(void 0===n&&void 0===r?(n=o.length>2,r=!1):void 0===n?n=!r&&o.length>3:void 0===r&&(r=!n&&o.length>3)),{rings:s,spatialReference:e,hasZ:n,hasM:r}}get centroid(){const t=O(this);if(!t||isNaN(t[0])||isNaN(t[1])||this.hasZ&&isNaN(t[2]))return null;const e=new l;return e.x=t[0],e.y=t[1],e.spatialReference=this.spatialReference,this.hasZ&&(e.z=t[2]),e}get extent(){const{spatialReference:t}=this,e=m(this);if(!e)return null;const n=new u(e);return n.spatialReference=t,n}get isSelfIntersecting(){return p(this.rings)}writeRings(t,n){n.rings=e(this.rings)}addRing(t){if(!t)return;this.clearCache();const e=this.rings,n=e.length;if(I(t)){const r=[];for(let e=0,n=t.length;e<n;e++)r[e]=t[e].toArray();e[n]=r}else e[n]=t.concat();return this}clone(){const t=new E;return t.spatialReference=this.spatialReference,t.rings=e(this.rings),t.hasZ=this.hasZ,t.hasM=this.hasM,t}contains(t){return!!t&&(h(t,this.spatialReference)&&(t=c(t,this.spatialReference)),f(this,t))}isClockwise(t){let e;return e=I(t)?t.map((t=>this.hasZ?this.hasM?[t.x,t.y,t.z,t.m]:[t.x,t.y,t.z]:[t.x,t.y])):t,v(e,this.hasM,this.hasZ)}getPoint(t,e){if(!this._validateInputs(t,e))return null;const n=this.rings[t][e],r=this.hasZ,s=this.hasM;return r&&!s?new l(n[0],n[1],n[2],void 0,this.spatialReference):s&&!r?new l(n[0],n[1],void 0,n[2],this.spatialReference):r&&s?new l(n[0],n[1],n[2],n[3],this.spatialReference):new l(n[0],n[1],this.spatialReference)}insertPoint(t,e,n){return this._validateInputs(t,e,!0)?(this.clearCache(),g(this,n),Array.isArray(n)||(n=n.toArray()),this.rings[t].splice(e,0,n),this):this}removePoint(t,e){return this._validateInputs(t,e)?(this.clearCache(),new l(this.rings[t].splice(e,1)[0],this.spatialReference)):null}removeRing(t){if(!this._validateInputs(t,null))return null;this.clearCache();const e=this.rings.splice(t,1)[0],n=this.spatialReference;return e.map((t=>new l(t,n)))}setPoint(t,e,n){return this._validateInputs(t,e)?(this.clearCache(),g(this,n),Array.isArray(n)||(n=n.toArray()),this.rings[t][e]=n,this):this}_validateInputs(t,e,n=!1){if(null==t||t<0||t>=this.rings.length)return!1;if(null!=e){const r=this.rings[t];if(n&&(e<0||e>r.length))return!1;if(!n&&(e<0||e>=r.length))return!1}return!0}toJSON(t){return this.write(null,t)}};t([n({dependsOn:["hasM","hasZ","rings"],autoTracked:!1})],P.prototype,"cache",void 0),t([n({readOnly:!0,dependsOn:["cache"],autoTracked:!1})],P.prototype,"centroid",null),t([n({readOnly:!0,dependsOn:["cache"],autoTracked:!1})],P.prototype,"extent",null),t([n({readOnly:!0,dependsOn:["cache"],autoTracked:!1})],P.prototype,"isSelfIntersecting",null),t([n({type:[[[Number]]],json:{write:{isRequired:!0}}})],P.prototype,"rings",void 0),t([s("rings")],P.prototype,"writeRings",null),P=E=t([r("esri.geometry.Polygon")],P),P.prototype.toJSON.isDefaultToJSON=!0;var b=P;export default b;export{M as a,k as b,z as c,y as d,Z as e,O as f,d as g,w as h,v as i,R as j,j as p,S as r,A as u};
