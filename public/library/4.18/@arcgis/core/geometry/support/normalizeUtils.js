/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import"../../chunks/tslib.es6.js";import"../../chunks/ArrayPool.js";import"../../chunks/object.js";import"../../chunks/deprecate.js";import"../../core/lang.js";import t from"../../config.js";import{L as e,b as s,i as n}from"../../chunks/Logger.js";import"../../chunks/string.js";import"../../chunks/metadata.js";import"../../core/accessorSupport/decorators/property.js";import"../../core/Accessor.js";import"../../chunks/PropertyOrigin.js";import"../../core/scheduling.js";import{resolve as r}from"../../core/promiseUtils.js";import"../../chunks/Message.js";import o from"../../core/Error.js";import"../../chunks/ensureType.js";import"../../core/accessorSupport/decorators/subclass.js";import"../../chunks/JSONSupport.js";import{urlToObject as i}from"../../core/urlUtils.js";import"../../core/accessorSupport/decorators/cast.js";import"../../chunks/jsonMap.js";import"../../chunks/reader.js";import"../../chunks/writer.js";import"../../chunks/resourceExtension.js";import c,{g as p}from"../SpatialReference.js";import"../../kernel.js";import f from"../../request.js";import"../Geometry.js";import"../Point.js";import"../../chunks/Ellipsoid.js";import{geographicToWebMercator as l,webMercatorToGeographic as u}from"./webMercatorUtils.js";import"../Extent.js";import"../../chunks/zmUtils.js";import"../Multipoint.js";import a from"../Polygon.js";import"../../chunks/extentUtils.js";import m from"../Polyline.js";import"../../chunks/typeUtils.js";import{fromJSON as h,getJsonType as g,getGeometryType as y}from"./jsonUtils.js";import"../../geometry.js";async function j(t,e,s){const n="string"==typeof t?i(t):t,r=e[0].spatialReference,o=g(e[0]),c={...s,query:{...n.query,f:"json",sr:r.wkid?r.wkid:JSON.stringify(r),geometries:JSON.stringify(x(e))}};return function(t,e,s){const n=y(e);return t.map((t=>{const e=n.fromJSON(t);return e.spatialReference=s,e}))}((await f(n.path+"/simplify",c)).data,o,r)}function x(t){return{geometryType:g(t[0]),geometries:t.map((t=>t.toJSON()))}}const d=e.getLogger("esri.geometry.support.normalizeUtils"),k={102100:{maxX:20037508.342788905,minX:-20037508.342788905,plus180Line:new m({paths:[[[20037508.342788905,-20037508.342788905],[20037508.342788905,20037508.342788905]]],spatialReference:c.WebMercator}),minus180Line:new m({paths:[[[-20037508.342788905,-20037508.342788905],[-20037508.342788905,20037508.342788905]]],spatialReference:c.WebMercator})},4326:{maxX:180,minX:-180,plus180Line:new m({paths:[[[180,-180],[180,180]]],spatialReference:c.WGS84}),minus180Line:new m({paths:[[[-180,-180],[-180,180]]],spatialReference:c.WGS84})}};function w(t){return"polygon"===t.type}function R(t){return"polyline"===t[0].type}function S(t){return w(t)?t.rings:t.paths}function M(t,e){return Math.ceil((t-e)/(2*e))}function b(t,e){const s=S(t);for(const t of s)for(const s of t)s[0]+=e;return t}function L(t){const e=[];let s=0,n=0;for(let r=0;r<t.length;r++){const o=t[r];let i=null;for(let t=0;t<o.length;t++)i=o[t],e.push(i),0===t?(s=i[0],n=s):(s=Math.min(s,i[0]),n=Math.max(n,i[0]));i&&e.push([(s+n)/2,0])}return e}function N(t,e){if(!(t instanceof m||t instanceof a)){const t="straightLineDensify: the input geometry is neither polyline nor polygon";throw d.error(t),new o(t)}const s=S(t),n=[];for(const t of s){const s=[];n.push(s),s.push([t[0][0],t[0][1]]);for(let n=0;n<t.length-1;n++){const r=t[n][0],o=t[n][1],i=t[n+1][0],c=t[n+1][1],p=Math.sqrt((i-r)*(i-r)+(c-o)*(c-o)),f=(c-o)/p,l=(i-r)/p,u=p/e;if(u>1){for(let t=1;t<=u-1;t++){const n=t*e,i=l*n+r,c=f*n+o;s.push([i,c])}const t=(p+Math.floor(u-1)*e)/2,n=l*t+r,i=f*t+o;s.push([n,i])}s.push([i,c])}}return w(t)?new a({rings:n,spatialReference:t.spatialReference}):new m({paths:n,spatialReference:t.spatialReference})}function O(t,e,s){if(e){const e=N(t,1e6);t=u(e,!0)}return s&&(t=b(t,s)),t}function P(t,e,s){if(Array.isArray(t)){const n=t[0];if(n>e){const s=M(n,e);t[0]=n+s*(-2*e)}else if(n<s){const e=M(n,s);t[0]=n+e*(-2*s)}}else{const n=t.x;if(n>e){const s=M(n,e);t=t.clone().offset(s*(-2*e),0)}else if(n<s){const e=M(n,s);t=t.clone().offset(e*(-2*s),0)}}return t}async function U(e,o,c){if(!Array.isArray(e))return U([e],o);const u=o?o.url:t.geometryServiceUrl;let y,x,d,w,L,N,J,q,A=0;const X=[],W=[];for(const t of e)if(s(t))W.push(t);else if(y||(y=t.spatialReference,x=p(y),d=y.isWebMercator,N=d?102100:4326,w=k[N].maxX,L=k[N].minX,J=k[N].plus180Line,q=k[N].minus180Line),x)if("mesh"===t.type)W.push(t);else if("point"===t.type)W.push(P(t.clone(),w,L));else if("multipoint"===t.type){const e=t.clone();e.points=e.points.map((t=>P(t,w,L))),W.push(e)}else if("extent"===t.type){const e=t.clone()._normalize(!1,!1,x);W.push(e.rings?new a(e):e)}else if(t.extent){const e=t.extent,s=M(e.xmin,L)*(2*w);let n=0===s?t.clone():b(t.clone(),s);e.offset(s,0),e.intersects(J)&&e.xmax!==w?(A=e.xmax>A?e.xmax:A,n=O(n,d),X.push(n),W.push("cut")):e.intersects(q)&&e.xmin!==L?(A=e.xmax*(2*w)>A?e.xmax*(2*w):A,n=O(n,d,360),X.push(n),W.push("cut")):W.push(n)}else W.push(t.clone());else W.push(t);let E=M(A,w),I=-90;const v=E,z=new m;for(;E>0;){const t=360*E-180;z.addPath([[t,I],[t,-1*I]]),I*=-1,E--}if(X.length>0&&v>0){const t=function(t,e){let s=-1;for(let n=0;n<e.cutIndexes.length;n++){const r=e.cutIndexes[n],o=e.geometries[n],i=S(o);for(let t=0;t<i.length;t++){const e=i[t];e.some((s=>{if(s[0]<180)return!0;{let s=0;for(let t=0;t<e.length;t++){const n=e[t][0];s=n>s?n:s}s=Number(s.toFixed(9));const n=-360*M(s,180);for(let s=0;s<e.length;s++){const e=o.getPoint(t,s);o.setPoint(t,s,e.clone().offset(n,0))}return!0}}))}if(r===s){if("polygon"===t[0].type)for(const e of S(o))t[r]=t[r].addRing(e);else if(R(t))for(const e of S(o))t[r]=t[r].addPath(e)}else s=r,t[r]=o}return t}(X,await async function(t,e,s,n){const r="string"==typeof t?i(t):t,o=e[0].spatialReference,c={...n,query:{...r.query,f:"json",sr:JSON.stringify(o),target:JSON.stringify({geometryType:g(e[0]),geometries:e}),cutter:JSON.stringify(s)}},p=await f(r.path+"/cut",c),{cutIndexes:l,geometries:u=[]}=p.data;return{cutIndexes:l,geometries:u.map((t=>{const e=h(t);return e.spatialReference=o,e}))}}(u,X,z,c)),s=[],r=[];for(let o=0;o<W.length;o++){const i=W[o];if("cut"!==i)r.push(i);else{const i=t.shift(),c=e[o];n(c)&&"polygon"===c.type&&c.rings&&c.rings.length>1&&i.rings.length>=c.rings.length?(s.push(i),r.push("simplify")):r.push(d?l(i):i)}}if(!s.length)return r;const o=await j(u,s,c),p=[];for(let t=0;t<r.length;t++){const e=r[t];"simplify"!==e?p.push(e):p.push(d?l(o.shift()):o.shift())}return p}const G=[];for(let t=0;t<W.length;t++){const e=W[t];if("cut"!==e)G.push(e);else{const t=X.shift();G.push(!0===d?l(t):t)}}return r(G)}function J(t){if(!t)return null;const e=t.extent;if(!e)return null;const s=t.spatialReference&&p(t.spatialReference);if(!s)return e;const[n,r]=s.valid,o=2*r,{width:i}=e;let c,{xmin:f,xmax:l}=e;if([f,l]=[l,f],"extent"===t.type||0===i||i<=r||i>o||f<n||l>r)return e;switch(t.type){case"polygon":if(!(t.rings.length>1))return e;c=L(t.rings);break;case"polyline":if(!(t.paths.length>1))return e;c=L(t.paths);break;case"multipoint":c=t.points}const u=e.clone();for(let t=0;t<c.length;t++){let e=c[t][0];e<0?(e+=r,l=Math.max(e,l)):(e-=r,f=Math.min(e,f))}return u.xmin=f,u.xmax=l,u.width<i?(u.xmin-=r,u.xmax-=r,u):e}function q(t,e){const s=p(e);if(s){const[e,n]=s.valid,r=n-e;if(t<e)for(;t<e;)t+=r;if(t>n)for(;t>n;)t-=r}return t}export{J as getDenormalizedExtent,U as normalizeCentralMeridian,q as normalizeMapX,N as straightLineDensify};
