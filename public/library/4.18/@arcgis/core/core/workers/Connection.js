/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import"../../chunks/tslib.es6.js";import"../../chunks/ArrayPool.js";import{h as e}from"../../chunks/object.js";import"../../chunks/deprecate.js";import"../lang.js";import"../../config.js";import{r as s,i as t,L as r}from"../../chunks/Logger.js";import"../../chunks/string.js";import{h as o}from"../../chunks/metadata.js";import"../accessorSupport/decorators/property.js";import"../Accessor.js";import"../../chunks/PropertyOrigin.js";import"../scheduling.js";import{resolve as n,reject as i,create as l,onAbortOrThrow as a,createAbortError as c,createAbortController as h,isPromiseLike as u,isAbortError as p,o as _,throwIfAborted as m,isThenable as g,first as d,all as k}from"../promiseUtils.js";import"../../chunks/Message.js";import f from"../Error.js";import"../../chunks/ensureType.js";import"../accessorSupport/decorators/subclass.js";import"../urlUtils.js";import"../../chunks/resourceExtension.js";import"../watchUtils.js";import{T as b}from"../../chunks/Scheduler.js";const y={geometryEngineWorker:()=>import("../../chunks/geometryEngineWorker.js"),CSVSourceWorker:()=>import("../../chunks/CSVSourceWorker.js"),EdgeProcessingWorker:()=>import("../../chunks/EdgeProcessingWorker.js").then((function(e){return e.b})),ElevationSamplerWorker:()=>import("../../chunks/ElevationSamplerWorker.js"),GeoJSONSourceWorker:()=>import("../../chunks/GeoJSONSourceWorker.js"),LercWorker:()=>import("../../chunks/LercWorker.js"),MemorySourceWorker:()=>import("../../chunks/MemorySourceWorker.js"),PBFDecoderWorker:()=>import("../../chunks/PBFDecoderWorker.js"),Pipeline:()=>import("../../chunks/Pipeline.js"),PointCloudWorker:()=>import("../../chunks/PointCloudWorker.js"),RasterWorker:()=>import("../../chunks/RasterWorker.js"),SceneLayerWorker:()=>import("../../chunks/SceneLayerWorker.js"),WorkerTileHandler:()=>import("../../chunks/WorkerTileHandler.js")};var j;!function(e){e[e.HANDSHAKE=0]="HANDSHAKE",e[e.CONFIGURE=1]="CONFIGURE",e[e.CONFIGURED=2]="CONFIGURED",e[e.OPEN=3]="OPEN",e[e.OPENED=4]="OPENED",e[e.RESPONSE=5]="RESPONSE",e[e.INVOKE=6]="INVOKE",e[e.ABORT=7]="ABORT",e[e.CLOSE=8]="CLOSE",e[e.OPEN_PORT=9]="OPEN_PORT",e[e.ON=10]="ON"}(j||(j={}));let O=0;function E(){return O++}function v(e){return e?"string"==typeof e?JSON.stringify({name:"message",message:e}):e.toJSON?JSON.stringify(e):JSON.stringify({name:e.name,message:e.message,details:e.details||{stack:e.stack}}):null}function P(e,s,t,r){if(s.type===j.OPEN_PORT)return void e.postMessage(s,[s.port]);if(s.type!==j.INVOKE&&s.type!==j.RESPONSE)return void e.postMessage(s);let o;var n;(n=t)&&"object"==typeof n&&("result"in n||"transferList"in n)?(o=S(t.transferList),s.data=t.result):(o=S(r),s.data=t),o?e.postMessage(s,o):e.postMessage(s)}function M(e){if(!e)return null;const s=e.data;return s?"string"==typeof s?JSON.parse(s):s:null}function S(s){if(!s||!s.length)return null;if(e("esri-workers-arraybuffer-transfer"))return s;const t=s.filter((e=>{return!((s=e)instanceof ArrayBuffer||s&&s.constructor&&"ArrayBuffer"===s.constructor.name);var s}));return t.length?t:null}const{CLOSE:N,ABORT:I,INVOKE:w,RESPONSE:C,OPEN_PORT:J,ON:W}=j;class T{constructor(e){this._timer=null,this._cancelledJobIds=new Set,this._invokeMessages=[],this._invoke=e,this._timer=null,this._process=this._process.bind(this)}push(e){e.type===j.ABORT?this._cancelledJobIds.add(e.jobId):(this._invokeMessages.push(e),null===this._timer&&(this._timer=setTimeout(this._process,0)))}clear(){this._invokeMessages.length=0,this._cancelledJobIds.clear(),this._timer=null}_process(){this._timer=null;for(const e of this._invokeMessages)this._cancelledJobIds.has(e.jobId)||this._invoke(e);this._cancelledJobIds.clear(),this._invokeMessages.length=0}}class A{constructor(e,s){this._port=e,this._outJobs=new Map,this._inJobs=new Map,this._invokeQueue=new T((e=>this._onInvokeMessage(e))),this._messageQueue=new Array,this._client=s.client,this._onMessage=this._onMessage.bind(this),this._channel=s.channel,s.scheduler&&(this._frameTask=s.scheduler.registerTask(b.REMOTE_CLIENT,(e=>this._update(e)),(()=>this._messageQueue.length>0))),this._port.addEventListener("message",this._onMessage),this._port.start()}static connect(e){const s=new MessageChannel;let t;t="function"==typeof e?new e:"default"in e&&"function"==typeof e.default?new e.default:e;const r=new A(s.port1,{channel:s,client:t});return"object"==typeof t&&"remoteClient"in t&&(t.remoteClient=r),A.clients.set(r,t),s.port2}static loadWorker(e){const s=y[e];return s?s():n(null)}close(){this._post({type:N}),this._close()}isBusy(){return this._outJobs.size>0}invoke(e,s,t){const r=t&&t.signal,o=t&&t.transferList;if(!this._port)return i(new f("worker:port-closed",`Cannot call invoke('${e}'), port is closed`,{methodName:e,data:s}));const n=E();return l(((t,i)=>{const l=a(r,(()=>{var e;const s=this._outJobs.get(n);s&&(this._outJobs.delete(n),null==(e=s.abortHandle)||e.remove(),this._post({type:I,jobId:n}),i(c()))})),h={resolve:t,reject:i,abortHandle:l,debugInfo:e};this._outJobs.set(n,h),this._post({type:w,jobId:n,methodName:e,abortable:null!=r},s,o)}))}on(e,s){const t=new MessageChannel;function r(e){s(e.data)}return this._port.postMessage({type:j.ON,eventType:e,port:t.port2},[t.port2]),t.port1.addEventListener("message",r),t.port1.start(),{remove(){t.port1.postMessage({type:j.CLOSE}),t.port1.close(),t.port1.removeEventListener("message",r)}}}openPort(){const e=new MessageChannel;return this._post({type:J,port:e.port2}),e.port1}_close(){this._channel&&(this._channel=null),this._port.removeEventListener("message",this._onMessage),this._port.close(),this._outJobs.forEach((e=>{var s;null==(s=e.abortHandle)||s.remove(),e.reject(c(`Worker closing, aborting job calling '${e.debugInfo}'`))})),this._inJobs.clear(),this._outJobs.clear(),this._invokeQueue.clear(),this._port=this._client=null,this._frameTask=s(this._frameTask)}_onMessage(e){t(this._frameTask)?this._messageQueue.push(e):this._processMessage(e)}_processMessage(e){const s=M(e);if(s)switch(s.type){case C:this._onResponseMessage(s);break;case w:this._invokeQueue.push(s);break;case I:this._onAbortMessage(s);break;case N:this._onCloseMessage();break;case J:this._onOpenPortMessage(s);break;case W:this._onOnMessage(s)}}_onAbortMessage(e){const s=this._inJobs,t=e.jobId,r=s.get(t);this._invokeQueue.push(e),r&&(r.controller&&r.controller.abort(),s.delete(t))}_onCloseMessage(){const e=this._client;this._close(),e&&"destroy"in e&&A.clients.get(this)===e&&e.destroy(),A.clients.delete(this),e&&e.remoteClient&&(e.remoteClient=null)}_onInvokeMessage(e){const{methodName:s,jobId:t,data:r,abortable:o}=e,n=o?h():null,i=this._inJobs;let l,a=this._client,c=a[s];try{if(!c&&s&&-1!==s.indexOf(".")){const e=s.split(".");for(let s=0;s<e.length-1;s++)a=a[e[s]],c=a[e[s+1]]}if("function"!=typeof c)throw new TypeError(`${s} is not a function`);l=c.call(a,r,{client:this,signal:n?n.signal:null})}catch(e){return void this._post({type:C,jobId:t,error:v(e)})}u(l)?(i.set(t,{controller:n,promise:l}),l.then((e=>{i.has(t)&&(i.delete(t),this._post({type:C,jobId:t},e))}),(e=>{i.has(t)&&(i.delete(t),p(e)||this._post({type:C,jobId:t,error:v(e||{message:`Error encountered at method ${s}`})}))}))):this._post({type:C,jobId:t},l)}_onOpenPortMessage(e){new A(e.port,{client:this._client})}_onOnMessage(e){const{port:s}=e,t=this._client.on(e.eventType,(e=>{s.postMessage(e)})),r=_(e.port,"message",(e=>{M(e).type===j.CLOSE&&(r.remove(),t.remove(),s.close())}))}_onResponseMessage(e){var s;const{jobId:t,error:r,data:o}=e,n=this._outJobs;if(!n.has(t))return;const i=n.get(t);n.delete(t),null==(s=i.abortHandle)||s.remove(),r?i.reject(f.fromJSON(JSON.parse(r))):i.resolve(o)}_update(e){for(;!e.done&&this._messageQueue.length>0;)this._processMessage(this._messageQueue.shift()),e.madeProgress()}_post(e,s,t){return P(this._port,e,s,t)}}A.clients=new Map;const L=r.getLogger("esri.core.workers.Connection");export default class{constructor(){this._clients=new Array,this._clientPromises=new Array,this._clientIdx=0}destroy(){this.close()}get closed(){return!this._clients||!this._clients.length}open(e,s){return l(((t,r)=>{let o=!0;const i=e=>{m(s.signal),o&&(o=!1,e())};this._clients.length=e.length,this._clientPromises.length=e.length;for(let o=0;o<e.length;++o){const l=e[o];g(l)?this._clientPromises[o]=l.then((e=>(this._clients[o]=new A(e,s),i(t),this._clients[o])),(()=>(i(r),null))):(this._clients[o]=new A(l,s),this._clientPromises[o]=n(this._clients[o]),i(t))}}))}broadcast(e,s,t){const r=new Array(this._clientPromises.length);for(let o=0;o<this._clientPromises.length;++o){const n=this._clientPromises[o];r[o]=n.then((r=>r.invoke(e,s,t)))}return r}close(){for(const e of this._clientPromises)e.then((e=>e.close()));this._clients.length=0,this._clientPromises.length=0}getAvailableClient(){let e;for(let s=0;s<this._clients.length;++s){const t=this._clients[s];if(t){if(!t.isBusy())return n(t)}else e=e||[],e.push(this._clientPromises[s])}return e?d(e):(this._clientIdx=(this._clientIdx+1)%this._clients.length,n(this._clients[this._clientIdx]))}invoke(e,s,t){let r=null;if(Array.isArray(t)?(L.warn("invoke()","The transferList parameter is deprecated, use the options object instead"),r={transferList:t}):r=t,this.closed)return i(new Error("Connection closed"));return this.getAvailableClient().then((t=>t.invoke(e,s,r)))}on(e,s){return k(this._clientPromises).then((()=>o(this._clients.map((t=>t.on(e,s))))))}openPorts(){return l((e=>{const s=new Array(this._clientPromises.length);let t=s.length;for(let r=0;r<this._clientPromises.length;++r){this._clientPromises[r].then((o=>{s[r]=o.openPort(),0==--t&&e(s)}))}}))}get test(){return{numClients:this._clients.length}}}export{j as M,A as R,E as n,P as p,M as r,v as t};
