/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{a as t}from"../chunks/object.js";import"./lang.js";import"../config.js";import{L as e,i as n,b as r,r as o,a as i}from"../chunks/Logger.js";import"../chunks/string.js";import"../chunks/Message.js";import c from"./Error.js";var u,s=(u=t,{setTimeout:(t,e)=>{const n=u.setTimeout(t,e);return{remove:()=>u.clearTimeout(n)}}});function f(t){return t&&("function"==typeof t.on||"function"==typeof t.addEventListener)}function l(t,e,n){if(!f(t))throw new TypeError("target is not a Evented or EventTarget object");if("on"in t)return t.on(e,n);if(Array.isArray(e)){const r=e.slice();for(const e of r)t.addEventListener(e,n);return{remove(){for(const e of r)t.removeEventListener(e,n)}}}return t.addEventListener(e,n),{remove(){t.removeEventListener(e,n)}}}function a(t,e,n){if(!f(t))throw new TypeError("target is not a Evented or EventTarget object");if("once"in t)return t.once(e,n);const r=l(t,e,(e=>{r.remove(),n.call(t,e)}));return{remove(){r.remove()}}}function m(t,e,n){let r=!1;const o=l(t,e,(e=>{r||n.call(t,e)}));return{resume(){r=!1},pause(){r=!0},remove(){o.remove()}}}const h={Win:"Meta",Scroll:"ScrollLock",Spacebar:" ",Down:"ArrowDown",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Del:"Delete",Apps:"ContextMenu",Esc:"Escape",Multiply:"*",Add:"+",Subtract:"-",Decimal:".",Divide:"/"};function p({key:t}){return h[t]||t}const v=e.getLogger("esri");function b(t){return Promise.all(t)}function w(t,e){const n=t.slice();return b(t.map(((t,n)=>e(t,n)))).then((t=>n.filter(((e,n)=>t[n]))))}function d(t){return new Promise(((e,n)=>{try{t(e,n)}catch(t){Promise.resolve().then((()=>n(t)))}}))}function g(t="Aborted"){return new c("AbortError",t)}function E(){return new AbortController}function j(t){if(T(t))throw g()}function y(t){return n(t)?"aborted"in t?t:t.signal:t}function T(t){const e=y(t);return n(e)&&e.aborted}function A(t){if(M(t))throw t}function L(t){if(!M(t))throw t}function k(t,e){const n=y(t);if(!r(n)){if(!n.aborted)return a(n,"abort",(()=>e()));e()}}function D(t,e){const n=y(t);if(!r(n))return j(n),a(n,"abort",(()=>e(g())))}function P(t,e){const n=y(e);return r(n)?t:d(((n,r)=>{let i=k(e,(()=>r(g())));const c=()=>i=o(i);t.then(c,c),t.then(n,r)}))}function M(t){return t&&"AbortError"===t.name}function S(t){return t.catch((t=>{if(!M(t))throw t}))}function U(t,e=v){return t.catch((t=>{M(t)||e.error(t)}))}function x(){let t=null;const e=d(((e,n)=>{t={promise:void 0,resolve:e,reject:n}}));return t.promise=e,t}function C(t,e){if(!t)return;if("function"!=typeof t.forEach){const e=Object.keys(t);return C(e.map((e=>t[e]))).then((t=>{const n={};return e.forEach(((e,r)=>n[e]=t[r])),n}))}const n=t,r=z;return P(d((t=>{const e=[];let o=n.length;0===o&&t(e),n.forEach((n=>{const i={promise:n||r(n)};e.push(i),i.promise.then((t=>{i.value=t})).catch((t=>{i.error=t})).then((()=>{--o,0===o&&t(e)}))}))})),e)}function R(t){return t&&"function"==typeof t.then}function O(t){return C(t).then((t=>t.filter((t=>!!t.value)).map((t=>t.value))))}function W(t){return t&&t.length?d(((e,n)=>{for(const r of t)r.then(e,n)})):z()}function q(t){return Promise.reject(t)}function z(t){return Promise.resolve(t)}function B(t,e,n){const r=E();return k(n,(()=>r.abort())),d(((n,o)=>{let i=setTimeout((()=>{i=0,n(e)}),t);k(r,(()=>{i&&(clearTimeout(i),o(g()))}))}))}function F(t,e,n,r){const o=n&&"abort"in n?n:null;null!=r||o||(r=n);let i=setTimeout((()=>{i=0,o&&o.abort()}),e);const u=()=>{throw r||new c("promiseUtils:timeout","The wrapped promise did not resolve within "+e+" ms")};return t.then((t=>{if(0===i)throw u();return clearTimeout(i),t}),(t=>{throw clearTimeout(i),0===i?u():t}))}function G(t){return t&&"function"==typeof t.then}function H(t){return t&&"object"==typeof t&&"then"in t&&"function"==typeof t.then?t:z(t)}function I(t,e=-1){let n,r,o,c,u=null;const s=(...f)=>{if(n){r=f,c&&c.reject(g()),c=x();const t=i(c.promise);if(u){const t=u;u=null,t.abort()}return t}if(o=c||x(),c=null,e>0){const r=E();n=H(t(...f,r.signal));const o=n;B(e).then((()=>{n===o&&(c?r.abort():u=r)}))}else n=1,n=H(t(...f));const l=()=>{const t=r;r=o=n=u=null,null!=t&&s(...t)},a=n,m=o;return a.then(l,l),a.then(m.resolve,m.reject),i(m.promise)};return s}function J(){let t,e;const n=d(((n,r)=>{t=n,e=r})),r=e=>{t(e)};return r.resolve=e=>t(e),r.reject=t=>e(t),r.timeout=(t,e)=>s.setTimeout((()=>r.reject(e)),t),r.promise=n,r}function K(t,e){return t.then(e,e)}function N(t){let e=E();const n=t(e.signal);let r={promise:n,finished:!1,abort:()=>{e&&(e.abort(),e=null)}};const o=()=>{r&&(r.finished=!0,r=null),e=null};return n.then(o,o),r}export{B as after,b as all,K as always,s as c,d as create,E as createAbortController,g as createAbortError,x as createDeferred,J as createResolver,N as createTask,I as debounce,p as e,C as eachAlways,O as eachAlwaysValues,w as filter,W as first,f as i,S as ignoreAbortErrors,M as isAbortError,T as isAborted,G as isPromiseLike,R as isThenable,U as logOnError,l as o,k as onAbort,D as onAbortOrThrow,m as p,q as reject,z as resolve,A as throwIfAbortError,j as throwIfAborted,L as throwIfNotAbortError,F as timeout,H as when,P as whenOrAbort};
