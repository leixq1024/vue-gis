// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.18/esri/copyright.txt for details.
//>>built
define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/has ../../../core/maybe ../../../core/Logger ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/property ../../../core/jsonMap ../../../core/accessorSupport/decorators/subclass ../../../core/Error ../../../core/urlUtils ../../../core/uuid ../../../portal/support/resourceExtension ../../../core/arrayUtils ../../../core/promiseUtils ../../../geometry/support/spatialReferenceUtils ../../../geometry/Point ../../../geometry ../../../layers/support/fieldUtils ../../../core/watchUtils ../../../layers/support/arcgisLayerUrl ../../../tasks/support/QuantizationParameters ../../../tasks/support/StatisticDefinition ../../../tasks/GenerateRendererTask ../../../geometry/support/quantizationUtils ../utils ../../statistics/support/utils ../../statistics/support/predominanceUtils ./LayerAdapter ./support/utils ../../../tasks/support/GenerateRendererParameters ../../../tasks/support/UniqueValueDefinition".split(" "),
function(K,F,z,L,M,Z,N,aa,O,t,ba,ca,da,G,p,H,P,ea,A,Q,R,S,B,T,I,U,r,C,V,n,D,W){const X=M.getLogger("esri.smartMapping.support.adapters.FeatureLayerAdapter");z=function(J){function E(a){return J.call(this,a)||this}K._inheritsLoose(E,J);var m=E.prototype;m.destroy=function(){this._hasLocalSource=null};m._isStatsSupportedOnService=function(){const a=this.layer;return!a.get("capabilities.query.supportsStatistics")||"multipatch"===this.geometryType&&!R.isHostedAgolService(a.url)&&10.5>a.version?p.reject(new t("feature-layer-adapter:not-supported",
"Layer does not support statistics query")):p.resolve()};m._fetchFeaturesFromMemory=async function(a,b,c){var d=this.layer;if(this._hasLocalSource)return(await d.queryFeatures(b)).features;if(!a)throw new t("feature-layer-adapter:insufficient-data","layerView is required to fetch the features");d=p.createAbortController();const f=Q.whenFalseOnce(a,"updating",d.signal);await p.timeout(f,5E3,d).catch(g=>{X.warn("LayerView is taking too long to update. Aborting fetch from layerView.");throw g;});return(await a.queryFeatures(b,
{signal:c})).features};m._fetchFeaturesFromService=function(a,b){return this.layer.queryFeatures(a,{signal:b}).then(c=>c&&c.features)};m._fetchFeaturesForStats=function(a){return U.getFieldsList({field:a.field,normalizationField:a.normalizationField,valueExpression:a.valueExpression}).then(b=>this.getSampleFeatures({sampleSize:-1,view:a.view,returnGeometry:a.returnGeometry,requiredFields:b,signal:a.signal}))};m._summaryStatsFromGenRend=function(a){const b=a.normalizationType,c=a.normalizationField;
return this.classBreaks({field:a.field,numClasses:5,classificationMethod:"standard-deviation",standardDeviationInterval:.25,normalizationType:b,normalizationField:"field"===b?c:void 0,minValue:a.minValue,maxValue:a.maxValue,signal:a.signal}).then(d=>{let f,g;d.classBreakInfos.some(h=>{h.hasAvg&&(f=h);return!!f});if(f){var e=f.maxValue-f.minValue;g=f.minValue+e/2;e*=4}return n.processSummaryStatisticsResult({min:d.minValue,max:d.maxValue,avg:g,stddev:e})})};m._getSummaryStatsQuery=function(a,b){const {field:c,
normalizationType:d,normalizationField:f,normalizationTotal:g}=a;b=this.supportsSQLExpression&&b?n.msSinceUnixEpochSQL(this,c):a.sqlExpression;var e=n.getFieldExpr({field:c,normalizationType:d,normalizationField:f,normalizationTotal:g,layer:this});const h=b||e;e=h?r.getRangeExpr(h,a.minValue,a.maxValue):null;const l=r.getSQLFilterForNormalization({field:c,normalizationField:f,normalizationType:d});a=r.mergeWhereClauses(a.sqlWhere,l);a=r.mergeWhereClauses(a,e);e=this.layer.createQuery();e.where=r.mergeWhereClauses(e.where,
a);e.sqlFormat=b?"standard":null;e.outStatistics=n.statisticTypes.map(k=>{const q=new B;q.statisticType="variance"===k?"var":k;q.onStatisticField=h;q.outStatisticFieldName=k+"_value";return q});return e};m._summaryStatsFromServiceQuery=async function(a,b){await this._isStatsSupportedOnService();"percent-of-total"===a.normalizationType&&(a.normalizationTotal=await this._getNormalizationTotal(a.field,a.normalizationType));const c=this._getSummaryStatsQuery(a,b);a=await this.layer.queryFeatures(c,{signal:a.signal});
b=n.getSummaryStatisticsFromFeatureSet(a,b);return n.processSummaryStatisticsResult(b)};m._summaryStatsFromClientQuery=async function(a,b){const c=this._getSummaryStatsQuery(a,b);a=await this.layer.queryFeatures(c,{signal:a.signal});b=n.getSummaryStatisticsFromFeatureSet(a,b);return n.processSummaryStatisticsResult(b)};m._summaryStatsFromMemory=async function(a,b){var c=a.field,d={field:c,valueExpression:a.valueExpression,normalizationField:a.normalizationField,view:a.view,signal:a.signal};d=a.features||
await this._fetchFeaturesForStats(d);if(!d||!d.length)throw new t("feature-layer-adapter:insufficient-data","No features are available to calculate statistics");a={...a};if("percent-of-total"===a.normalizationType){c=(await n.calculateStatsFromMemory({field:c},d)).sum;if(null==c)throw new t("feature-layer-adapter:invalid","invalid normalizationTotal");a.normalizationTotal=c}b=await n.calculateStatsFromMemory(a,d,b);return n.processSummaryStatisticsResult(b)};m._uvFromGenRenderer=function(a,b){const c=
a.field,d=new W;d.attributeField=c;const f=new D;f.classificationDefinition=d;return this.generateRenderer(f,a.signal).then(g=>{const e={},h=this.getField(c);g.uniqueValues.forEach(l=>{let k=l.value;if(null==k||""===k||"string"===typeof k&&(""===k.trim()||"\x3cnull\x3e"===k.toLowerCase()))k=null;null==e[k]?e[k]={count:l.count,data:A.isNumericField(h)&&k?Number(k):k}:e[k].count+=l.count});return{count:e}}).then(g=>n.createUVResult(g,b,a.returnAllCodedValues))};m._getUVQuery=function(a){const b=a.field,
c=a.sqlExpression;var d="countOF"+(b||"Expr");const f=new B;f.statisticType="count";f.onStatisticField=c?"1":b;f.outStatisticFieldName=d;d=this.layer.createQuery();d.where=r.mergeWhereClauses(d.where,a.sqlWhere);d.sqlFormat=c?"standard":null;d.outStatistics=[f];d.groupByFieldsForStatistics=[b||c];return d};m._uvFromServiceQuery=function(a,b){return this._isStatsSupportedOnService().then(()=>this.layer.queryFeatures(this._getUVQuery(a),{signal:a.signal})).then(c=>n.getUniqueValuesFromFeatureSet(c,
this,a.field,null,a.signal)).then(c=>n.createUVResult(c,b,a.returnAllCodedValues))};m._uvFromClientQuery=async function(a,b){var {signal:c}=a,d=this._getUVQuery(a);d=await this.layer.queryFeatures(d,{signal:c});c=await n.getUniqueValuesFromFeatureSet(d,this,a.field,null,c);return n.createUVResult(c,b,a.returnAllCodedValues)};m._uvFromMemory=async function(a,b){const {field:c,valueExpression:d,view:f,signal:g}=a;var e={field:c,valueExpression:d,view:f,signal:g};e=a.features?a.features:await this._fetchFeaturesForStats(e);
return n.calculateUniqueValuesFromMemory(a,e,b)};m._calcBinsSQL=function(a,b){const c=[],d=b.length;b.forEach((f,g)=>{f=r.mergeWhereClauses(a+" \x3e\x3d "+f[0],a+(g===d-1?" \x3c\x3d ":" \x3c ")+f[1]);c.push("WHEN ("+f+") THEN "+(g+1))});return["CASE",c.join(" "),"ELSE 0 END"].join(" ")};m._getNormalizationTotal=function(a,b,c){return a&&"percent-of-total"===b?this.summaryStatistics({field:a,signal:c}).then(d=>d.sum):p.resolve(null)};m._getQueryParamsForExpr=function(a,b){const c=a.signal;if(!a.valueExpression&&
!a.sqlExpression){const f=a.field;var d=f?this.getField(f):null;d=A.isDateField(d);b={field:f,normalizationType:a.normalizationType,normalizationField:a.normalizationField,normalizationTotal:b,layer:this};return{sqlExpression:d?n.msSinceUnixEpochSQL(this,f):n.getFieldExpr(b),sqlWhere:d?null:a.sqlWhere||r.getSQLFilterForNormalization(a),signal:c}}return{valueExpression:a.valueExpression,sqlExpression:a.sqlExpression,sqlWhere:a.sqlWhere,signal:c}};m._getDataRange=function(a,b,c){return null!=b&&null!=
c?p.resolve({min:b,max:c}):this.summaryStatistics(a).then(d=>({min:d.min,max:d.max}))};m._histogramForExpr=function(a){return this._getNormalizationTotal(a.field,a.normalizationType,a.signal).then(b=>{const c=this._getQueryParamsForExpr(a,b);return this._getDataRange(c,a.minValue,a.maxValue).then(d=>{const {min:f,max:g}=d,e=a.numBins||10;d=n.getEqualIntervalBins(f,g,e);d=this._calcBinsSQL(c.sqlExpression,d);const h=new B({statisticType:"count",outStatisticFieldName:"countOFExpr",onStatisticField:"1"}),
l=this.layer.createQuery();l.where=r.mergeWhereClauses(l.where,c.sqlWhere);l.sqlFormat="standard";l.outStatistics=[h];l.groupByFieldsForStatistics=[d];l.orderByFields=[d];return this._isStatsSupportedOnService().then(()=>this.layer.queryFeatures(l,{signal:c.signal})).then(k=>n.getHistogramFromFeatureSet(k,f,g,e,b))})})};m._histogramForField=function(a){let b=null;b=null!=a.minValue&&null!=a.maxValue?p.resolve({min:a.minValue,max:a.maxValue}):this.summaryStatistics(a).then(c=>{if(!c.count)throw new t("feature-layer-adapter:insufficient-data",
"Either the layer has no features or none of the features have data for the field");return{min:c.min,max:c.max}});return b.then(c=>this._getBins({min:c.min,max:c.max},a.field,a.numBins,a.signal))};m._getBins=function(a,b,c=10,d){const {min:f,max:g,normTotal:e,excludeZerosExpr:h}=a,l=a.intervals||n.getEqualIntervalBins(f,g,c);return this._queryBins(l,a.sqlExpr||b,h,d).then(k=>({bins:k.map((q,u)=>({minValue:l[u][0],maxValue:l[u][1],count:q.value})),minValue:f,maxValue:g,normalizationTotal:e}))};m._queryBins=
function(a,b,c,d){const f=[],g=a.length;for(let e=0;e<g;e++){const h=r.mergeWhereClauses(c,r.mergeWhereClauses(b+" \x3e\x3d "+a[e][0],null!==a[e][1]?b+(e===g-1?" \x3c\x3d ":" \x3c ")+a[e][1]:""));f.push(h)}return p.eachAlways(f.map(e=>this.queryFeatureCount(e,d)))};m._binParamsFromGenRend=function(a,b){const {field:c,normalizationType:d,normalizationField:f,signal:g}=a,e=r.getSQLFilterForNormalization({field:c,normalizationType:d,normalizationField:f});a=new D({classificationDefinition:n.createCBDefn({field:c,
normalizationType:d,normalizationField:f,classificationMethod:a.classificationMethod,standardDeviationInterval:a.standardDeviationInterval,breakCount:a.numBins||10}),where:r.mergeWhereClauses(e,b)});return this.generateRenderer(a,g).then(h=>{const {normalizationTotal:l,classBreaks:k}=h;return n.generateBinParams({field:c,normalizationType:d,normalizationField:f,normalizationTotal:l,classBreaks:k,where:e,layer:this})})};m._histogramFromMemory=function(a){const {field:b,normalizationField:c,normalizationType:d,
valueExpression:f,classificationMethod:g,minValue:e,maxValue:h,view:l,signal:k}=a,q={field:b,valueExpression:f,normalizationField:c,view:l,signal:k};return(a.features?p.resolve(a.features):this._fetchFeaturesForStats(q)).then(u=>{if(!u||!u.length)throw new t("feature-layer-adapter:insufficient-data","No features are available to calculate histogram");var v=null!=e&&null!=h;let y=null;g&&"equal-interval"!==g||d?(v={...a},v.features=u,y=this._getBinParamsFromMemory(v)):y=v?p.resolve({min:e,max:h,source:"parameters"}):
this.summaryStatistics({field:b,valueExpression:f,features:u,view:l,signal:k}).then(w=>w.count?{min:w.min,max:w.max}:p.reject(new t("feature-layer-adapter:insufficient-data","No features are available to calculate histogram")));return y.then(w=>n.calculateHistogramFromMemory(a,w,u))})};m._getBinParamsFromMemory=async function(a){const {field:b,valueExpression:c,classificationMethod:d,standardDeviationInterval:f,normalizationType:g,normalizationField:e,minValue:h,maxValue:l,features:k,view:q,signal:u}=
a;return this._classBreaksFromMemory({field:b,valueExpression:c,normalizationType:g,normalizationField:e,classificationMethod:d,standardDeviationInterval:f,minValue:h,maxValue:l,numClasses:a.numBins,features:k,view:q,signal:u}).then(v=>{const y=v.normalizationTotal;v=v.classBreakInfos;const w=r.getSQLFilterForNormalization({field:b,normalizationType:g,normalizationField:e});return n.generateBinParams({field:b,normalizationType:g,normalizationField:e,normalizationTotal:y,classBreaks:v,where:w,layer:this})})};
m._classBreaksFromGenRend=function(a){const {field:b,normalizationType:c,normalizationField:d,normalizationTotal:f,signal:g}=a,e=r.getSQLFilterForNormalization({field:b,normalizationType:c,normalizationField:d});var h=n.getFieldExpr({field:b,normalizationType:c,normalizationField:d,normalizationTotal:f,layer:this});h=r.getRangeExpr(h,a.minValue,a.maxValue);const l=n.createCBDefn({field:b,normalizationType:c,normalizationField:d,classificationMethod:a.classificationMethod,standardDeviationInterval:a.standardDeviationInterval,
breakCount:a.numClasses||5}),k=new D;k.classificationDefinition=l;k.where=r.mergeWhereClauses(e,h);return this.generateRenderer(k,g).then(q=>n.resolveCBResult(a,q))};m._classBreaksFromInterpolation=function(a){const {minValue:b,maxValue:c}=a,d=a.numClasses||5,f=[],g=(c-b)/d;for(let e=0;e<d;e++){const h=b+e*g;f.push({minValue:h,maxValue:h+g})}f[d-1].maxValue=c;a=n.resolveCBResult(a,{classBreaks:f,normalizationTotal:a.normalizationTotal});return p.resolve(a)};m._classBreaksFromMemory=async function(a){const {field:b,
normalizationField:c,valueExpression:d,view:f,signal:g}=a;var e={field:b,valueExpression:d,normalizationField:c,view:f,signal:g};e=a.features||await this._fetchFeaturesForStats(e);if(!e||!e.length)throw new t("feature-layer-adapter:insufficient-data","No features are available to calculate statistics");a={...a};if("percent-of-total"===a.normalizationType){const h=(await n.calculateStatsFromMemory({field:b},e)).sum;if(null==h)throw new t("feature-layer-adapter:invalid","invalid normalizationTotal");
a.normalizationTotal=h}return n.calculateClassBreaksFromMemory(a,e)};m._heatmapStatsFromMemory=async function(a,b){const {blurRadius:c,field:d,view:f,signal:g}=a,{resolution:e,size:h}=f.state,l=new S({extent:f.extent,tolerance:e});a=this._quantizeFeatures(a.features||await this._fetchFeaturesForStats({field:d,view:f,returnGeometry:!0,signal:g}),l,f);if(!a||!a.length)return{count:0,min:null,max:null,avg:null,stddev:null};if(b=n.calculateHeatmapStats(a,c,b,d,h[0],h[1]))return{count:b.count,min:b.min,
max:b.max,avg:b.mean,stddev:b.stdDev};throw new t("feature-layer-adapter:invalid","unable to calculate heatmap statistics");};m._quantizeFeatures=function(a,b,c){const d=I.toQuantizationTransform(b),{spatialReference:f,size:g}=c,e=H.isWrappable(f)?H.getInfo(f):null,h=e?Math.round((e.valid[1]-e.valid[0])/d.scale[0]):null;return a.map(l=>{const k=new P(L.unwrap(l.geometry));I.quantizePoint(d,k,k,k.hasZ,k.hasM);l.geometry=e?this._wrapPoint(k,h,g[0]):k;return l})};m._wrapPoint=function(a,b,c){0>a.x?a.x+=
b:a.x>c&&(a.x-=b);return a};m.getField=function(a=""){return this.layer.getField(a)};m.getFieldUsageInfo=function(a){return this.getField(a)?{supportsLabelingInfo:!0,supportsRenderer:!0,supportsPopupTemplate:!0,supportsLayerQuery:!0,supportsStatistics:!0}:null};m.getFieldDomain=function(a,b){return this.layer.getFieldDomain(a,b)};m.summaryStatistics=function(a){var b=a.field;b=b?this.getField(b):null;const c=A.isDateField(b),d=(b=a.valueExpression||a.sqlExpression)&&!a.sqlExpression;var f=a.view;
f=f&&"3d"===f.type;return this._hasLocalSource||a.features||d?d||a.features||f?this._summaryStatsFromMemory(a,c):this._summaryStatsFromClientQuery(a,c):this.supportsSQLExpression||!c&&!b?(a.normalizationType&&!this.supportsSQLExpression?this._summaryStatsFromGenRend(a):this._summaryStatsFromServiceQuery(a,c)).catch(()=>{p.throwIfAborted(a.signal);return this._summaryStatsFromMemory(a,c)}):p.reject(new t("feature-layer-adapter:not-supported","Layer does not support standardized SQL expression for queries"))};
m.uniqueValues=function(a){const {field:b,valueExpression:c,sqlExpression:d,signal:f}=a,g=(b?this.getField(b):null)&&this.getFieldDomain(b),e=c&&(!d||!this.supportsSQLExpression),h=a.view,l=h&&"3d"===h.type;return this._hasLocalSource||a.features||e?e||a.features||l?this._uvFromMemory(a,g):this._uvFromClientQuery(a,g):this._uvFromServiceQuery(a,g).catch(k=>{p.throwIfAborted(f);return a.field?this._uvFromGenRenderer(a,g):k}).catch(()=>{p.throwIfAborted(f);return e||a.features||l?this._uvFromMemory(a,
g):this._uvFromClientQuery(a,g)})};m.histogram=function(a){const {field:b,normalizationType:c,normalizationField:d,classificationMethod:f,signal:g}=a;var e=b?this.getField(b):null;e=A.isDateField(e);const h=a.valueExpression||a.sqlExpression,l=h&&!a.sqlExpression,k=this.supportsSQLExpression,q=!f||"equal-interval"===f,u=a.minValue,v=a.maxValue,y=null!=u&&null!=v,w=a.numBins||10;return this._hasLocalSource||a.features||l?this._histogramFromMemory(a):(h||k)&&q?h&&!k?p.reject(new t("feature-layer-adapter:not-supported",
"Layer does not support standardized SQL expression for queries")):this._histogramForExpr(a):e&&q?p.reject(new t("feature-layer-adapter:not-supported","Normalization and date field are not allowed when layer does not support standardized SQL expression for queries")):c||!q?this._binParamsFromGenRend(a).then(x=>{if(!y)return this._getBins(x,b,w,g);if(u>x.max||v<x.min)throw new t("histogram:insufficient-data","Range defined by 'minValue' and 'maxValue' does not intersect available data range of the field");
if(q)return this._getBins({min:u,max:v,sqlExpr:x.sqlExpr,excludeZerosExpr:x.excludeZerosExpr},b,w,g);x=n.getFieldExpr({field:b,normalizationType:c,normalizationField:d,normalizationTotal:x.normTotal,layer:this});x=r.getRangeExpr(x,u,v);return this._binParamsFromGenRend(a,x).then(Y=>this._getBins(Y,b,w,g))}):this._histogramForField(a)};m.classBreaks=function(a){const b=!1!==a.analyzeData,c=this._hasLocalSource||a.features||a.valueExpression;return b&&c?this._classBreaksFromMemory(a):(b?this._classBreaksFromGenRend(a):
this._classBreaksFromInterpolation(a)).catch(()=>{p.throwIfAborted(a.signal);return this._classBreaksFromMemory(a)})};m.queryFeatureCount=function(a,b){if(this._hasLocalSource)return p.reject(new t("feature-layer-adapter:not-supported","Layer does not support count query"));const c=this.layer,d=c.createQuery();d.where=r.mergeWhereClauses(d.where,a);return c.queryFeatureCount(d,{signal:b})};m.generateRenderer=function(a,b){var c=this.layer;if(this._hasLocalSource||10.1>c.version)return p.reject(new t("feature-layer-adapter:not-supported",
"Layer does not support generateRenderer operation (requires ArcGIS Server version 10.1+)"));const d=new T({url:c.parsedUrl.path,source:c.dynamicDataSource,gdbVersion:c.gdbVersion});c=c.createQuery();a.where=r.mergeWhereClauses(a.where,c.where);return d.execute(a,{signal:b})};m.heatmapStatistics=function(a){const {field:b,fieldOffset:c,signal:d}=a;return(b&&null==c?this.summaryStatistics({field:b,signal:d}):p.resolve(null)).then(f=>{let g=c||0;if(f){const {count:e,min:h,max:l}=f;e?h===l&&0===h?g=
1:0>=l?g="abs":0>h&&(g=-1.01*h):g=1}return this._heatmapStatsFromMemory(a,g).then(e=>({...e,summaryStatistics:f,fieldOffset:g}))})};m.predominantCategories=async function(a){if(!this._hasLocalSource&&!this.supportsSQLExpression)throw new t("feature-layer-adapter:not-supported","Layer does not support advanced SQL expressions and standardized queries");const {fields:b,view:c,signal:d}=a;a=C.getArcadeForPredominantCategory(b);var f=C.getSQLForPredominantCategoryName(b);a=(c&&this._hasLocalSource?await this._uvFromMemory({valueExpression:a,
view:c,signal:d}):await this._uvFromServiceQuery({sqlExpression:f.expression,valueExpression:a,signal:d})).uniqueValueInfos;const g=a.map(e=>e.value);f=b.filter(e=>-1===g.indexOf(e));for(const e of f)a.push({value:e,count:0});a.sort((e,h)=>b.indexOf(e.value)-b.indexOf(h.value));for(const e of a)e.value===C.noDominantCategoryField&&(e.value=null);return{predominantCategoryInfos:a}};m.getSampleFeatures=async function(a){const {view:b,sampleSize:c,requiredFields:d,returnGeometry:f,signal:g}=a,e=this.layer.createQuery();
e.outSpatialReference=a.spatialReference||b&&b.spatialReference;e.returnGeometry=!!f;e.outFields=d;let h=[];var l=!1;if(b)try{const k=await b.whenLayerView(this.layer);if(l=!(await n.getMissingFields(this,d,k)).length)if(h=await this._fetchFeaturesFromMemory(k,e,g),h.length&&0<c&&c<=h.length)return G.pickRandom(h,c,1)}catch(k){p.throwIfAborted(g)}try{if(this._hasLocalSource)return l?h:this._fetchFeaturesFromService(e,g);const k=await this.queryFeatureCount(null,g),q=this.layer.capabilities.query.maxRecordCount;
l=-1===c?k:c;l=q&&l>q?q:l;if(k<=h.length||h.length>=q)return h;const u=b.extent.width/b.width/b.scale*4E5;e.maxAllowableOffset=a.resolution||u;if(k<=l)return this._fetchFeaturesFromService(e,g);if(2E4>=k){const v=await this.layer.queryObjectIds();e.objectIds=G.pickRandom(v,l,1);return this._fetchFeaturesFromService(e,g)}this.layer.get("capabilities.query.supportsPagination")&&(e.num=Math.min(l,2E4));return this._fetchFeaturesFromService(e,g)}catch(k){return p.throwIfAborted(g),h}};m.load=function(a){a=
this.layer.load(a).then(b=>{this.geometryType=b.geometryType;this.objectIdField=b.objectIdField;this.supportsSQLExpression=b.get("capabilities.query.supportsSqlExpression");this.hasQueryEngine=this._hasLocalSource=!b.url&&!!b.source;this.minScale=b.minScale;this.maxScale=b.maxScale;this.fullExtent=b.fullExtent});this.addResolvingPromise(a);return p.resolve(this)};return E}(V);F.__decorate([N.property({constructOnly:!0})],z.prototype,"layer",void 0);return z=F.__decorate([O.subclass("esri.smartMapping.support.adapters.FeatureLayerAdapter")],
z)});