// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.18/esri/copyright.txt for details.
//>>built
define(["exports","../../../core/has","../../../core/maybe","../../../core/libs/rbush/PooledRBush"],function(k,p,q,l){function m(b,e,a,c){return{minX:Math.min(b[e+0],b[a+0],b[c+0]),maxX:Math.max(b[e+0],b[a+0],b[c+0]),minY:Math.min(b[e+1],b[a+1],b[c+1]),maxY:Math.max(b[e+1],b[a+1],b[c+1]),p0:[b[e+0],b[e+1],b[e+2]],p1:[b[a+0],b[a+1],b[a+2]],p2:[b[c+0],b[c+1],b[c+2]]}}let n=function(){function b(){}var e=b.prototype;e.createIndex=async function(a,c){const d=[];if(!a.vertexAttributes||!a.vertexAttributes.position)return new l.PooledRBush;
a=this.createMeshData(a);c=q.isSome(c)?await c.invoke("createIndexThread",a,{transferList:d}):this.createIndexThread(a).result;return this.createPooledRBush().fromJSON(c)};e.createIndexThread=function(a){const c=new Float64Array(a.position),d=this.createPooledRBush();return a.components?this.createIndexComponentsThread(d,c,a.components.map(f=>new Uint32Array(f))):this.createIndexAllThread(d,c)};e.createIndexAllThread=function(a,c){const d=Array(c.length/9);let f=0;for(let g=0;g<c.length;g+=9)d[f++]=
m(c,g+0,g+3,g+6);a.load(d);return{result:a.toJSON()}};e.createIndexComponentsThread=function(a,c,d){var f=0;for(var g of d)f+=g.length/3;f=Array(f);g=0;for(const h of d)for(d=0;d<h.length;d+=3)f[g++]=m(c,3*h[d+0],3*h[d+1],3*h[d+2]);a.load(f);return{result:a.toJSON()}};e.createMeshData=function(a){const c=a.vertexAttributes.position.buffer;return!a.components||a.components.some(d=>!d.faces)?{position:c}:{position:c,components:a.components.map(d=>d.faces)}};e.createPooledRBush=function(){return new l.PooledRBush(9,
p("csp-restrictions")?a=>a:[".minX",".minY",".maxX",".maxY"])};return b}();k.ElevationSamplerWorker=n;k.default=n;Object.defineProperty(k,"__esModule",{value:!0})});