// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.18/esri/copyright.txt for details.
//>>built
define("exports ./enums ./Utils ./MemoryRequirements ./TileBufferData ./WGLDisplayRecord ./TileDisplayData ./util/Writer ./mesh/MeshData ./mesh/VertexBuffer".split(" "),function(E,A,v,B,C,G,D,H,I,J){const r=new B,q=new B;B=function(){function n(){this.tileBufferData=this.tileDisplayData=null}var x=n.prototype;x.reshuffle=function(){r.reset();const e=D.groupRecordsByGeometryType(this.tileDisplayData.displayObjects);for(var f of e)for(var b of f)b&&r.needMore(b.geometryType,b.meshData?b.meshData.vertexCount:
b.vertexCount,b.meshData?b.meshData.indexData.length:b.indexCount);f=e.length;b=new C;for(var h=0;h<f;++h){b.geometries[h].indexBuffer=new Uint32Array(Math.round(1.5*r.indicesFor(h)));var k=[];for(var g in this.tileBufferData.geometries[h].vertexBuffer)k.push(this.tileBufferData.geometries[h].vertexBuffer[g].stride);k=n._computeVertexAlignment(k);var d=Math.round(1.5*r.verticesFor(h));k=n._align(d,k);for(var c in this.tileBufferData.geometries[h].vertexBuffer)d=this.tileBufferData.geometries[h].vertexBuffer[c].stride,
b.geometries[h].vertexBuffer[c]={stride:d,data:v.allocateTypedArrayBuffer(k,d)}}q.reset();this.tileDisplayData.displayList.clear();for(g=0;g<f;++g){c=e[g];for(const a of c){if(a.meshData)a.writeMeshDataToBuffers(q.verticesFor(g),b.geometries[g].vertexBuffer,q.indicesFor(g),b.geometries[g].indexBuffer),a.meshData=null;else{h=this.tileBufferData.geometries[g].vertexBuffer;k=this.tileBufferData.geometries[g].indexBuffer;d=b.geometries[g].vertexBuffer;const p=b.geometries[g].indexBuffer,m=q.verticesFor(g),
l=q.indicesFor(g);v.copyMeshData(m,l,d,p,a,h,k);a.vertexFrom=m;a.indexFrom=l}q.needMore(g,a.vertexCount,a.indexCount)}this.tileDisplayData.displayList.unified||this.tileDisplayData.displayList.addToList(c)}if(this.tileDisplayData.displayList.unified)for(const a of this.tileDisplayData.displayObjects)this.tileDisplayData.displayList.addToList(a.displayRecords);this.tileBufferData=b};x.reshuffleBulkAdd=function(e,f,b){const h=e.addOrUpdate.tileDisplayData.displayObjects;var k=this.tileDisplayData.displayObjects;
r.reset();for(var g=0;g<k.length;g++){var d=k[g];for(var c=0;c<d.displayRecords.length;c++){var a=d.displayRecords[c];r.needMore(a.geometryType,a.vertexCount,a.indexCount)}}for(g=f;g<h.length;g++)for(d=h[g],c=g===f?b:0;c<d.displayRecords.length;c++)a=d.displayRecords[c],r.needMore(a.geometryType,a.vertexCount,a.indexCount);g=new C;for(d=0;5>d;d++){g.geometries[d].indexBuffer=new Uint32Array(Math.round(1.5*r.indicesFor(d)));a=[];c=this.tileBufferData.geometries[d].vertexBuffer;for(var p in c)a.push(c[p].stride);
a=n._computeVertexAlignment(a);var m=Math.round(1.5*r.verticesFor(d));a=n._align(m,a);for(var l in c){m=c[l].stride;var t=v.allocateTypedArrayBuffer(a,m);g.geometries[d].vertexBuffer[l]={stride:m,data:t}}}q.reset();this.tileDisplayData.displayList.clear();for(p=0;p<k.length;p++)for(l=k[p],d=0;d<l.displayRecords.length;d++){c=l.displayRecords[d];a=c.geometryType;m=this.tileBufferData.geometries[a].vertexBuffer;t=this.tileBufferData.geometries[a].indexBuffer;var u=g.geometries[a].vertexBuffer,y=g.geometries[a].indexBuffer,
w=q.verticesFor(a),z=q.indicesFor(a);v.copyMeshData(w,z,u,y,c,m,t);c.vertexFrom=w;c.indexFrom=z;q.needMore(a,c.vertexCount,c.indexCount);this.tileDisplayData.displayList.addToList(c)}k=this.tileDisplayData.displayObjectRegistry;if(0!==b)for(p=h[f],l=0;l<b;l++)d=p.displayRecords[l],k.get(p.id)&&d.geometryType!==A.WGLGeometryType.FILL&&d.geometryType!==A.WGLGeometryType.LINE||(c=d.geometryType,a=this.tileBufferData.geometries[c].vertexBuffer,m=this.tileBufferData.geometries[c].indexBuffer,t=g.geometries[c].vertexBuffer,
u=g.geometries[c].indexBuffer,y=q.verticesFor(c),w=q.indicesFor(c),v.copyMeshData(y,w,t,u,d,a,m),d.vertexFrom=y,d.indexFrom=w,q.needMore(c,d.vertexCount,d.indexCount),this.tileDisplayData.displayList.addToList(d));for(p=f;p<h.length;p++){l=h[p];c=p===f?b:0;for(d=k.get(l.id);c<l.displayRecords.length;c++){a=l.displayRecords[c];if(d){if(a.geometryType!==A.WGLGeometryType.FILL&&a.geometryType!==A.WGLGeometryType.LINE)continue;d.displayRecords.push(a)}m=a.geometryType;u=e.addOrUpdate.tileBufferData.geometries[m];
t=u.vertexBuffer;u=u.indexBuffer;y=g.geometries[m].vertexBuffer;w=g.geometries[m].indexBuffer;z=q.verticesFor(m);const F=q.indicesFor(m);v.copyMeshData(z,F,y,w,a,t,u);a.vertexFrom=z;a.indexFrom=F;q.needMore(m,a.vertexCount,a.indexCount);this.tileDisplayData.displayList.addToList(a)}d||(k.set(l.id,l),this.tileDisplayData.displayObjects.push(l))}this.tileBufferData=g};x.getStrides=function(){const e=[];for(let f=0;f<this.tileBufferData.geometries.length;++f){const b=this.tileBufferData.geometries[f];
e[f]={};for(const h in b.vertexBuffer)e[f][h]=b.vertexBuffer[h].stride}return e};x.clone=function(){const e=new n;e.tileBufferData=this.tileBufferData.clone();e.tileDisplayData=this.tileDisplayData.clone();return e};x._guessSize=function(){const {displayObjects:e}=this.tileDisplayData,f=Math.min(e.length,4);let b=0;for(let h=0;h<f;h++)b=Math.max(b,e[h].displayRecords.length);return 2*(12*e.length+e.length*b*40)};x.serialize=function(){const e=this.tileBufferData.serialize(),f=this.tileBufferData.getBuffers(),
b=this.tileDisplayData.serialize(new H(Int32Array,this._guessSize())).buffer();f.push(b);return{result:{displayData:b,bufferData:e},transferList:f}};n.decode=function(e){const f=I.MeshData.deserializeDisplayObjects(e),b={};for(const h in e.vertexBuffersMap)b[h]=J.VertexBuffers.decode(e.vertexBuffersMap[h]);return n.fromMeshData({displayObjects:f,vertexBuffersMap:b})};n.fromMeshData=function(e){const f=new n,b=new D["default"],h=new C;b.displayObjects=e.displayObjects;for(const k in e.vertexBuffersMap){const g=
e.vertexBuffersMap[k];h.geometries[k].indexBuffer=g.indexBuffer;h.geometries[k].vertexBuffer=g.namedBuffers}f.tileDisplayData=b;f.tileBufferData=h;return f};n.bind=function(e,f){const b=new n;b.tileDisplayData=e;b.tileBufferData=f;return b};n.create=function(e,f){const b=new n;b.tileDisplayData=new D["default"];b.tileDisplayData.displayObjects=e;const h=[0,0,0,0,0],k=[0,0,0,0,0],g=[[],[],[],[],[]];for(var d of e)for(var c of d.displayRecords)g[c.geometryType].push(c),h[c.geometryType]+=c.meshData.vertexCount,
k[c.geometryType]+=c.meshData.indexData.length;e=new C;f=[f.fill||{},f.line||{},f.icon||{},f.text||{},f.label||{}];for(d=0;5>d;d++){c=new Uint32Array(k[d]);{var a=f[d];var p=h[d];const m={};for(const l in a){const t={data:v.allocateTypedArrayBuffer(p,a[l]),stride:a[l]};m[l]=t}a=m}G.writeAllMeshDataToBuffers(g[d],a,c);e.geometries[d]={indexBuffer:c,vertexBuffer:a}}b.tileBufferData=e;return b};n._align=function(e,f){const b=e%f;return 0===b?e:e+(f-b)};n._computeVertexAlignment=function(e){let f=!1,
b=!1;for(const h of e)2===h%4?f=!0:0!==h%4&&(b=!0);return b?4:f?2:1};return n}();E.TileData=B;Object.defineProperty(E,"__esModule",{value:!0})});