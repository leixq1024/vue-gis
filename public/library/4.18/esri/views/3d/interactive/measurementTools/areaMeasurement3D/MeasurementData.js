// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.18/esri/copyright.txt for details.
//>>built
define("../../../../../geometry/SpatialReference ../../../../../geometry/support/intersects ../../../../../core/mathUtils ../../../../../chunks/vec3f64 ../../../../../chunks/vec3 ../../../support/mathUtils ../../../../../geometry/projectionEllipsoid ../../../../../geometry/projection ../../../../../core/Quantity ../../../../../chunks/vec2f64 ../../../../../chunks/vec4f64 ../../../../../core/libs/earcut/earcut ../../../../../chunks/vec2 ../support/viewUtils ../support/measurementUtils".split(" "),
function(J,E,K,g,l,B,C,t,z,F,L,G,D,H,w){function I(y,m){const a=new Float64Array(y.length*m);for(let c=0;c<y.length;++c){const d=y[c];for(let b=0;b<m;++b)a[c*m+b]=d[b]}return a}return function(){function y(){this.positionsWorldCoords=[];this.positionsRenderCoords=[];this.positionsProjectedWorldCoords=[];this.positionsFittedRenderCoords=[];this.positionsGeographic=[];this.positionsSpherical=[];this.positionsStereographic=[];this.pathSegmentLengths=[];this.geodesicPathSegmentLengths=[];this.perimeterSegmentLengths=
[];this.intersectingSegments=new Set;this.geodesicIntersectingSegments=new Set;this.areaCentroidWorldCoords=g.create();this.areaCentroidRenderCoords=g.create();this.geodesicAreaCentroidRenderCoords=g.create();this._length=0;this._centroidRenderCoords=g.create();this._planeWorldCoords=L.create();this._worldUp=g.create();this._worldTangent=g.create();this._frame=[g.create(),g.create(),g.create()];this._tempU=g.create();this._tempV=g.create();this._tempVec3=g.create();this._tempSphere={center:g.create(),
radius:0}}var m=y.prototype;m.update=function(a,c,d,b,e,f,p){this._resize(a.length);const u=C.getSphericalPCPF(c.spatialReference),q=t.canProjectWithoutEngine(c.spatialReference,u)&&t.canProjectToWGS84ComparableLonLat(c.spatialReference),n=this.positionsGeographic,h=this.positionsWorldCoords,x=this.positionsRenderCoords,v=this.positionsSpherical;for(let k=0;k<a.length;++k){const r=a.vertex(k);t.projectPointToVector(r,h[k],f);t.projectPointToVector(r,x[k],e);q&&(t.projectPointToWGS84ComparableLonLat(r,
n[k]),t.projectPointToVector(r,v[k],u),l.normalize(v[k],v[k]))}a=this._updatePathLengths(b);this.pathLength=0<this._length?new z(d.normalizeDistance(a),"meters"):null;q?(a=this._updateGeodesicPathLengths(b,f),this.geodesicPathLength=0<this._length?new z(a,"meters"):null):this.geodesicPathLength=null;b?(this._updateArea(c,d,e,f,p),q&&this._updateGeodesicArea(c)):(this.geodesicTriangleIndices=this.triangleIndices=this.perimeterLength=this.geodesicArea=this.area=null,this.intersectingSegments.clear(),
this.geodesicIntersectingSegments.clear())};m._resize=function(a){a<this._length&&(this.positionsWorldCoords.length=a,this.positionsRenderCoords.length=a,this.positionsProjectedWorldCoords.length=a,this.positionsFittedRenderCoords.length=a,this.positionsGeographic.length=a,this.positionsSpherical.length=a,this.positionsStereographic.length=a,this.pathSegmentLengths.length=a,this.geodesicPathSegmentLengths.length=a,this._length=this.perimeterSegmentLengths.length=a);for(;this._length<a;)this.positionsWorldCoords.push(g.create()),
this.positionsRenderCoords.push(g.create()),this.positionsProjectedWorldCoords.push(F.create()),this.positionsFittedRenderCoords.push(g.create()),this.positionsGeographic.push(g.create()),this.positionsSpherical.push(g.create()),this.positionsStereographic.push(F.create()),this.pathSegmentLengths.push(0),this.geodesicPathSegmentLengths.push(0),this.perimeterSegmentLengths.push(0),++this._length};m._updatePathLengths=function(a){const c=this.positionsWorldCoords,d=this.pathSegmentLengths;let b=0;for(let e=
0;e<this._length;++e){const f=d[e]=l.distance(c[e],c[(e+1)%this._length]);if(e<this._length-1||a)b+=f}return b};m._updateGeodesicPathLengths=function(a,c){const d=this.positionsGeographic,b=this.geodesicPathSegmentLengths;let e=0;for(let f=0;f<this._length;++f){const p=b[f]=w.segmentLengthGeodesicVector(d[f],d[(f+1)%this._length],c);if(f<this._length-1||a)e+=p}return e};m._updateArea=function(a,c,d,b,e){const f=a.renderCoordsHelper;a=this.positionsWorldCoords;const p=this.positionsRenderCoords,u=
this.positionsProjectedWorldCoords,q=this.positionsFittedRenderCoords;var n=this._planeWorldCoords,h=this._centroidRenderCoords;H.midpoint(p,h);f.worldUpAtPosition(h,this._worldUp);f.worldBasisAtPosition(h,0,this._worldTangent);t.projectDirection(h,this._worldUp,d,this._worldUp,b);t.projectDirection(h,this._worldTangent,d,this._worldTangent,b);2<a.length&&w.bestFitPlane(a,n);this.fittingMode=this._selectFittingMode(n,a,this._worldUp,e);let x=0;if("horizontal"===this.fittingMode){let k=-Infinity;p.forEach((r,
A)=>{r=f.getAltitude(p[A]);r>k&&(k=r,x=A)})}e=a[x];h=n;var v=this._worldTangent;"horizontal"===this.fittingMode?h=this._worldUp:"vertical"===this.fittingMode&&(h=this._tempVec3,v=this._worldUp,B.makeOrthonormal(n,this._worldUp,h));l.copy(this._frame[2],h);B.makeOrthonormal(v,h,this._frame[0]);l.cross(this._frame[1],this._frame[0],this._frame[2]);l.negate(this._frame[1],this._frame[1]);n=this._tempVec3;h=this._tempU;v=this._tempV;for(let k=0;k<this._length;++k){const r=u[k],A=q[k];l.subtract(n,a[k],
e);D.set(r,l.dot(this._frame[0],n),l.dot(this._frame[1],n));l.scale(h,this._frame[0],r[0]);l.scale(v,this._frame[1],r[1]);l.add(n,h,v);l.add(n,n,e);t.projectVectorToVector(n,b,A,d)}this.perimeterLength=0<this._length?new z(c.normalizeDistance(this._updatePerimeterLengths()),"meters"):null;H.midpoint(q,this.areaCentroidRenderCoords);t.projectVectorToVector(this.areaCentroidRenderCoords,d,this.areaCentroidWorldCoords,b);this._updateIntersectingSegments();this.area=0===this.intersectingSegments.size?
new z(c.normalizeArea(this._computeArea()),"square-meters"):null};m._updateGeodesicArea=function(a){const c=a.renderCoordsHelper,d=this.positionsSpherical,b=this.positionsStereographic,e=this._tempVec3,f=w.fitHemisphere(d,e);if(f){var p=this._tempU,u=this._tempV;B.tangentFrame(e,p,u);for(let q=0;q<this._length;++q){const n=l.dot(d[q],p),h=l.dot(d[q],u),x=l.dot(d[q],e);D.set(b[q],n/x,h/x)}l.scale(e,e,C.getReferenceEllipsoid(a.spatialReference).radius);c.toRenderCoords(e,C.getSphericalPCPF(a.spatialReference),
this.geodesicAreaCentroidRenderCoords);this._updateGeodesicIntersectingSegments();this.geodesicArea=f&&0===this.geodesicIntersectingSegments.size?new z(this._computeGeodesicArea(),"square-meters"):null}else this.geodesicArea=null};m._updatePerimeterLengths=function(){const a=this.positionsProjectedWorldCoords,c=this.perimeterSegmentLengths;let d=0;for(let b=0;b<this._length;++b){const e=c[b]=D.distance(a[b],a[(b+1)%this._length]);d+=e}return d};m._updateIntersectingSegments=function(){const a=this.positionsProjectedWorldCoords,
c=this.intersectingSegments;c.clear();for(let d=0;d<this._length;++d)for(let b=d+2;b<this._length;++b)(b+1)%this._length!==d&&E.segmentIntersects(a[d],a[(d+1)%this._length],a[b],a[(b+1)%this._length])&&(c.add(d),c.add(b))};m._computeArea=function(){const a=this.positionsProjectedWorldCoords;var c=I(a,2);c=this.triangleIndices=new Uint32Array(G.earcut(c,[],2));let d=0;for(let b=0;b<c.length;b+=3)d+=w.triangleAreaEuclidean(a[c[b]],a[c[b+1]],a[c[b+2]]);return d};m._updateGeodesicIntersectingSegments=
function(){const a=this.positionsStereographic,c=this.geodesicIntersectingSegments;c.clear();for(let d=0;d<this._length;++d)for(let b=d+2;b<this._length;++b)(b+1)%this._length!==d&&E.segmentIntersects(a[d],a[(d+1)%this._length],a[b],a[(b+1)%this._length])&&(c.add(d),c.add(b))};m._computeGeodesicArea=function(){const a=this.positionsGeographic;var c=I(this.positionsStereographic,2);c=this.geodesicTriangleIndices=new Uint32Array(G.earcut(c,[],2));let d=0;for(let b=0;b<c.length;b+=3)d+=w.triangleAreaGeodesic(a[c[b]],
a[c[b+1]],a[c[b+2]],J.WGS84);return d};m._selectFittingMode=function(a,c,d,b){var e=c.map(p=>Math.abs(w.planePointDistance(a,p))).reduce((p,u)=>Math.max(p,u),0);w.boundingSphere(c,this._tempSphere);c=e/(2*this._tempSphere.radius);e=c<b.maxRelativeErrorAlmostCoplanar;let f="horizontal";c<b.maxRelativeErrorCoplanar?f="oblique":e&&(f=Math.abs(l.dot(d,a))>Math.cos(K.deg2rad(b.verticalAngleThreshold))?"horizontal":"vertical");return f};return y}()});