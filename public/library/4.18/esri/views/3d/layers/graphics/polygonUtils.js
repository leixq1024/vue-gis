// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.18/esri/copyright.txt for details.
//>>built
define("exports ../../../../core/maybe ../../../../geometry/Extent ../../../../geometry/Polygon ../../../../geometry ../../../../geometry/projection ../../../../geometry/support/triangulationUtils ../../webgl-engine/lib/Util ../../webgl-engine/lib/GeometryData ./elevationAlignmentUtils ../../terrain/OverlayRenderer".split(" "),function(k,h,t,u,B,v,m,d,n,w,x){function p(a,c,b){const g=[];for(const {index:e,count:f}of a){if(1>=f)continue;a=3*e;const l=a+3*f;g.push({index:e,count:f,position:c.subarray(a,
l),mapPosition:b?b.subarray(a,l):void 0})}return g}function q(a,c,b){const g=[];for(const {index:e,count:f,holeIndices:l,pathLengths:y}of a){if(1>=f)continue;a=3*e;const r=a+3*f,A=l.map(z=>z-e);g.push({index:e,count:f,holeIndices:A,pathLengths:y,position:c.subarray(a,r),mapPosition:b?b.subarray(a,r):void 0})}return g}k.createColorGeometryData=function(a){const c={},b={};b[d.VertexAttrConstants.POSITION]={size:3,data:a.attributeData.position};c[d.VertexAttrConstants.POSITION]=a.indices;if(h.isSome(a.attributeData.color)){const g=
new Uint32Array(a.indices.length);b[d.VertexAttrConstants.COLOR]={size:4,data:a.attributeData.color};c[d.VertexAttrConstants.COLOR]=g}h.isSome(a.attributeData.uvMapSpace)&&(b[d.VertexAttrConstants.UVMAPSPACE]={size:4,data:a.attributeData.uvMapSpace},c[d.VertexAttrConstants.UVMAPSPACE]=a.indices);h.isSome(a.attributeData.bound1)&&(b[d.VertexAttrConstants.BOUND1]={size:3,data:a.attributeData.bound1},c[d.VertexAttrConstants.BOUND1]=a.indices);h.isSome(a.attributeData.bound2)&&(b[d.VertexAttrConstants.BOUND2]=
{size:3,data:a.attributeData.bound2},c[d.VertexAttrConstants.BOUND2]=a.indices);h.isSome(a.attributeData.bound3)&&(b[d.VertexAttrConstants.BOUND3]={size:3,data:a.attributeData.bound3},c[d.VertexAttrConstants.BOUND3]=a.indices);h.isSome(a.attributeData.mapPosition)&&(b.mapPos={size:3,data:a.attributeData.mapPosition},c.mapPos=a.indices);return new n.GeometryData(b,c)};k.createWaterGeometryData=function(a){const c={},b={};b[d.VertexAttrConstants.POSITION]={size:3,data:a.attributeData.position};c[d.VertexAttrConstants.POSITION]=
a.indices;b[d.VertexAttrConstants.UV0]={size:2,data:a.attributeData.uv0};c[d.VertexAttrConstants.UV0]=a.indices;h.isSome(a.attributeData.mapPosition)&&(b.mapPos={size:3,data:a.attributeData.mapPosition},c.mapPos=a.indices);return new n.GeometryData(b,c)};k.geometryAsPolygon=function(a){switch(a.type){case "extent":if(a instanceof t)return u.fromExtent(a);break;case "polygon":return a}return null};k.geometryToRenderInfo=function(a,c,b,g){const e=m.pathsToTriangulationInfo(a.rings,a.hasZ,1),f=new Float64Array(e.position.length);
a=w.applyPerVertexElevationAlignment(e.position,a.spatialReference,0,f,0,e.position,0,e.position.length/3,c,b,g);c=null!=a;return{position:e.position,mapPosition:f,polygons:q(e.polygons,e.position,f),outlines:p(e.outlines,e.position,f),projectionSuccess:c,sampledElevation:a}};k.geometryToRenderInfoDraped=function(a,c){const b=m.pathsToTriangulationInfo(a.rings,!1,1);a=v.projectBuffer(b.position,a.spatialReference,0,b.position,c,0,b.position.length/3);for(c=2;c<b.position.length;c+=3)b.position[c]=
x.DRAPED_Z;return{position:b.position,polygons:q(b.polygons,b.position),outlines:p(b.outlines,b.position),projectionSuccess:a}};Object.defineProperty(k,"__esModule",{value:!0})});