// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.18/esri/copyright.txt for details.
//>>built
define("../../../../chunks/vec3f64 ../../../../chunks/vec3 ../../../../chunks/vec3f32 ../../support/geometryUtils ./BufferVectorMath ./Util ./GeometryData".split(" "),function(da,l,u,S,ea,k,G){const P=ea.Vec3Compact;var U;(function(C){const E=[[-.5,-.5,.5],[.5,-.5,.5],[.5,.5,.5],[-.5,.5,.5],[-.5,-.5,-.5],[.5,-.5,-.5],[.5,.5,-.5],[-.5,.5,-.5]],J=[0,0,1,-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1],L=[0,0,1,0,1,1,0,1],b=[0,1,2,2,3,0,4,0,3,3,7,4,1,5,6,6,2,1,1,0,4,4,5,1,3,2,6,6,7,3,5,4,7,7,6,5],d=Array(36);for(var a=
0;6>a;a++)for(let e=0;6>e;e++)d[6*a+e]=a;const c=Array(36);for(a=0;6>a;a++)c[6*a]=0,c[6*a+1]=1,c[6*a+2]=2,c[6*a+3]=2,c[6*a+4]=3,c[6*a+5]=0;C.createGeometry=function(e){Array.isArray(e)||(e=[e,e,e]);const g=new Float32Array(24);for(var f=0;8>f;f++)g[3*f]=E[f][0]*e[0],g[3*f+1]=E[f][1]*e[1],g[3*f+2]=E[f][2]*e[2];e={};e[k.VertexAttrConstants.POSITION]=new Uint32Array(b);e[k.VertexAttrConstants.NORMAL]=new Uint32Array(d);e[k.VertexAttrConstants.UV0]=new Uint32Array(c);f={};f[k.VertexAttrConstants.POSITION]=
{size:3,data:g};f[k.VertexAttrConstants.NORMAL]={size:3,data:new Float32Array(J)};f[k.VertexAttrConstants.UV0]={size:2,data:new Float32Array(L)};return new G.GeometryData(f,e)}})(U||(U={}));var V;(function(C){const E=[[-.5,0,-.5],[.5,0,-.5],[.5,0,.5],[-.5,0,.5],[0,-.5,0],[0,.5,0]],J=[0,1,-1,1,1,0,0,1,1,-1,1,0,0,-1,-1,1,-1,0,0,-1,1,-1,-1,0],L=[5,1,0,5,2,1,5,3,2,5,0,3,4,0,1,4,1,2,4,2,3,4,3,0],b=[0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7];C.createGeometry=function(d){Array.isArray(d)||(d=[d,d,
d]);const a=new Float32Array(18);for(var c=0;6>c;c++)a[3*c]=E[c][0]*d[0],a[3*c+1]=E[c][1]*d[1],a[3*c+2]=E[c][2]*d[2];d={};d[k.VertexAttrConstants.POSITION]=new Uint32Array(L);d[k.VertexAttrConstants.NORMAL]=new Uint32Array(b);c={};c[k.VertexAttrConstants.POSITION]={size:3,data:a};c[k.VertexAttrConstants.NORMAL]={size:3,data:new Float32Array(J)};return new G.GeometryData(c,d)}})(V||(V={}));var W;(function(C){const E=u.fromValues(-.5,0,-.5),J=u.fromValues(.5,0,-.5),L=u.fromValues(0,0,.5),b=u.fromValues(0,
.5,0),d=u.create(),a=u.create(),c=u.create(),e=u.create(),g=u.create();l.subtract(d,E,b);l.subtract(a,E,J);l.cross(c,d,a);l.normalize(c,c);l.subtract(d,J,b);l.subtract(a,J,L);l.cross(e,d,a);l.normalize(e,e);l.subtract(d,L,b);l.subtract(a,L,E);l.cross(g,d,a);l.normalize(g,g);const f=[E,J,L,b],h=[0,-1,0,c[0],c[1],c[2],e[0],e[1],e[2],g[0],g[1],g[2]],m=[0,1,2,3,1,0,3,2,1,3,0,2],q=[0,0,0,1,1,1,2,2,2,3,3,3];C.createGeometry=function(p){Array.isArray(p)||(p=[p,p,p]);const n=new Float32Array(12);for(var r=
0;4>r;r++)n[3*r]=f[r][0]*p[0],n[3*r+1]=f[r][1]*p[1],n[3*r+2]=f[r][2]*p[2];p={};p[k.VertexAttrConstants.POSITION]=new Uint32Array(m);p[k.VertexAttrConstants.NORMAL]=new Uint32Array(q);r={};r[k.VertexAttrConstants.POSITION]={size:3,data:n};r[k.VertexAttrConstants.NORMAL]={size:3,data:new Float32Array(h)};return new G.GeometryData(r,p)}})(W||(W={}));var X;(function(C){function E(b,d,a,c,e){if(Math.abs(l.dot(d,b))>e)return!1;l.cross(a,b,d);l.normalize(a,a);l.cross(c,a,b);l.normalize(c,c);return!0}function J(b,
d,a,c,e,g,f){return E(b,d,e,g,f)||E(b,a,e,g,f)||E(b,c,e,g,f)}C.createBoxGeometry=U.createGeometry;C.createDiamondGeometry=V.createGeometry;C.createTetrahedronGeometry=W.createGeometry;C.createSphereGeometry=function(b,d,a,c){const {phiStart:e=-Math.PI,phiLength:g=2*Math.PI,thetaStart:f=-Math.PI/2,thetaLength:h=Math.PI}=c||{},{position:m=k.VertexAttrConstants.POSITION,normal:q=k.VertexAttrConstants.NORMAL,uv:p=k.VertexAttrConstants.UV0}=(null==c?void 0:c.attributes)||{};c=Math.max(3,Math.floor(d));
var n=Math.max(2,Math.floor(a)),r=(c+1)*(n+1);a=new Float32Array(3*r);d=new Float32Array(3*r);r=new Float32Array(2*r);const x=[];let y=0;for(var w=0;w<=n;w++){var v=[],H=w/n,z=f+H*h,t=Math.cos(z);for(var I=0;I<=c;I++){const A=I/c;var D=e+A*g;const N=Math.cos(D)*t,F=Math.sin(z);D=-Math.sin(D)*t;a[3*y]=N*b;a[3*y+1]=F*b;a[3*y+2]=D*b;d[3*y]=N;d[3*y+1]=F;d[3*y+2]=D;r[2*y]=A;r[2*y+1]=H;v.push(y);++y}x.push(v)}b=new Uint32Array(2*c*(n-1)*3);y=0;for(w=0;w<n;w++)for(v=0;v<c;v++)H=x[w][v],z=x[w][v+1],t=x[w+
1][v+1],I=x[w+1][v],0===w?(b[y++]=H,b[y++]=t,b[y++]=I):w===n-1?(b[y++]=H,b[y++]=z,b[y++]=t):(b[y++]=H,b[y++]=z,b[y++]=t,b[y++]=t,b[y++]=I,b[y++]=H);c={};c[m]=b;c[q]=b;n={};n[m]={size:3,data:a};n[q]={size:3,data:d};p&&(n[p]={size:2,data:r},c[p]=b);return new G.GeometryData(n,c)};C.createPolySphereGeometry=function(b,d,a){function c(h,m){h>m&&([h,m]=[m,h]);const q=h.toString()+"."+m.toString();if(f[q])return f[q];let p=e.length;e.length+=3;P.add(e,3*h,e,3*m,e,p);P.scale(e,p,b/P.length(e,p));p/=3;return f[q]=
p}let e;a?(e=[0,-1,0,1,0,0,0,0,1,-1,0,0,0,0,-1,0,1,0],a=new Uint32Array([0,1,2,0,2,3,0,3,4,0,4,1,1,5,2,2,5,3,3,5,4,4,5,1])):(a=b*(1+Math.sqrt(5))/2,e=[-b,a,0,b,a,0,-b,-a,0,b,-a,0,0,-b,a,0,b,a,0,-b,-a,0,b,-a,a,0,-b,a,0,b,-a,0,-b,-a,0,b],a=new Uint32Array([0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1]));for(var g=0;g<e.length;g+=3)P.scale(e,g,b/P.length(e,g));let f={};for(g=0;g<d;g++){const h=a.length,m=new Uint32Array(4*
h);for(let q=0;q<h;q+=3){const p=a[q],n=a[q+1],r=a[q+2],x=c(p,n),y=c(n,r),w=c(r,p),v=4*q;m[v]=p;m[v+1]=x;m[v+2]=w;m[v+3]=n;m[v+4]=y;m[v+5]=x;m[v+6]=r;m[v+7]=w;m[v+8]=y;m[v+9]=x;m[v+10]=y;m[v+11]=w}a=m;f={}}d=new Float32Array(e);for(g=0;g<d.length;g+=3)P.normalize(d,g);g={};g[k.VertexAttrConstants.POSITION]=a;g[k.VertexAttrConstants.NORMAL]=a;a={};a[k.VertexAttrConstants.POSITION]={size:3,data:new Float32Array(e)};a[k.VertexAttrConstants.NORMAL]={size:3,data:d};return new G.GeometryData(a,g)};C.createPointGeometry=
function(b,d,a,c,e,g,f,h){d=d?new Float64Array([d[0],d[1],d[2]]):new Float32Array([0,0,0]);b=b?new Float32Array([b[0],b[1],b[2]]):new Float32Array([0,0,1]);g=g?new Float32Array(g):new Float32Array([0,0]);a=a?new Uint8Array([255*a[0],255*a[1],255*a[2],3<a.length?255*a[3]:255]):new Uint8Array([255,255,255,255]);const m=null!=c&&2===c.length?new Float32Array(c):new Float32Array([1,1]);c={};c[k.VertexAttrConstants.POSITION]={size:3,data:d};c[k.VertexAttrConstants.NORMAL]={size:3,data:b};c[k.VertexAttrConstants.UV0]=
{size:g.length,data:g};c[k.VertexAttrConstants.COLOR]={size:4,data:a};c[k.VertexAttrConstants.SIZE]={size:2,data:m};null!=e&&(e=new Float32Array([e[0],e[1],e[2],e[3]]),c[k.VertexAttrConstants.AUXPOS1]={size:4,data:e});null!=f&&(f=new Float32Array([f[0],f[1],f[2],f[3]]),c[k.VertexAttrConstants.AUXPOS2]={size:4,data:f});return null!=h?(h.initialize(c,G.GeometryData.DefaultIndices,"point"),h):new G.GeometryData(c,G.GeometryData.DefaultIndices,"point")};C.updatePointGeometry=function(b,d,a,c,e,g,f,h){const m=
h.vertexAttributes;if(null!=b){const {data:q}=m[k.VertexAttrConstants.NORMAL];q[0]=b[0];q[1]=b[1];q[2]=b[2]}null!=d&&({data:b}=m[k.VertexAttrConstants.POSITION],b[0]=d[0],b[1]=d[1],b[2]=d[2]);null!=a&&({data:d}=m[k.VertexAttrConstants.COLOR],d[0]=a[0],d[1]=a[1],d[2]=a[2],d[3]=a[3]);null!=c&&({data:a}=m[k.VertexAttrConstants.SIZE],a[0]=c[0],a[1]=c[1]);null!=e&&({data:c}=m[k.VertexAttrConstants.AUXPOS1],c[0]=e[0],c[1]=e[1],c[2]=e[2],c[3]=e[3]);null!=g&&({data:e}=m[k.VertexAttrConstants.UV0],e[0]=g[0],
e[1]=g[1]);null!=f&&({data:g}=m[k.VertexAttrConstants.AUXPOS2],g[0]=f[0],g[1]=f[1],g[2]=f[2],g[3]=f[3]);return h};C.createPointArrayGeometry=function(b,d){const a=new Float32Array(3*b.length),c=new Float32Array(d?3*b.length:3),e=new Uint32Array(b.length),g=new Uint32Array(b.length);for(var f=0;f<b.length;f++)a[3*f]=b[f][0],a[3*f+1]=b[f][1],a[3*f+2]=b[f][2],d&&(c[3*f]=d[f][0],c[3*f+1]=d[f][1],c[3*f+2]=d[f][2]),e[f]=f,g[f]=0;d||(c[0]=0,c[1]=1,c[2]=0);b=new Float32Array(2);b[0]=0;b[1]=0;f={};f[k.VertexAttrConstants.POSITION]=
e;f[k.VertexAttrConstants.NORMAL]=d?e:g;f[k.VertexAttrConstants.UV0]=g;d={};d[k.VertexAttrConstants.POSITION]={size:3,data:a};d[k.VertexAttrConstants.NORMAL]={size:3,data:c};d[k.VertexAttrConstants.UV0]={size:2,data:b};return new G.GeometryData(d,f,"point")};C.createTriangleGeometry=function(){const b=new Float32Array([0,0,0,0,0,100,100,0,0]);var d=new Uint32Array([0,1,2]);const a=new Float32Array([0,1,0]),c=new Uint32Array([0,0,0]),e=new Float32Array([0,0]),g=new Uint32Array([0,0,0]),f={};f[k.VertexAttrConstants.POSITION]=
d;f[k.VertexAttrConstants.NORMAL]=c;f[k.VertexAttrConstants.UV0]=g;d={};d[k.VertexAttrConstants.POSITION]={size:3,data:b};d[k.VertexAttrConstants.NORMAL]={size:3,data:a};d[k.VertexAttrConstants.UV0]={size:2,data:e};return new G.GeometryData(d,f)};const L=[[-1,-1,0],[1,-1,0],[1,1,0],[-1,1,0]];C.createSquareGeometry=function(b=L){const d=new Float64Array(12);for(var a=0;4>a;a++)for(var c=0;3>c;c++)d[3*a+c]=b[a][c];b=new Uint32Array([0,1,2,2,3,0]);a=new Float32Array([0,0,1]);c=new Uint32Array([0,0,0,
0,0,0]);const e=new Float32Array([0,0,1,0,1,1,0,1]),g=new Uint8Array([255,255,255,255]);return new G.GeometryData({[k.VertexAttrConstants.POSITION]:{size:3,data:d},[k.VertexAttrConstants.NORMAL]:{size:3,data:a},[k.VertexAttrConstants.UV0]:{size:2,data:e},[k.VertexAttrConstants.COLOR]:{size:4,data:g}},{[k.VertexAttrConstants.POSITION]:b,[k.VertexAttrConstants.NORMAL]:c,[k.VertexAttrConstants.UV0]:b,[k.VertexAttrConstants.COLOR]:c})};C.createConeGeometry=function(b,d,a,c,e=!0,g=!0){var f=0,h=u.fromValues(0,
f,0),m=u.fromValues(0,f+b,0),q=u.fromValues(0,-1,0),p=u.fromValues(0,1,0);c&&(f=b,m=u.fromValues(0,0,0),h=u.fromValues(0,f,0),q=u.fromValues(0,1,0),p=u.fromValues(0,-1,0));h=[m,h];q=[q,p];p=a+2;m=Math.sqrt(b*b+d*d);if(c)for(c=a-1;0<=c;c--){var n=2*Math.PI/a*c,r=u.fromValues(Math.cos(n)*d,f,Math.sin(n)*d);h.push(r);n=u.fromValues(b*Math.cos(n)/m,-d/m,b*Math.sin(n)/m);q.push(n)}else for(c=0;c<a;c++)n=2*Math.PI/a*c,r=u.fromValues(Math.cos(n)*d,f,Math.sin(n)*d),h.push(r),n=u.fromValues(b*Math.cos(n)/
m,d/m,b*Math.sin(n)/m),q.push(n);b=new Uint32Array(6*(a+2));a=new Uint32Array(6*(a+2));f=d=0;if(e){for(e=3;e<h.length;e++)b[d++]=1,b[d++]=e-1,b[d++]=e,a[f++]=0,a[f++]=0,a[f++]=0;b[d++]=h.length-1;b[d++]=2;b[d++]=1;a[f++]=0;a[f++]=0;a[f++]=0}if(g){for(g=3;g<h.length;g++)b[d++]=g,b[d++]=g-1,b[d++]=0,a[f++]=g,a[f++]=g-1,a[f++]=1;b[d++]=0;b[d++]=2;b[d++]=h.length-1;a[f++]=1;a[f++]=2;a[f++]=q.length-1}g=new Float32Array(3*p);for(e=0;e<p;e++)g[3*e]=h[e][0],g[3*e+1]=h[e][1],g[3*e+2]=h[e][2];h=new Float32Array(3*
p);for(e=0;e<p;e++)h[3*e]=q[e][0],h[3*e+1]=q[e][1],h[3*e+2]=q[e][2];q={};q[k.VertexAttrConstants.POSITION]=b;q[k.VertexAttrConstants.NORMAL]=a;p={};p[k.VertexAttrConstants.POSITION]={size:3,data:g};p[k.VertexAttrConstants.NORMAL]={size:3,data:h};return new G.GeometryData(p,q)};C.createCylinderGeometry=function(b,d,a,c,e,g){c=c?u.clone(c):u.fromValues(1,0,0);e=e?u.clone(e):u.fromValues(0,0,0);var f=void 0===g?!0:g,h=u.create();l.normalize(h,c);const m=u.create();l.scale(m,h,Math.abs(b));const q=u.create();
l.scale(q,m,-.5);l.add(q,q,e);const p=u.fromValues(0,1,0);.2>Math.abs(1-l.dot(h,p))&&l.set(p,0,0,1);const n=u.create();l.cross(n,h,p);l.normalize(n,n);l.cross(p,n,h);g=2*a+(f?2:0);const r=a+(f?2:0);b=new Float32Array(3*g);e=new Float32Array(3*r);c=new Float32Array(2*g);const x=new Uint32Array(3*a*(f?4:2)),y=new Uint32Array(3*a*(f?4:2));f&&(b[3*(g-2)]=q[0],b[3*(g-2)+1]=q[1],b[3*(g-2)+2]=q[2],c[2*(g-2)]=0,c[2*(g-2)+1]=0,b[3*(g-1)]=b[3*(g-2)]+m[0],b[3*(g-1)+1]=b[3*(g-2)+1]+m[1],b[3*(g-1)+2]=b[3*(g-2)+
2]+m[2],c[2*(g-1)]=1,c[2*(g-1)+1]=1,e[3*(r-2)]=-h[0],e[3*(r-2)+1]=-h[1],e[3*(r-2)+2]=-h[2],e[3*(r-1)]=h[0],e[3*(r-1)+1]=h[1],e[3*(r-1)+2]=h[2]);h=function(t,I,D){x[t]=I;y[t]=D};let w=0;const v=u.create(),H=u.create();for(let t=0;t<a;t++){var z=2*Math.PI/a*t;l.scale(v,p,Math.sin(z));l.scale(H,n,Math.cos(z));l.add(v,v,H);e[3*t]=v[0];e[3*t+1]=v[1];e[3*t+2]=v[2];l.scale(v,v,d);l.add(v,v,q);b[3*t]=v[0];b[3*t+1]=v[1];b[3*t+2]=v[2];c[2*t]=t/a;c[2*t+1]=0;b[3*(t+a)]=b[3*t]+m[0];b[3*(t+a)+1]=b[3*t+1]+m[1];
b[3*(t+a)+2]=b[3*t+2]+m[2];c[2*(t+a)]=t/a;c[2*t+1]=1;z=(t+1)%a;h(w++,t,t);h(w++,t+a,t);h(w++,z,z);h(w++,z,z);h(w++,t+a,t);h(w++,z+a,z)}if(f){for(d=0;d<a;d++)f=(d+1)%a,h(w++,g-2,r-2),h(w++,d,r-2),h(w++,f,r-2);for(d=0;d<a;d++)f=(d+1)%a,h(w++,d+a,r-1),h(w++,g-1,r-1),h(w++,f+a,r-1)}a={};a[k.VertexAttrConstants.POSITION]=x;a[k.VertexAttrConstants.NORMAL]=y;a[k.VertexAttrConstants.UV0]=x;d={};d[k.VertexAttrConstants.POSITION]={size:3,data:b};d[k.VertexAttrConstants.NORMAL]={size:3,data:e};d[k.VertexAttrConstants.UV0]=
{size:2,data:c};return new G.GeometryData(d,a)};C.createTubeGeometry=function(b,d,a,c,e){a=a||10;c=null!=c?c:!0;k.assert(1<b.length);const g=[],f=[];for(let h=0;h<a;h++){g.push([0,-h-1,-((h+1)%a)-1]);const m=h/a*2*Math.PI;f.push([Math.cos(m)*d,Math.sin(m)*d])}return C.createPathExtrusionGeometry(f,b,[[0,0,0]],g,c,e)};C.createPathExtrusionGeometry=function(b,d,a,c,e,g=u.fromValues(0,0,0)){var f=b.length;const h=new Float32Array(d.length*f*3+(6*a.length||0)),m=new Float32Array(d.length*f+(2*a.length||
0)),q=new Float32Array(d.length*f*3+(a?6:0));var p=(d.length-1)*f*6+6*c.length,n=new Uint32Array(p);p=new Uint32Array(p);let r=0;var x=0;let y=0,w=0,v=0;const H=u.create(),z=u.create(),t=u.create(),I=u.create(),D=u.create(),A=u.create(),N=u.create(),F=da.create(),T=u.create(),Q=u.create(),Z=u.create(),Y=u.create(),aa=u.create(),ba=S.plane.create();l.set(T,0,1,0);l.subtract(z,d[1],d[0]);l.normalize(z,z);e?(l.add(F,d[0],g),l.normalize(t,F)):l.set(t,0,0,1);J(z,t,T,T,D,t,.99619469809);l.copy(I,t);l.copy(Y,
D);for(var B=0;B<a.length;B++)l.scale(A,D,a[B][0]),l.scale(F,t,a[B][2]),l.add(A,A,F),l.add(A,A,d[0]),h[r++]=A[0],h[r++]=A[1],h[r++]=A[2],m[y++]=0;q[x++]=-z[0];q[x++]=-z[1];q[x++]=-z[2];for(B=0;B<c.length;B++)n[w++]=0<c[B][0]?c[B][0]:-c[B][0]-1+a.length,n[w++]=0<c[B][1]?c[B][1]:-c[B][1]-1+a.length,n[w++]=0<c[B][2]?c[B][2]:-c[B][2]-1+a.length,p[v++]=0,p[v++]=0,p[v++]=0;B=a.length;const fa=a.length-1;for(let K=0;K<d.length;K++){let ca=!1;0<K&&(l.copy(H,z),K<d.length-1?(l.subtract(z,d[K+1],d[K]),l.normalize(z,
z)):ca=!0,l.add(Q,H,z),l.normalize(Q,Q),l.add(Z,d[K-1],I),S.plane.fromPositionAndNormal(d[K],Q,ba),S.plane.intersectRay(ba,S.ray.wrap(Z,H),F)?(l.subtract(F,F,d[K]),l.normalize(t,F),l.cross(D,Q,t),l.normalize(D,D)):J(Q,I,Y,T,D,t,.99619469809),l.copy(I,t),l.copy(Y,D));e&&(l.add(F,d[K],g),l.normalize(aa,F));for(let M=0;M<f;M++)if(l.scale(A,D,b[M][0]),l.scale(F,t,b[M][1]),l.add(A,A,F),l.normalize(N,A),q[x++]=N[0],q[x++]=N[1],q[x++]=N[2],e?m[y++]=l.dot(A,aa):m[y++]=A[2],l.add(A,A,d[K]),h[r++]=A[0],h[r++]=
A[1],h[r++]=A[2],!ca){var O=(M+1)%f;n[w++]=B+M;n[w++]=B+f+M;n[w++]=B+O;n[w++]=B+O;n[w++]=B+f+M;n[w++]=B+f+O;for(O=0;6>O;O++)p[v++]=n[w-6+O]-fa}B+=f}b=d[d.length-1];for(d=0;d<a.length;d++)l.scale(A,D,a[d][0]),l.scale(F,t,a[d][1]),l.add(A,A,F),l.add(A,A,b),h[r++]=A[0],h[r++]=A[1],h[r++]=A[2],m[y++]=0;a=x/3;q[x++]=z[0];q[x++]=z[1];q[x++]=z[2];f=B-f;for(x=0;x<c.length;x++)n[w++]=0<=c[x][0]?B+c[x][0]:-c[x][0]-1+f,n[w++]=0<=c[x][2]?B+c[x][2]:-c[x][2]-1+f,n[w++]=0<=c[x][1]?B+c[x][1]:-c[x][1]-1+f,p[v++]=
a,p[v++]=a,p[v++]=a;c={};c[k.VertexAttrConstants.POSITION]=n;c[k.VertexAttrConstants.NORMAL]=p;n={};n[k.VertexAttrConstants.POSITION]={size:3,data:h};n.zOffset={size:1,data:m};n[k.VertexAttrConstants.NORMAL]={size:3,data:q};return new G.GeometryData(n,c)};C.createPolylineGeometry=function(b,d){k.assert(1<b.length,"createPolylineGeometry(): polyline needs at least 2 points");k.assert(3===b[0].length,"createPolylineGeometry(): malformed vertex");k.assert(void 0===d||d.length===b.length,"createPolylineGeometry: need same number of points and normals");
k.assert(void 0===d||3===d[0].length,"createPolylineGeometry(): malformed normal");var a=new Float64Array(3*b.length);const c=new Uint32Array(2*(b.length-1));var e=0,g=0;for(var f=0;f<b.length;f++){for(var h=0;3>h;h++)a[e++]=b[f][h];0<f&&(c[g++]=f-1,c[g++]=f)}e={};g={};e[k.VertexAttrConstants.POSITION]=c;g[k.VertexAttrConstants.POSITION]={size:3,data:a};if(d){a=new Float32Array(3*d.length);f=0;for(h=0;h<b.length;h++)for(let m=0;3>m;m++)a[f++]=d[h][m];e[k.VertexAttrConstants.NORMAL]=c;g[k.VertexAttrConstants.NORMAL]=
{size:3,data:a}}return new G.GeometryData(g,e,"line")};C.createExtrudedTriangle=function(b,d,a,c){const e=new Float32Array(18);b=[[-d,0,c/2],[a,0,c/2],[0,b,c/2],[-d,0,-c/2],[a,0,-c/2],[0,b,-c/2]];for(d=0;6>d;d++)e[3*d]=b[d][0],e[3*d+1]=b[d][1],e[3*d+2]=b[d][2];b={[k.VertexAttrConstants.POSITION]:new Uint32Array([0,1,2,3,0,2,2,5,3,1,4,5,5,2,1,1,0,3,3,4,1,4,3,5])};return new G.GeometryData({[k.VertexAttrConstants.POSITION]:{size:3,data:e}},b)};C.transformInPlace=function(b,d){b=b.vertexAttributes[k.VertexAttrConstants.POSITION].data;
for(let a=0;a<b.length;a+=3)l.set(R,b[a],b[a+1],b[a+2]),l.transformMat4(R,R,d),b[a]=R[0],b[a+1]=R[1],b[a+2]=R[2]};C.cgToGIS=function(b,d=b){var a=b.getVertexAttr();b=a.position.data;var c=a.normal.data,e=d.getVertexAttr();a=e.position.data;e=e.normal.data;if(c)for(let g=0;g<c.length;g+=3){const f=c[g+1];e[g+1]=-c[g+2];e[g+2]=f}if(b)for(c=0;c<b.length;c+=3)e=b[c+1],a[c+1]=-b[c+2],a[c+2]=e;return d};C.makeOrthoBasisDirUp=E;C.makeOrthoBasisDirUpFallback=J})(X||(X={}));const R=u.create();return X});