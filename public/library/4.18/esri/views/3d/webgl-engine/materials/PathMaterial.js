// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.18/esri/copyright.txt for details.
//>>built
define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/mathUtils ../../support/buffer/BufferView ../../../../geometry/support/aaBoundingBox ../../support/buffer/InterleavedLayout ../lib/geometryDataUtils ../lib/Util ../lib/GLMaterial ./internal/MaterialUtil ../lib/Material ./internal/bufferWriterUtils ./VisualVariableMaterialParameters ./PathTechnique".split(" "),function(r,t,u,A,B,C,D,p,E,F,v,w,G,e){const H=p.assert;p=function(k){function f(a,c){a=k.call(this,c,a,I)||this;
a.supportsEdges=!0;a._vertexAttributeLocations=e.pathVertexAttributeLocations;a.techniqueConfig=new e.PathTechniqueConfiguration;a.vertexBufferLayout=f.getVertexBufferLayout(a.params);return a}t._inheritsLoose(f,k);var b=f.prototype;b.getTechniqueConfig=function(a,c){this.techniqueConfig.output=a;this.techniqueConfig.vvSize=this.params.vvSizeEnabled;this.techniqueConfig.vvColor=this.params.vvColorEnabled;this.techniqueConfig.vvOpacity=this.params.vvOpacityEnabled;this.techniqueConfig.slicePlaneEnabled=
this.params.slicePlaneEnabled;this.techniqueConfig.transparent=this.params.transparent;this.techniqueConfig.sceneHasOcludees=this.params.sceneHasOcludees;if(0===a||7===a)this.techniqueConfig.doubleSidedMode=this.params.doubleSided&&"normal"===this.params.doubleSidedType?1:this.params.doubleSided&&"winding-order"===this.params.doubleSidedType?2:0,this.techniqueConfig.receiveShadows=this.params.receiveShadows,this.techniqueConfig.receiveSSAO=this.params.receiveSSAO;this.techniqueConfig.transparencyPassType=
c?c.transparencyPassType:3;return this.techniqueConfig};b.getPassParameters=function(){return this.params};b.isVisibleInPass=function(a){return 4===a?this.params.castShadows:!0};b.isVisible=function(){const a=this.params;return k.prototype.isVisible.call(this)?0<a.opacity:!1};b.intersect=function(a,c,g,m,h,l,q){if(a.metadata){c=a.metadata.pathGeometry;g=[this.params.size[0],this.params.size[1]];if(this.params.vvSizeEnabled){var d=this.params.vvSizeOffset,n=this.params.vvSizeFactor;const x=this.params.vvSizeMinSize,
y=this.params.vvSizeMaxSize,z=c.sizeAttributeValue;g[0]*=u.clamp(d[0]+z*n[0],x[0],y[0]);g[1]*=u.clamp(d[2]+z*n[2],x[2],y[2])}d=Math.max(g[0],g[1]);a=B.fromValues(a.boundingInfo.bbMin[0]-d,a.boundingInfo.bbMin[1]-d,a.boundingInfo.bbMin[2]-d,a.boundingInfo.bbMax[0]+d,a.boundingInfo.bbMax[1]+d,a.boundingInfo.bbMax[2]+d);d=[l[0]-h[0],l[1]-h[1],l[2]-h[2]];n=Math.sqrt(d[0]*d[0]+d[1]*d[1]+d[2]*d[2]);F.intersectAabbInvDir(a,h,[n/d[0],n/d[1],n/d[2]],m.tolerance)&&(c.baked.size&&c.baked.size[0]===g[0]&&c.baked.size[1]===
g[1]||c.baked.bake(g),c.baked.intersect(h,l,q))}};b.computeAttachmentOrigin=function(a,c){a=a.data;return(a="getVertexAttr"in a?a.getVertexAttr():"vertexAttr"in a?a.vertexAttr:null)?D.computeAttachmentOriginLines(a[e.PathVertexAttrConstants.POSITION],null,!1,c):null};b.createBufferWriter=function(){return new J(this.vertexBufferLayout)};b.getGLMaterial=function(a){if(0===a.output||7===a.output||1===a.output||2===a.output||4===a.output||3===a.output&&this.params.castShadows)return new K(a)};f.getVertexBufferLayout=
function(a){let c=C.newLayout().vec3f(e.PathVertexAttrConstants.POSITION).vec4f(e.PathVertexAttrConstants.PROFILERIGHT).vec4f(e.PathVertexAttrConstants.PROFILEUP).vec4f(e.PathVertexAttrConstants.PROFILEVERTEXANDNORMAL);if(a.vvColorEnabled||a.vvSizeEnabled||a.vvOpacityEnabled)c=c.vec4f(e.PathVertexAttrConstants.FEATUREVALUE);return c};return f}(v.Material);let K=function(k){function f(a){a=k.call(this,a)||this;a.updateParameters();return a}t._inheritsLoose(f,k);var b=f.prototype;b.updateParameters=
function(a){this.technique=this.techniqueRep.acquireAndReleaseExisting(e.PathTechnique,this.material.getTechniqueConfig(this.output,a),this.technique)};b.beginSlot=function(a){return a===(this.technique.configuration.transparent?5:3)};b._updateOccludeeState=function(a){a.hasOccludees!==this.material.params.sceneHasOcludees&&this.material.setParameterValues({sceneHasOcludees:a.hasOccludees})};b._updateShadowState=function(a){a.shadowMappingEnabled!==this.technique.configuration.receiveShadows&&this.material.setParameterValues({receiveShadows:a.shadowMappingEnabled})};
b.ensureParameters=function(a){if(0===this.output||7===this.output)this._updateShadowState(a),this._updateOccludeeState(a);this.updateParameters(a)};b.bind=function(a,c){a.bindProgram(this.technique.program);this.technique.bindPass(a,this.material.getPassParameters(),c)};return f}(E);const I={size:[1,1,1],ambient:[.2,.2,.2],diffuse:[.8,.8,.8],specular:[0,0,0],opacity:1,doubleSided:!1,doubleSidedType:"normal",receiveSSAO:!0,receiveShadows:!1,castShadows:!0,slicePlaneEnabled:!1,transparent:!1,sceneHasOcludees:!1,
...G.Default,...v.materialParametersDefaults};let J=function(){function k(b){this.vertexBufferLayout=b}var f=k.prototype;f.allocate=function(b){return this.vertexBufferLayout.createBuffer(b)};f.elementCount=function(b){return b.indices[e.PathVertexAttrConstants.POSITION].length};f.write=function(b,a,c,g){const m=h=>{if(h in a.vertexAttr){const l=a.vertexAttr[h],q=a.indices[h];H(4===l.size);const d=c.getField(h,A.BufferViewVec4f);if(d)w.writeBufferVec4(q,l.data,d,g);else throw Error("unable to acquire view for "+
h);}};m(e.PathVertexAttrConstants.PROFILERIGHT);m(e.PathVertexAttrConstants.PROFILEUP);m(e.PathVertexAttrConstants.PROFILEVERTEXANDNORMAL);this.vertexBufferLayout.hasField(e.PathVertexAttrConstants.FEATUREVALUE)&&m(e.PathVertexAttrConstants.FEATUREVALUE);w.writeDefaultAttributes(a,this.vertexBufferLayout,b.transformation,b.invTranspTransformation,c,g)};return k}();r.PathMaterial=p;Object.defineProperty(r,"__esModule",{value:!0})});